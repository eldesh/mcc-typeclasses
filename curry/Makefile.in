# Makefile for the Curry library
#
# $Id: Makefile.in 2627 2008-02-18 07:44:02Z wlux $
#
# Copyright (c) 2004-2008, Wolfgang Lux
# See ../LICENSE for the full license.
#

@SET_MAKE@

# package information
PACKAGE = @PACKAGE_TARNAME@
VERSION = @PACKAGE_VERSION@

# source directory
top_srcdir = @top_srcdir@
srcdir = @srcdir@

# install directories
prefix = @prefix@
exec_prefix = @exec_prefix@
bindir = @bindir@
libdir = @libdir@

# configuration variables
# set to stdlib/debug to enable and to no to disable buidling of standard
# and debugging libraries, resp.
# note that the prelude is always compiled
stdlib = @STDLIB@
debug = @DEBUG@

# compiler definitions
CC = @CC@
CPPFLAGS = -I../runtime -I$(top_srcdir)/runtime -I$(srcdir) @CPPFLAGS@
CFLAGS = @CFLAGS@

AR = ar
RANLIB = @RANLIB@

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_DIR = @INSTALL_DIR@

# file lists
curry_prelude_SRCS = \
	Prelude.curry \
	Ptr.curry \
	StablePtr.curry \
	Ratio.curry \
	IO.curry
curry_stdlib_SRCS  = \
	AllSolutions.curry \
	Array.curry \
	Bits.curry \
	CError.curry \
	CForeign.curry \
	CString.curry \
	CTypes.curry \
	Char.curry \
	Combinatorial.curry \
	Directory.curry \
	FiniteMap.curry \
	Float.curry \
	Foreign.curry \
	ForeignPtr.curry \
	IOExts.curry \
	IOVector.curry \
	Ix.curry \
	Integer.curry \
	Lexing.curry \
	List.curry \
	MarshalAlloc.curry \
	MarshalError.curry \
	MarshalUtils.curry \
	Maybe.curry \
	Monad.curry \
	NameSupply.curry \
	Numeric.curry \
	Parser.curry \
	Ports.curry \
	Random.curry \
	Read.curry \
	Set.curry \
	Socket.curry \
	Success.curry \
	System.curry \
	Time.curry \
	Trace.curry \
	Unsafe.curry
curry_stdlib_HDRS = \
	CError.h \
	Socket.h

curry_SRCS = $(curry_prelude_SRCS) $(curry_$(stdlib:yes=stdlib)_SRCS)
curry_INTF = $(curry_SRCS:.curry=.icurry)
curry_CSRC = $(curry_INTF:.icurry=.c)
curry_DCSRC= $(curry_INTF:.icurry=.d.c)
curry_OBJS = $(curry_INTF:.icurry=.o)
curry_DOBJS= $(curry_INTF:.icurry=.d.o)
curry_LIBS = libcurry.a

debug_SRCS = DebugPrelude.curry
debug_INTF = $(debug_SRCS:.curry=.icurry)
debug_CSRC = $(debug_INTF:.icurry=.c) $(curry_DCSRC)
debug_OBJS = $(debug_INTF:.icurry=.o) $(curry_DOBJS)
debug_LIBS = libcurry_g.a

DISTFILES = Makefile.in Prelude.icurry-boot Ratio.icurry-boot \
	    $(curry_prelude_SRCS) $(curry_stdlib_SRCS) \
	    $(curry_stdlib_HDRS) $(debug_SRCS)
DISTFILES_PATH = $(DISTFILES:%=@srcdir@/%)
BINDISTFILES = $(curry_SRCS) $($(debug:yes=debug)_SRCS) \
	       $(curry_INTF) $($(debug:yes=debug)_INTF) \
	       $(curry_LIBS) $($(debug:yes=debug)_LIBS)

# Getting the dependencies right for the runtime system header files
# is a little bit tricky as most of them are found in the runtime source
# directory. However, config.h is located in the build directory which
# may be different from the source directory.
# The definitions are a little bit involved in order to avoid a duplicate
# target warning under Gnu make when the source and build directory are
# the same.
# NB Don't replace @top_srcdir@ by $(top_srcdir) in the definition of
#    rts_H_PATH:sh as Solaris make does not perform variable substitutions
#    in the command (BSD make does, however).

rts_LIB = ../runtime/libcurry.a
rts_H_PATH = $(shell echo $(top_srcdir)/runtime/*.h)
rts_H_PATH:sh = echo @top_srcdir@/runtime/*.h
rts_H = ../runtime/config.h $(rts_H_PATH:@top_srcdir@/runtime/config.h=)

# suffix rules
.SUFFIXES: .curry .icurry .c .o .d.c .d.o
.curry.c:
	rm -rf .$*
	mkdir .$*
	../cycc $(CYCCFLAGS) $($*_CYCCFLAGS) --split-code -o .$*/$* $<
	touch $@
.curry.d.c:
	rm -rf .$*.d
	mkdir .$*.d
	../cycc -g --trusted $(CYCCFLAGS) $($*_CYCCFLAGS) --split-code -o .$*.d/$* $<
	touch $@
.c.icurry:
	@test -f $@ || (echo "$@ does not exist!"; echo "Remove $< and run make again."; exit 1)
.c.o:
	fail=; \
	set .$*/*.c; test "$$1" = ".$*/*.c" || \
	for f in $$*; do \
		$(CC) $(CPPFLAGS) $(CFLAGS) -c $$f \
			-o .$*/`basename $$f .c`.o || \
			case "$(MFLAGS)" in -*k* | *' '-k*) fail=yes;; *) exit $$?;; esac; \
	done; \
	test -z "$$fail"
	touch $@
# this rule is going to make BSD make happy
.d.c.d.o:
	fail=; \
	set .$*.d/*.c; test "$$1" = ".$*.d/*.c" || \
	for f in $$*; do \
		$(CC) $(CPPFLAGS) $(CFLAGS) -c $$f \
			-o .$*.d/`basename $$f .c`.o || \
			case "$(MFLAGS)" in -*k* | *' '-k*) fail=yes;; *) exit $$?;; esac; \
	done; \
	test -z "$$fail"
	touch $@

# default target, build the Curry library
all: curry

# Curry modules
curry: $(curry_LIBS) $($(debug:yes=debug)_LIBS)
icurry: $(curry_INTF) $($(debug:yes=debug)_INTF)
ccurry: $(curry_CSRC) $($(debug:yes=debug)_CSRC)

$(curry_CSRC) $(debug_CSRC): ../cycc
$(curry_DCSRC): DebugPrelude.icurry
$(curry_OBJS) $(debug_OBJS): $(rts_H)

obj_dirs = sed -e 's/\([A-Za-z_.]*\)\.o/.\1/g'

libcurry.a: $(rts_LIB) $(curry_OBJS) $(curry_INTF)
	cp $(rts_LIB) $@
	find `echo $(curry_OBJS) | $(obj_dirs)` -name '*.o' | \
		xargs $(AR) q $@
	$(RANLIB) $@
libcurry_g.a: $(debug_OBJS) $(debug_INTF) $(curry_INTF)
	rm -f $@
	find `echo $(debug_OBJS) | $(obj_dirs)` -name '*.o' | \
		xargs $(AR) qc $@
	$(RANLIB) $@

# special rules handling mutual recursion between Prelude, Ratio, and IO
boot_filter = sed -e '/import IO;/d' -e '/IO\./d'

bootstrap:
	cmp -s Prelude.icurry $(srcdir)/Prelude.icurry-boot || \
		$(boot_filter) $(srcdir)/Prelude.icurry-boot > Prelude.icurry
	cmp -s Ratio.icurry $(srcdir)/Ratio.icurry-boot || \
		$(boot_filter) $(srcdir)/Ratio.icurry-boot > Ratio.icurry

Prelude.c: Prelude.curry
	rm -rf .Prelude
	mkdir .Prelude
	../cycc $(CYCCFLAGS) $(Prelude_CYCCFLAGS) --split-code -o .Prelude/Prelude Prelude.curry
	touch Prelude.c
	cmp -s Prelude.icurry $(srcdir)/Prelude.icurry-boot || \
		{ cp -p Prelude.icurry $(srcdir)/Prelude.icurry-boot && \
		  $(MAKE) $(MFLAGS) Ratio.icurry IO.icurry; }

Ratio.c: Ratio.curry $(srcdir)/Prelude.icurry-boot
	$(MAKE) bootstrap
	rm -rf .Ratio
	mkdir .Ratio
	../cycc $(CYCCFLAGS) $(Ratio_CYCCFLAGS) --split-code -o .Ratio/Ratio Ratio.curry
	touch Ratio.c
	cmp -s Ratio.icurry $(srcdir)/Ratio.icurry-boot || \
		cp -p Ratio.icurry $(srcdir)/Ratio.icurry-boot
Ratio.d.c: Prelude.icurry
Ratio.o: Prelude.icurry

IO.c: IO.curry $(srcdir)/Prelude.icurry-boot
	$(MAKE) bootstrap
	rm -rf .IO
	mkdir .IO
	../cycc $(CYCCFLAGS) $(IO_CYCCFLAGS) --split-code -o .IO/IO IO.curry
	touch IO.c
IO.d.c: Prelude.icurry
IO.o: Prelude.icurry

# link all source files into the current directory
# NB if $(srcdir) is a relative path we have to modify the paths for target
#    files which are located in subdirectories
.DEFAULT:
	@test ! -r $@ -a -f $(srcdir)/$@ && \
	(test -d $(@D) || mkdir $(@D)) && \
	if expr $(srcdir) : '/.*' >/dev/null; then \
		(case "$(MFLAGS)" in -*s* | *' '-s*) ;; *) set -x;; esac; \
		 ln -s $(srcdir)/$@ $@); \
	else \
		srcdir=`echo $@ | sed -e 's:[^/]*$$::' -e 's:[^/]*/:../:g'` && \
		(case "$(MFLAGS)" in -*s* | *' '-s*) ;; *) set -x;; esac; \
		 ln -s $${srcdir}$(srcdir)/$@ $@); \
	fi

# install the binaries
install: $(curry_LIBS) $($(debug:yes=debug)_LIBS)
	$(INSTALL_DIR) $(DESTDIR)$(libdir)
	$(INSTALL_DIR) $(DESTDIR)$(libdir)/curry-$(VERSION)
	for f in $(curry_SRCS) $($(debug:yes=debug)_SRCS) $(curry_INTF) $($(debug:yes=debug)_INTF) $(curry_LIBS) $($(debug:yes=debug)_LIBS); do \
		$(INSTALL_DATA) $$f $(DESTDIR)$(libdir)/curry-$(VERSION); \
	done
	for a in $(DESTDIR)$(libdir)/curry-$(VERSION)/*.a; do \
		$(RANLIB) $$a; \
	done

# build the distributions
# NB distdir must be set by the caller
distdir:
	cp $(DISTFILES_PATH) $(distdir)
bindistdir: $(BINDISTFILES)
	cp $(BINDISTFILES) $(distdir)/lib
	for a in $(distdir)/lib/*.a; do $(RANLIB) $$a; done

# automatic reconfiguration
$(top_srcdir)/configure: $(top_srcdir)/configure.in $(top_srcdir)/aclocal.m4
	cd $(top_srcdir) && autoconf

.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in ../config.status
	cd .. && ./config.status curry/Makefile
	$(MAKE) $(MFLAGS) depend

.PRECIOUS: ../config.status
../config.status: $(top_srcdir)/configure
	cd .. && ./config.status --recheck

# clean up
mostlyclean:
	rm -f $(curry_CSRC) $(curry_INTF) $(curry_OBJS)
	rm -f $(debug_CSRC) $(debug_INTF) $(debug_OBJS)
	rm -rf $(curry_OBJS:%.o=.%) $(debug_OBJS:%.o=.%)
	rm -f $(curry_LIBS) $(debug_LIBS) core *.core
clean: mostlyclean
	for f in $(curry_prelude_SRCS) $(curry_stdlib_SRCS) $(debug_SRCS); do \
		if test -h $$f; then rm $$f; fi; \
	done
distclean: clean
	-rm -f Makefile .depend
	-rm -f *~ a.out *.bak *.BAK TAGS
maintainerclean: distclean

# dependencies
# NB This is a poor hack for computing the dependencies without cymake
#    (which may not be available at the time when this rule in executed)
depend: $(curry_prelude_SRCS) $(curry_stdlib_SRCS) $(debug_SRCS)
	(for f in $(curry_prelude_SRCS) $(curry_stdlib_SRCS) $(debug_SRCS); do \
		stem=`basename $$f .curry`; o="$$stem.c $$stem.d.c"; \
		echo $$o : $$f; \
		case $$f in \
			Prelude.curry | Ratio.curry | IO.curry ) ;; \
			* ) echo $$o : Prelude.icurry ;; \
		esac; \
		sed -e '/^import/!d;s/import \([A-Za-z0-9_]*\).*/'"$$o : "'\1.icurry/' $(srcdir)/$$f; \
	 done) > .depend

# include computed dependencies
include .depend

# additional foreign header dependencies
CError.o: $(srcdir)/CError.h
Socket.o: $(srcdir)/Socket.h
