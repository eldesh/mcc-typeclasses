interface Prelude where {
import Ratio;
infix 4 ==;
infix 4 /=;
infixl 7 /;
infixl 7 `quot`;
infixl 7 `rem`;
infixl 7 `div`;
infixl 7 `mod`;
infixl 1 >>=;
infixl 1 >>;
infixl 6 +;
infixl 6 -;
infixl 7 *;
infix 4 <;
infix 4 <=;
infix 4 >=;
infix 4 >;
infixr 5 :;
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixr 5 ++;
infixr 9 .;
infix 4 =/=;
infix 4 =:=;
infixr 0 ?;
infix 4 `elem`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
data () = ();
data (,) a b = (,) a b;
data (,,) a b c = (,,) a b c;
data (,,,) a b c d = (,,,) a b c d;
data (,,,,) a b c d e = (,,,,) a b c d e;
data (,,,,,) a b c d e f = (,,,,,) a b c d e f;
data (,,,,,,) a b c d e f g = (,,,,,,) a b c d e f g;
data (,,,,,,,) a b c d e f g h = (,,,,,,,) a b c d e f g h;
data (,,,,,,,,) a b c d e f g h i = (,,,,,,,,) a b c d e f g h i;
data (,,,,,,,,,) a b c d e f g h i j
  = (,,,,,,,,,) a b c d e f g h i j;
data (,,,,,,,,,,) a b c d e f g h i j k
  = (,,,,,,,,,,) a b c d e f g h i j k;
data (,,,,,,,,,,,) a b c d e f g h i j k l
  = (,,,,,,,,,,,) a b c d e f g h i j k l;
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
  = (,,,,,,,,,,,,) a b c d e f g h i j k l m;
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
  = (,,,,,,,,,,,,,) a b c d e f g h i j k l m n;
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
  = (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o;
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
  = (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p;
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
  = (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q;
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
  = (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r;
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
  = (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s;
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
  = (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t;
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
  = (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u;
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
  = (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
			    v;
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
  = (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
			     u v w;
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
  = (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
			      u v w x;
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
  = (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
			       t u v w x y;
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
  = (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
				t u v w x y z;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
				 s t u v w x y z a1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
				  s t u v w x y z a1 b1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
				   r s t u v w x y z a1 b1 c1;
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
				    r s t u v w x y z a1 b1 c1 d1;
data (->) a b;
data Bool = False | True;
class Bounded a where {
minBound :: a;
maxBound :: a
};
data Char;
data Either a b = Left a | Right b;
class Enum a where {
succ :: a -> a;
pred :: a -> a;
toEnum :: Int -> a;
fromEnum :: a -> Int;
enumFrom :: a -> [a];
enumFromThen :: a -> a -> [a];
enumFromTo :: a -> a -> [a];
enumFromThenTo :: a -> a -> a -> [a]
};
class Eq a where {
(==) :: a -> a -> Bool;
(/=) :: a -> a -> Bool
};
type FilePath = [Char];
data Float;
class Num a => Fractional a where {
(/) :: a -> a -> a;
recip :: a -> a;
fromRational :: Ratio.Ratio Integer -> a
};
class (Functor :: * -> *) a where {
fmap :: (b -> c) -> a b -> a c
};
data IO a;
type IOError = [Char];
data Int;
data Integer;
class (Enum a, Real a) => Integral a where {
quot :: a -> a -> a;
rem :: a -> a -> a;
div :: a -> a -> a;
mod :: a -> a -> a;
quotRem :: a -> a -> (a, a);
divMod :: a -> a -> (a, a);
toInt :: a -> Int;
toInteger :: a -> Integer
};
data Maybe a = Nothing | Just a;
class (Monad :: * -> *) a where {
return :: b -> a b;
(>>=) :: a b -> (b -> a c) -> a c;
(>>) :: a b -> a c -> a c;
fail :: [Char] -> a b
};
class (Eq a, Show a) => Num a where {
(+) :: a -> a -> a;
(-) :: a -> a -> a;
(*) :: a -> a -> a;
negate :: a -> a;
abs :: a -> a;
signum :: a -> a;
fromInt :: Int -> a;
fromInteger :: Integer -> a
};
class Eq a => Ord a where {
compare :: a -> a -> Ordering;
(<) :: a -> a -> Bool;
(<=) :: a -> a -> Bool;
(>=) :: a -> a -> Bool;
(>) :: a -> a -> Bool;
min :: a -> a -> a;
max :: a -> a -> a
};
data Ordering = LT | EQ | GT;
class (Num a, Ord a) => Real a where {
toRational :: a -> Ratio.Ratio Integer
};
class (Fractional a, Real a) => RealFrac a where {
properFraction :: Integral b => a -> (b, a);
truncate :: Integral b => a -> b;
round :: Integral b => a -> b;
ceiling :: Integral b => a -> b;
floor :: Integral b => a -> b
};
class Show a where {
showsPrec :: Int -> a -> [Char] -> [Char];
show :: a -> [Char];
showList :: [a] -> [Char] -> [Char]
};
type ShowS = [Char] -> [Char];
type String = [Char];
data Success;
data [] a = [] | (:) a [a];
type Ratio.Rational = Ratio.Ratio Integer;
(!!) :: [a] -> Int -> a;
($) :: (a -> b) -> a -> b;
($!) :: (a -> b) -> a -> b;
($!!) :: (a -> b) -> a -> b;
($#) :: (a -> b) -> a -> b;
($##) :: (a -> b) -> a -> b;
(&) :: Success -> Success -> Success;
(&&) :: Bool -> Bool -> Bool;
(&>) :: Success -> a -> a;
(++) :: [a] -> [a] -> [a];
(.) :: (a -> b) -> (c -> a) -> c -> b;
(=/=) :: a -> a -> Success;
(=:=) :: a -> a -> Success;
(?) :: a -> a -> a;
all :: (a -> Bool) -> [a] -> Bool;
and :: [Bool] -> Bool;
any :: (a -> Bool) -> [a] -> Bool;
appendFile :: [Char] -> [Char] -> IO ();
best :: (a -> Success) -> (a -> a -> Bool) -> [a -> Success];
break :: (a -> Bool) -> [a] -> ([a], [a]);
browse :: Show a => (a -> Success) -> IO ();
browseList :: Show a => [a -> Success] -> IO ();
catch :: {-# ARITY 3 #-} IO a -> ([Char] -> IO a) -> IO a;
chr :: Int -> Char;
concat :: [[a]] -> [a];
concatMap :: (a -> [b]) -> [a] -> [b];
const :: a -> b -> a;
curry :: ((a, b) -> c) -> a -> b -> c;
doSolve :: Success -> IO ();
done :: Monad a => a ();
drop :: Int -> [a] -> [a];
dropWhile :: (a -> Bool) -> [a] -> [a];
either :: (a -> b) -> (c -> b) -> Either a c -> b;
elem :: {-# ARITY 1 #-} Eq a => a -> [a] -> Bool;
ensureGround :: a -> a;
ensureNotFree :: a -> a;
ensureSpine :: [a] -> [a];
error :: [Char] -> a;
failed :: a;
filter :: (a -> Bool) -> [a] -> [a];
findall :: (a -> Success) -> [a];
findfirst :: (a -> Success) -> a;
flip :: (a -> b -> c) -> b -> a -> c;
foldl :: (a -> b -> a) -> a -> [b] -> a;
foldl1 :: (a -> a -> a) -> [a] -> a;
foldr :: (a -> b -> b) -> b -> [a] -> b;
foldr1 :: (a -> a -> a) -> [a] -> a;
fromIntegral :: (Integral a, Num b) => a -> b;
fst :: (a, b) -> a;
getChar :: IO Char;
getContents :: IO [Char];
getLine :: IO [Char];
head :: [a] -> a;
id :: a -> a;
if_then_else :: Bool -> a -> a -> a;
inject :: (a -> Success) -> (a -> Success) -> a -> Success;
interact :: ([Char] -> [Char]) -> IO ();
ioError :: {-# ARITY 2 #-} [Char] -> IO a;
iterate :: (a -> a) -> a -> [a];
length :: [a] -> Int;
lines :: [Char] -> [[Char]];
lookup :: Eq a => a -> [(a, b)] -> Maybe b;
map :: (a -> b) -> [a] -> [b];
mapIO :: (a -> IO b) -> [a] -> IO [b];
mapIO_ :: (a -> IO b) -> [a] -> IO ();
mapM :: Monad b => (a -> b c) -> [a] -> b [c];
mapM_ :: Monad b => (a -> b c) -> [a] -> b ();
maybe :: a -> (b -> a) -> Maybe b -> a;
not :: Bool -> Bool;
notElem :: {-# ARITY 1 #-} Eq a => a -> [a] -> Bool;
null :: [a] -> Bool;
once :: {-# ARITY 1 #-} (a -> Success) -> a -> Success;
or :: [Bool] -> Bool;
ord :: Char -> Int;
otherwise :: Bool;
print :: Show a => a -> IO ();
putChar :: {-# ARITY 0 #-} Char -> IO ();
putStr :: {-# ARITY 0 #-} [Char] -> IO ();
putStrLn :: {-# ARITY 0 #-} [Char] -> IO ();
readFile :: [Char] -> IO [Char];
realToFrac :: (Real a, Fractional b) => a -> b;
repeat :: a -> [a];
replicate :: Int -> a -> [a];
reverse :: [a] -> [a];
seq :: a -> b -> b;
sequence :: {-# ARITY 0 #-} Monad a => [a b] -> a [b];
sequenceIO :: {-# ARITY 0 #-} [IO a] -> IO [a];
sequenceIO_ :: {-# ARITY 0 #-} [IO a] -> IO ();
sequence_ :: {-# ARITY 0 #-} Monad a => [a b] -> a ();
showChar :: Char -> [Char] -> [Char];
showParen :: {-# ARITY 2 #-} Bool -> ([Char] -> [Char]) ->
			     [Char] -> [Char];
showString :: [Char] -> [Char] -> [Char];
shows :: {-# ARITY 0 #-} Show a => a -> [Char] -> [Char];
snd :: (a, b) -> b;
solveAll :: (a -> Success) -> [a -> Success];
span :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt :: Int -> [a] -> ([a], [a]);
success :: Success;
tail :: [a] -> [a];
take :: Int -> [a] -> [a];
takeWhile :: (a -> Bool) -> [a] -> [a];
try :: (a -> Success) -> [a -> Success];
uncurry :: (a -> b -> c) -> (a, b) -> c;
undefined :: a;
unknown :: a;
unlines :: [[Char]] -> [Char];
unpack :: (a -> Success) -> a;
until :: (a -> Bool) -> (a -> a) -> a -> a;
unwords :: [[Char]] -> [Char];
unzip :: [(a, b)] -> ([a], [b]);
unzip3 :: [(a, b, c)] -> ([a], [b], [c]);
words :: [Char] -> [[Char]];
writeFile :: [Char] -> [Char] -> IO ();
zip :: [a] -> [b] -> [(a, b)];
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) :: Bool -> Bool -> Bool;
instance Bounded ();
instance (Bounded a, Bounded b) => Bounded (a, b);
instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c);
instance (Bounded a, Bounded b, Bounded c, Bounded d) =>
	 Bounded (a, b, c, d);
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
	 Bounded (a, b, c, d, e);
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
	  Bounded f) =>
	 Bounded (a, b, c, d, e, f);
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
	  Bounded f, Bounded g) =>
	 Bounded (a, b, c, d, e, f, g);
instance Bounded Bool;
instance Bounded Char;
instance Enum ();
instance Enum Bool;
instance Enum Char;
instance Eq ();
instance (Eq a, Eq b) => Eq (a, b);
instance (Eq a, Eq b, Eq c) => Eq (a, b, c);
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d);
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e);
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
	 Eq (a, b, c, d, e, f);
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
	 Eq (a, b, c, d, e, f, g);
instance Eq Bool;
instance Eq Char;
instance (Eq a, Eq b) => Eq (Either a b);
instance Eq a => Eq [a];
instance Enum Float;
instance Eq Float;
{-# DATA Ratio.Ratio a #-};
instance Fractional Float;
instance Functor [];
instance Functor IO;
instance Bounded Int;
instance Enum Int;
instance Eq Int;
instance Enum Integer;
instance Eq Integer;
instance Integral Int;
instance Integral Integer;
instance Eq a => Eq (Maybe a);
instance Functor Maybe;
instance Monad IO;
instance Monad Maybe;
instance Monad [];
instance Num Float;
instance Num Int;
instance Num Integer;
instance Ord ();
instance (Ord a, Ord b) => Ord (a, b);
instance (Ord a, Ord b, Ord c) => Ord (a, b, c);
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d);
instance (Ord a, Ord b, Ord c, Ord d, Ord e) =>
	 Ord (a, b, c, d, e);
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
	 Ord (a, b, c, d, e, f);
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
	 Ord (a, b, c, d, e, f, g);
instance Ord Bool;
instance Ord Char;
instance (Ord a, Ord b) => Ord (Either a b);
instance Ord Float;
instance Ord Int;
instance Ord Integer;
instance Ord a => Ord (Maybe a);
instance Ord a => Ord [a];
instance Bounded Ordering;
instance Enum Ordering;
instance Eq Ordering;
instance Ord Ordering;
instance Real Float;
instance Real Int;
instance Real Integer;
instance RealFrac Float;
instance Show ();
instance (Show a, Show b) => Show (a, b);
instance (Show a, Show b, Show c) => Show (a, b, c);
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d);
instance (Show a, Show b, Show c, Show d, Show e) =>
	 Show (a, b, c, d, e);
instance (Show a, Show b, Show c, Show d, Show e, Show f) =>
	 Show (a, b, c, d, e, f);
instance (Show a, Show b, Show c, Show d, Show e, Show f,
	  Show g) =>
	 Show (a, b, c, d, e, f, g);
instance Show Bool;
instance Show Char;
instance (Show a, Show b) => Show (Either a b);
instance Show Float;
instance Show Int;
instance Show Integer;
instance Show a => Show (Maybe a);
instance Show Ordering;
instance Show a => Show [a];
instance Show Success;
instance Integral a => Enum (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a => Eq (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a =>
	 Fractional (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a => Num (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a => Ord (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a => Real (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a =>
	 RealFrac (Ratio.Ratio a) {-# MODULE Ratio #-};
instance Integral a => Show (Ratio.Ratio a) {-# MODULE Ratio #-}
}
