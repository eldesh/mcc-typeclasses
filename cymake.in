#! /bin/sh
# @configure_input@
#
# Shell script for building Curry programs
#
# $Id: cymake.in 2821 2009-05-07 16:31:23Z wlux $
#
# Copyright (c) 2002-2009, Wolfgang Lux
# See LICENSE for the full license.
#


# Configuration parameters
cymake=`basename $0`
version=@PACKAGE_VERSION@
build="%BUILD_DATE%"
prefix=@prefix@
exec_prefix=@exec_prefix@
bindir=@bindir@
libdir=@libdir@
# DO NOT DELETE: Beginning of in-place configuration
srcdir="@srcdir@"
@in_place_config@
# DO NOT DELETE: End of in-place configuration
: ${CYC=$bindir/cyc-$version}
: ${CURRY_PATH=$libdir/curry-$version}
: ${CURRY_IMPORT_PATH=$CURRY_PATH}
export CYC CURRY_PATH CURRY_IMPORT_PATH

# Local variables
echo=echo
exec=
verbose=
cyc=$CYC
cymk=$CURRY_PATH/cymk
newer=$CURRY_PATH/newer
progress=${CURRY_CYMAKE_PROGRESS-:}
mkopts=
cyopts=
ldopts=
linkAlways=
goal=
typeIt=
output=
clean=
find=
depend=
imports=
libs=
files=
temps=

# Functions
noecho ( ) { return 0; }

check_source ( ) {
  stem=`expr "$1" : '\(.*\)'$2`
  for suffix in $3; do
    if test -f "$stem$suffix"; then return 0; fi
  done
  echo 1>&2 "$cymake: missing source file for $1"
  return 1
}

remove ( ) {
  case $f in	## Dirty trick to remove the correct executable with -o FILENAME
    *.curry | *.lcurry | *.o ) target=;;
    * ) target=$f;;
  esac
  for f in "$@"; do
    if test "$target" = "$f" -a -n "$output"; then f=$output; fi
    if test -f "$f"; then
      $echo rm -f "$f"
      $exec rm -f "$f"
    fi
  done
}

compile ( ) {
  i=$1 n=$2 source=$3 object=$4; shift 4
  if $newer "$object" "$source" "$@"; then
    $progress $i $n skipping "$source"
  else
    $progress $i $n compiling "$source"
    $echo $cyc $cyopts -c "$source" -o "$object"
    $exec $cyc $cyopts -c "$source" -o "$object"
  fi
}

link ( ) {
  if test -n "$output"; then target=$output; else target=$3; fi;
  i=$1 n=$2; shift 3
  if test -n "$goal"; then
    $progress $i $n linking "$target"
    $echo $cyc $cyopts $ldopts -e "$goal" -o "$target" "$@" $libs
    $exec $cyc $cyopts $ldopts -e "$goal" -o "$target" "$@" $libs
  elif test -n "$typeIt"; then
    $progress $i $n linking ""
    if test -n "$output"; then set dummy -o "$output" "$@"; shift; fi
    $echo $cyc $cyopts -T "$typeIt" "$@"
    $exec $cyc $cyopts -T "$typeIt" "$@"
  elif test -z "$linkAlways" && $newer "$target" "$@"; then
    $progress $i $n skipping ""
  else
    $progress $i $n linking "$target"
    $echo $cyc $cyopts $ldopts -o "$target" "$@" $libs
    $exec $cyc $cyopts $ldopts -o "$target" "$@" $libs
  fi
}

# Option processing
while test $# -gt 0; do
  case $1 in
    # Overall options
    -M | --depend ) depend=$1;;
    -[cCS] ) echo 1>&2 "$cymake: unsupported option $1"; exit 1;;
    -a ) linkAlways="$1";;
    -e ) goal=$2; shift;;
    -e* ) goal=`expr X"$1" : X'-e\(.*\)'`;;
    -T ) typeIt=$2; shift;;
    -T* ) typeIt=`expr X"$1" : X'-T\(.*\)'`;;
    -g | --debug ) mkopts="$mkopts $1"; cyopts="$cyopts $1";;
    --clean ) clean=--clean;;
    --find ) find=--find;;
    -o ) output="$2"; shift;;
    -o* ) output=`expr X"$1" : X'-o\(.*\)'`;;
    -n ) exec=echo;;
    -v ) verbose=-v; echo=echo cyopts="$cyopts -v";;
    -q ) echo=noecho;;

    # Include files and imported modules
    -i | -P ) cyopts="$cyopts $1 $2"; imports="$imports $1 $2"; shift;;
    -i* | -P* ) cyopts="$cyopts $1"; imports="$imports $1";;

    # Linker options
    -ldopt-* | -ldopts-* | --ldopt-* | --ldopts-* ) ldopts="$ldopts $1";;
    -ldopt | -ldopts | --ldopt | --ldopts ) ldopts="$ldopts $1 $2"; shift;;
    -L ) ldopts="$ldopts -L$2"; shift;;
    -L* ) ldopts="$ldopts $1";;
    -l ) libs="$libs -l$2"; shift;;
    -l* ) libs="$libs $1";;

    # Pass all other flags to the Curry compiler
    # NB some options require an argument; must keep this list in sync with cyc
    -[DUIFhkt] | -cc | -ccopt | --ccopt | -ccopts | --ccopts | -arch | -framework )
	 cyopts="$cyopts $1 $2"; shift;;
    -* ) cyopts="$cyopts $1";;

    +RTS )
	shift
	cyopts="$cyopts +RTS"
	while test $# -gt 0 -a "$1" != "-RTS"; do
	  cyopts="$cyopts $1";
	  shift
	done
	cyopts="$cyopts -RTS";;

    # Pass archive files and shared libraries to the linker
    *.a | *.so | *.dylib | *.dll ) libs="$libs $1";;

    # Save all files
    * ) files="$files $1";;
  esac
  shift
done
set dummy $depend $clean $find; shift
if test $# -gt 1; then
  echo 1>&2 "$cymake: specify only one of -M, --clean, and --find"
  exit 1
fi

# Eventually display the compiler version
test -n "$verbose" && echo 1>&2 "$cymake version $version (built on $build)"
test "$exec" && verbose= echo=noecho

# Generate only dependencies if requested
if test -n "$depend$find"; then
  if test -z "$files"; then
    echo 1>&2 "$cymake: no targets"
    exit 1
  fi
  test -n "$output" && mkopts="$mkopts -o $output"
  test -n "$verbose" && echo 1>&2 $cymk $depend $find $mkopts $imports $files
  $exec $cymk $depend $find $mkopts $imports $files
  exit $?
fi

# Check for input files
if test -z "$files$goal$typeIt"; then
  test -n "$verbose" && exit 0
  echo 1>&2 "$cymake: no targets"
  exit 1
fi

# Remove build script upon exit
trap 'rc=$?; rm -f /tmp/cymake$$; exit $rc' 0 1 2 3 15

# Process all targets
set dummy $files; shift
if test -n "$output" -a $# -gt 1; then
  echo 1>&2 "$cymake: cannot specify -o with multiple targets"
  exit 1
fi
if test -n "$goal" -a $# -gt 1; then
  echo 1>&2 "$cymake: cannot specify -e with multiple targets"
  exit 1
fi
if test -n "$typeIt" -a $# -gt 1; then
  echo 1>&2 "$cymake: cannot specify -T with multiple targets"
  exit 1
fi
if test -n "$goal" -a -n "$typeIt"; then
  echo 1>&2 "$cymake: conflicting options -e and -T specified"
  exit 1
fi


if test $# -eq 0; then
  if test -n "$clean"; then
    test -n "$output" || output=a.out
    remove $output
  else
    link 1 1 a.out
  fi
  exit $?
fi

for f in $files; do
  suffixes=".lcurry .curry"
  case $f in
    *.curry ) suffix=.curry suffixes=.curry;;
    *.lcurry ) suffix=.lcurry suffixes=.lcurry;;
    *.o ) suffix=.o;;
    * ) suffix=;;
  esac
  check_source "$f" "$suffix" "$suffixes" || exit $?
  if test -n "$goal$typeIt"; then
    test -n "$verbose" && echo 1>&2 $cymk $clean $mkopts -e \""$goal$typeIt"\" $imports $f
    $cymk $clean $mkopts -e "$goal$typeIt" -o /tmp/cymake$$ $imports $f
  else
    test -n "$verbose" && echo 1>&2 $cymk $clean $mkopts $imports $f
    $cymk $clean $mkopts -o /tmp/cymake$$ $imports $f
  fi

  . /tmp/cymake$$
  set +e
done

# done
exit 0
