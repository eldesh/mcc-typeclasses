% -*- LaTeX -*-
% $Id: newer.lhs 3136 2013-05-12 15:53:27Z wlux $
%
% Copyright (c) 2002-2013, Wolfgang Lux
% See LICENSE for the full license.
%
\nwfilename{newer.lhs}
\section{Compute whether a file is out of date}
Unfortunately, not all versions of the Unix \verb|test| utility
support the switches \verb|-nt| and \verb|-ot| to compare the
modification dates of their arguments. Even worse, on some systems
(e.g., Solaris 7) the \verb|test| program supports these switches but
the default Bourne shell has a builtin \verb|test| that does not
handle them.

In order to avoid complex dependencies on the operating system, we use
our own program to check whether a file is out of date with respect to
some or all of its dependencies. If the checked file does not exist it
is considered out of date as well and an error occurs if any of the
dependencies does not exist.

The program exits with return code 0 if the file is not out of date
and 1 otherwise. In case of an error, the program exits with return
code 2.

Note that the program silently ignores dependencies whose name starts
with \texttt{-M}. This is done in order to ease processing of the
\texttt{link} commands generated by the \texttt{CurryDeps} module (see
Sect.~\ref{sec:dependencies}).
\begin{verbatim}

> import Directory
> import IO
> import List
> import System
> import Time
> import Utils

> main =
>   do
>     prog <- getProgName
>     args <- getArgs
>     b <- newer prog args
>     exitWith (if b then ExitSuccess else ExitFailure 1)

> badUsage prog =
>   do
>     putErrLn ("usage: " ++ prog ++ " FILE DEPENDENCIES...")
>     exitWith (ExitFailure 2)

> newer prog [] = badUsage prog
> newer prog (file:deps) =
>   IO.catch (do t <- getModificationTime file
>                allM (isNewer t) (filter (not . ("-M" `isPrefixOf`)) deps))
>            (const (return False))

> isNewer t file =
>   IO.catch (do t' <- getModificationTime file; return (t > t'))
>            (\ioe -> do print ioe; exitWith (ExitFailure 2))

> allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
> allM f xs = andM (map f xs)

> andM :: Monad m => [m Bool] -> m Bool
> andM = foldr (>>&) (return True)
>   where m1 >>& m2 = m1 >>= \b -> if b then m2 else return False

\end{verbatim}
