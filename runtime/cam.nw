% -*- noweb-code-mode: c-mode -*-
% $Id: cam.nw 2346 2007-06-23 10:23:59Z wlux $
%
% Copyright (c) 2001-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Abstract Machine Code Macros}
The header file [[cam.h]] defines a few useful macros for writing
external functions.

@ 
The macros [[SAVE_RET]]$n$ can be used to save $n$ values and the
contents of the return address register to the stack.

<<cam.h>>=
#define SAVE_RET0()		SAVE_RET(0, ())
#define SAVE_RET1(x)		SAVE_RET(1, (x))
#define SAVE_RET2(x,y)		SAVE_RET(2, (x,y))
#define SAVE_RET3(x,y,z)	SAVE_RET(3, (x,y,z))
#define SAVE_RET4(x,y,z,t)	SAVE_RET(4, (x,y,z,t))

#define SAVE_RET(n,args) {	       \
	CHECK_STACK(n+1);	       \
	regs.sp -= n+1;		       \
	DO_SAVE_RET_##n args;	       \
	regs.sp[n] = (Node *)regs.ret; \
    }

#define DO_SAVE_RET_0()		/* empty */
#define DO_SAVE_RET_1(x)	DO_SAVE_RET_0();      regs.sp[0] = (x)
#define DO_SAVE_RET_2(x,y)	DO_SAVE_RET_1(x);     regs.sp[1] = (y)
#define DO_SAVE_RET_3(x,y,z)	DO_SAVE_RET_2(x,y);   regs.sp[2] = (z)
#define DO_SAVE_RET_4(x,y,z,t)	DO_SAVE_RET_3(x,y,z); regs.sp[3] = (t)

@ 
The frequently used special case of saving the argument registers
\texttt{regs.r[1]} to \texttt{regs.r[$n$]} together with the return
address register is implemented by the macro [[SAVE_REGS]].

<<cam.h>>=
#define SAVE_REGS(n)	SAVE_REGS_##n
#define SAVE_REGS_0	SAVE_RET0()
#define SAVE_REGS_1	SAVE_RET1(regs.r[1])
#define SAVE_REGS_2	SAVE_RET2(regs.r[1], regs.r[2])
#define SAVE_REGS_3	SAVE_RET3(regs.r[1], regs.r[2], regs.r[3])
#define SAVE_REGS_4	SAVE_RET4(regs.r[1], regs.r[2], regs.r[3], regs.r[4])

@ 
The macros [[EXEC]]$n(f,\emph{arg}_1,\dots,\emph{arg}_n)$ implement
tail calls in leaf procedures. They assign the expressions
$\emph{arg}_1$ to $\emph{arg}_n$ to the argument registers
\texttt{regs.r[0]} to \texttt{regs.r[$n-1$]} and then jump to the
entry point of function $f$. Since these macros are used only in leaf
procedures, they must use [[GOTO_INDIR]] in order to invoke the
callee. Note that these macros initialize the argument registers
strictly from left to right and therefore \texttt{regs.r[$i$]} must
not be used in an argument position that is loaded into register
\texttt{regs.r[$j$]} when $i<j$.

<<cam.h>>=
#define EXEC0(f)		DO_EXEC(0,f,())
#define EXEC1(f,x)		DO_EXEC(1,f,(x))
#define EXEC2(f,x,y)		DO_EXEC(2,f,(x,y))
#define EXEC3(f,x,y,z)		DO_EXEC(3,f,(x,y,z))
#define EXEC4(f,x,y,z,t)	DO_EXEC(4,f,(x,y,z,t))

#define DO_EXEC(n,f,args) do { \
	DO_LOAD_REGS_##n args; \
	GOTO_INDIR(f);	       \
    } while ( 0 )

#define DO_LOAD_REGS_0()	/* empty */
#define DO_LOAD_REGS_1(x)	DO_LOAD_REGS_0();      regs.r[0] = (x)
#define DO_LOAD_REGS_2(x,y)	DO_LOAD_REGS_1(x);     regs.r[1] = (y)
#define DO_LOAD_REGS_3(x,y,z)   DO_LOAD_REGS_2(x,y);   regs.r[2] = (z)
#define DO_LOAD_REGS_4(x,y,z,t)	DO_LOAD_REGS_3(x,y,z); regs.r[3] = (t)

@ 
Two important special cases of [[EXEC1]] are implemented by the macros
[[RET]] and [[ENT]]. [[RET(x)]] returns [[x]] and [[ENT(x)]] enters
the evaluation method of [[x]]. Since both macros do not change the
return address register, they are supposed to be used only in leaf
procedures.

<<cam.h>>=
#define RET(x)			EXEC1(regs.ret, x)
#define ENT(x)			EXEC1((x)->info->eval, x)

@ 
The macros [[CALL]]$n(f,k,\emph{arg}_1,\dots,\emph{arg}_n)$ and
[[CALL_INDIR]]$n(f,k,\emph{arg}_1,\dots,\emph{arg}_n)$ implement
recursive calls. Similar to the [[EXEC]]$n$ macros, they assign the
expressions $\emph{arg}_1$ to $\emph{arg}_n$ to the argument registers
\texttt{regs.r[0]} to \texttt{regs.r[$n-1$]} and jump to the entry
point of function $f$. In addition, these macros also assign the
return address $k$ to the return address register [[regs.ret]]. The
[[CALL]]$n$ macros use [[GOTO]] and the [[CALL_INDIR]]$n$ macros use
[[GOTO_INDIR]] in order to invoke the callee. Therefore, recursive
calls in the entry code of a function must use [[CALL_INDIR]]$n$,
whereas [[CALL]]$n$ maybe used in all other functions.

<<cam.h>>=
#define CALL0(f,k)		DO_CALL(GOTO,0,f,k,())
#define CALL1(f,k,x)		DO_CALL(GOTO,1,f,k,(x))
#define CALL2(f,k,x,y)		DO_CALL(GOTO,2,f,k,(x,y))
#define CALL3(f,k,x,y,z)	DO_CALL(GOTO,3,f,k,(x,y,z))
#define CALL4(f,k,x,y,z,t)	DO_CALL(GOTO,4,f,k,(x,y,z,t))

#define CALL_INDIR0(f,k)	 DO_CALL(GOTO_INDIR,0,f,k,())
#define CALL_INDIR1(f,k,x)	 DO_CALL(GOTO_INDIR,1,f,k,(x))
#define CALL_INDIR2(f,k,x,y)	 DO_CALL(GOTO_INDIR,2,f,k,(x,y))
#define CALL_INDIR3(f,k,x,y,z)	 DO_CALL(GOTO_INDIR,3,f,k,(x,y,z))
#define CALL_INDIR4(f,k,x,y,z,t) DO_CALL(GOTO_INDIR,4,f,k,(x,y,z,t))

#define DO_CALL(goto,n,f,k,args) do { \
	DO_LOAD_REGS_##n args;	      \
	regs.ret = k;		      \
	goto(f);		      \
    } while ( 0 )

@ 
An important special case of [[CALL1]] and [[CALL_INDIR1]],
respectively, is implemented by the macros [[CALL_ENT(x,k)]] and
[[CALL_INDIR_ENT(x,k)]], which call the evaluation method of [[x]]
such that execution continues at address [[k]] after the argument has
been evaluated.

<<cam.h>>=
#define CALL_ENT(x,k)		CALL1((x)->info->eval, k, x)
#define CALL_INDIR_ENT(x,k)	CALL_INDIR1((x)->info->eval, k, x)

@ 
The macros [[CALL_RET]]$n(f,m,\emph{arg}_1,\dots,\emph{arg}_n)$
implement tail calls in non-leaf procedures. They assign the
expressions $\emph{arg}_1$ to $\emph{arg}_n$ to the argument registers
\texttt{regs.r[0]} to \texttt{regs.[$n-1$]}, restore [[regs.ret]] from
the stack, drop $m$ values from the stack, and then jump to the entry
point of function $f$. Note that even though [[CALL_RET]]$n$ drops the
current stack frame, it is safe to use \texttt{regs.sp[$i$]} in an
argument expression. These macro always use [[GOTO]] in order to
invoke the callee because they are not useful in the entry code of a
function.

<<cam.h>>=
#define CALL_RET0(f,m)		DO_CALL_RET(0,f,m,())
#define CALL_RET1(f,m,x)	DO_CALL_RET(1,f,m,(x))
#define CALL_RET2(f,m,x,y)	DO_CALL_RET(2,f,m,(x,y))
#define CALL_RET3(f,m,x,y,z)	DO_CALL_RET(3,f,m,(x,y,z))
#define CALL_RET4(f,m,x,y,z,t)	DO_CALL_RET(4,f,m,(x,y,z,t))

#define DO_CALL_RET(n,f,m,args) do {  \
	DO_LOAD_REGS_##n args;	      \
	regs.ret = (Label)regs.sp[m]; \
	regs.sp += m + 1;	      \
	GOTO(f);		      \
    } while ( 0 )

@
The macros [[RETURN]] and [[ENTER]] implement two special cases of
[[CALL_RET1]]. [[RETURN(x,n)]] returns [[x]] and [[ENTER(x,n)]] jumps
to the evaluation method of [[x]]. Both functions restore their return
address from the stack and drop [[n]] values from the stack. Note that
[[RETURN]] must use [[GOTO_INDIR]] rather than [[GOTO]].

<<cam.h>>=
#define RETURN(x,n) do {		 \
	Label _ret_ = (Label)regs.sp[n]; \
	regs.r[0]   = (x);		 \
	regs.sp	   += n + 1;		 \
	GOTO_INDIR(_ret_);		 \
    } while ( 0 )

#define ENTER(x,n) do {			\
	Node *node = (x);		\
	regs.r[0]  = node;		\
	regs.ret   = (Label)regs.sp[n]; \
	regs.sp	  += n + 1;		\
	GOTO(node->info->eval);		\
    } while ( 0 )

@ 
The macros [[EVAL]], [[EVAL_INDIR]], [[EVAL_NODE]] and
[[EVAL_INDIR_NODE]] evaluate the argument in register
\texttt{regs.r[0]} and continue execution at the specified label after
the argument is evaluated to head normal form. The [[EVAL]] and
[[EVAL_INDIR]] macros are prepared to handle tagged characters and
tagged integers, whereas the [[EVAL_NODE]] and [[EVAL_INDIR_NODE]]
macros assume that the argument register always contains a node
pointer.

<<cam.h>>=
#define EVAL(l) do {							\
    for (;;) {								\
	if ( is_tagged_ptr(regs.r[0]) )					\
	    switch ( regs.r[0]->info->kind ) {				\
	    case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue;	\
	    case LAZY_KIND: regs.ret = (l); GOTO(regs.r[0]->info->eval); \
	    }								\
	break;								\
    }									\
    GOTO_INDIR(l);							\
} while ( 0 )

#define EVAL_INDIR(l) do {						\
    for (;;) {								\
	if ( is_tagged_ptr(regs.r[0]) )					\
	    switch ( regs.r[0]->info->kind ) {				\
	    case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue;	\
	    case LAZY_KIND: regs.ret = (l); GOTO_INDIR(regs.r[0]->info->eval); \
	    }								\
	break;								\
    }									\
    GOTO_INDIR(l);							\
} while ( 0 )

#define EVAL_NODE(l) do {					     \
    for (;;) {							     \
	switch ( regs.r[0]->info->kind ) {			     \
	case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue;    \
	case LAZY_KIND: regs.ret = (l); GOTO(regs.r[0]->info->eval); \
	}							     \
	break;							     \
    }								     \
    GOTO_INDIR(l);						     \
} while ( 0 )

#define EVAL_INDIR_NODE(l) do {					     \
    for (;;) {							     \
	switch ( regs.r[0]->info->kind ) {			     \
	case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue;    \
	case LAZY_KIND: regs.ret = (l); GOTO_INDIR(regs.r[0]->info->eval); \
	}							     \
	break;							     \
    }								     \
    GOTO_INDIR(l);						     \
} while ( 0 )

@ 
The macro [[SWAPn]] exchanges the arguments in register
\texttt{regs.r[0]} and at offset $n$ in the stack. This is useful for
functions with two or more arguments that must be evaluated.

<<cam.h>>=
#define SWAPn(n) do {		 \
	Node *aux  = regs.r[0];	 \
	regs.r[0]  = regs.sp[n]; \
	regs.sp[n] = aux;	 \
    } while ( 0 )

@
The [[FAIL]] macro invokes the current failure handler.

<<cam.h>>=
#define FAIL(msg) do {		   \
	regs.r[0] = (Node *)msg;   \
	GOTO(regs.handlers->fail); \
    } while ( 0 )

@
The following macros implement (kind) matching of the argument in
register \texttt{regs.r[0]}, which is expected to be in head normal
form already. The macros [[MATCH_RIGID_CHAR]], [[MATCH_RIGID_INT]],
and [[MATCH_RIGID]] carefully check for tagged characters and tagged
integers while the other macros assume that the argument is always a
node pointer. The argument of all macros is the label where execution
is resumed after an unbound variable has been instantiated. In general
this is the entry point of the function that uses the [[MATCH]] macro.

<<cam.h>>=
#define MATCH_RIGID_NODE(what, l)				  \
    for (;;) {							  \
	switch ( regs.r[0]->info->kind ) {			  \
	case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue; \
	case LVAR_KIND: regs.ret = (l); GOTO(sync_var);		  \
	case what##_KIND: break;				  \
	default: invalid_arg(#l, regs.r[0]->info->kind);	  \
	}							  \
	break;							  \
    }

#if NO_POINTER_TAGS
# define MATCH_RIGID_CHAR(l)		MATCH_RIGID_NODE(CHAR, l)
# define MATCH_RIGID_INT(l)		MATCH_RIGID_NODE(INT, l)
#endif
#define MATCH_RIGID_FLOAT(l)		MATCH_RIGID_NODE(FLOAT, l)
#define MATCH_RIGID_PTR(l)		MATCH_RIGID_NODE(PTR, l)
#define MATCH_RIGID_FOREIGN_PTR(l)	MATCH_RIGID_NODE(FOREIGN_PTR, l)
#define MATCH_RIGID_DATA(l)		MATCH_RIGID_NODE(CAPP, l)
#define MATCH_RIGID_PAPP(l)		MATCH_RIGID_NODE(PAPP, l)
#define MATCH_RIGID_VECTOR(l)		MATCH_RIGID_NODE(VECTOR, l)
#define MATCH_RIGID_ABSTRACT(l)		MATCH_RIGID_NODE(ABSTRACT, l)

#if !NO_POINTER_TAGS
#define MATCH_RIGID_CHAR(l)					      \
    for (;;) {							      \
	if ( is_tagged_ptr(regs.r[0]) )				      \
	    switch ( regs.r[0]->info->kind ) {			      \
	    case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue; \
	    case LVAR_KIND: regs.ret = (l); GOTO(sync_var);	      \
	    default: invalid_arg(#l, regs.r[0]->info->kind);	      \
	    }							      \
	break;							      \
    }

# define MATCH_RIGID_INT(l)					      \
    for (;;) {							      \
	if ( is_tagged_ptr(regs.r[0]) )				      \
	    switch ( regs.r[0]->info->kind ) {			      \
	    case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue; \
	    case LVAR_KIND: regs.ret = (l); GOTO(sync_var);	      \
	    case INT_KIND: break;				      \
	    default: invalid_arg(#l, regs.r[0]->info->kind);	      \
	    }							      \
	break;							      \
    }
#endif

#define MATCH_RIGID(l)						      \
    for (;;) {							      \
	if ( is_tagged_ptr(regs.r[0]) )				      \
	    switch ( regs.r[0]->info->kind ) {			      \
	    case INDIR_KIND: regs.r[0] = regs.r[0]->n.node; continue; \
	    case LVAR_KIND: regs.ret = (l); GOTO(sync_var);	      \
	    }							      \
	break;							      \
    }
