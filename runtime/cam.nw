% -*- noweb-code-mode: c-mode -*-
% $Id: cam.nw 2262 2007-06-16 14:46:48Z wlux $
%
% Copyright (c) 2001-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Abstract Machine Code Macros}
The header file [[cam.h]] defines a few useful macros for writing
external functions.

@
The [[RETURN]] and [[ENTER]] macros return the value on the top of the
stack to the caller of the current function. [[RETURN]] must be used
only if the value is known to be in head normal form. Otherwise, the
[[ENTER]] macro must be used, which starts the evaluation of the node
with a tail call to its evaluation method unless the node is already
in head normal form.

<<cam.h>>=
#define RETURN(_res) {		      \
    Label ret_ip = (Label)regs.sp[0]; \
    regs.sp[0]	 = (_res);	      \
    GOTO(ret_ip);		      \
}

#define ENTER(_node) {		   \
    if ( is_boxed(_node) ) {	   \
	CHECK_STACK1();		   \
	*--regs.sp = (_node);	   \
	GOTO((_node)->info->eval); \
    }				   \
    RETURN(_node);		   \
}

@ 
The macros [[EVAL]] and [[EVAL_BOXED]] evaluate the node on the top of
the stack and continue execution at the specified label after the node
is evaluated to head normal form.

<<cam.h>>=
#define EVAL(l)	do {							\
    for (;;) {								\
	if ( is_boxed(regs.sp[0]) )					\
	    switch ( regs.sp[0]->info->kind ) {				\
	    case INDIR_KIND: regs.sp[0] = regs.sp[0]->n.node; continue;	\
	    case LAZY_KIND:						\
		CHECK_STACK1(); regs.sp -= 1;				\
		regs.sp[0] = regs.sp[1]; regs.sp[1] = (Node *)(l);	\
		GOTO(regs.sp[0]->info->eval);				\
	    }								\
	break;								\
    }									\
    GOTO(l);								\
} while ( 0 )

#define EVAL_BOXED(l) do {					    \
    for (;;) {							    \
	switch ( regs.sp[0]->info->kind ) {			    \
	case INDIR_KIND: regs.sp[0] = regs.sp[0]->n.node; continue; \
	case LAZY_KIND:						    \
	    CHECK_STACK1(); regs.sp -= 1;			    \
	    regs.sp[0] = regs.sp[1]; regs.sp[1] = (Node *)(l);	    \
	    GOTO(regs.sp[0]->info->eval);			    \
	}							    \
	break;							    \
    }								    \
    GOTO(l);							    \
} while ( 0 )

@ 
The macro [[SWAPn]] exchanges the nodes at the top of the stack and at
offset $n$. This is useful for functions with two or more arguments
that must be evaluated.

<<cam.h>>=
#define SWAPn(n) do {		 \
	Node *aux  = regs.sp[0]; \
	regs.sp[0] = regs.sp[n]; \
	regs.sp[n] = aux;	 \
    } while ( 0 )

@
The [[FAIL]] macro invokes the current failure handler.

<<cam.h>>=
#define FAIL() GOTO(regs.handlers->fail)

@
The following macros implement (kind) matching of the node on the top
of the stack, which is expected to be in head normal form already.
[[MATCH_RIGID_INT]] and [[MATCH_RIGID]] carefully check for unboxed
values while the other macros assume that the node on the top of the
stack is always boxed. The argument of all macros is the label where
execution is resumed after an unbound variable has been instantiated.
In general this is the entry point of the function that uses the
[[MATCH]] macro.

<<cam.h>>=
#define MATCH_RIGID_BOXED(what, l)				    \
    for (;;) {							    \
	switch ( regs.sp[0]->info->kind ) {			    \
	case INDIR_KIND: regs.sp[0] = regs.sp[0]->n.node; continue; \
	case LVAR_KIND:						    \
	    CHECK_STACK1(); regs.sp -= 1;			    \
	    regs.sp[0] = regs.sp[1]; regs.sp[1] = (Node *)(l);	    \
	    GOTO(sync_var);					    \
	case what##_KIND: break;				    \
	default: invalid_arg(#l, regs.sp[0]->info->kind);	    \
	}							    \
	break;							    \
    }

#define MATCH_RIGID_CHAR(l)		MATCH_RIGID_BOXED(CHAR, l)
#define MATCH_RIGID_FLOAT(l)		MATCH_RIGID_BOXED(FLOAT, l)
#define MATCH_RIGID_PTR(l)		MATCH_RIGID_BOXED(PTR, l)
#define MATCH_RIGID_FOREIGN_PTR(l)	MATCH_RIGID_BOXED(FOREIGN_PTR, l)
#define MATCH_RIGID_DATA(l)		MATCH_RIGID_BOXED(CAPP, l)
#define MATCH_RIGID_PAPP(l)		MATCH_RIGID_BOXED(PAPP, l)
#define MATCH_RIGID_VECTOR(l)		MATCH_RIGID_BOXED(VECTOR, l)
#define MATCH_RIGID_ABSTRACT(l)		MATCH_RIGID_BOXED(ABSTRACT, l)

#define MATCH_RIGID_INT(l)						\
    for (;;) {								\
	if ( is_boxed(regs.sp[0]) )					\
	    switch ( regs.sp[0]->info->kind ) {				\
	    case INDIR_KIND: regs.sp[0] = regs.sp[0]->n.node; continue;	\
	    case LVAR_KIND:						\
		CHECK_STACK1(); regs.sp -= 1;				\
		regs.sp[0] = regs.sp[1]; regs.sp[1] = (Node *)(l);	\
		GOTO(sync_var);						\
	    case INT_KIND: break;					\
	    default: invalid_arg(#l, regs.sp[0]->info->kind);		\
	    }								\
	break;								\
    }

#define MATCH_RIGID(l)							\
    for (;;) {								\
	if ( is_boxed(regs.sp[0]) )					\
	    switch ( regs.sp[0]->info->kind ) {				\
	    case INDIR_KIND: regs.sp[0] = regs.sp[0]->n.node; continue;	\
	    case LVAR_KIND:						\
		CHECK_STACK1(); regs.sp -= 1;				\
		regs.sp[0] = regs.sp[1]; regs.sp[1] = (Node *)(l);	\
		GOTO(sync_var);						\
	    }								\
	break;								\
    }
