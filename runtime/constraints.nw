% -*- noweb-code-mode: c-mode -*-
% $Id: constraints.nw 2854 2009-05-29 12:33:07Z wlux $
%
% Copyright (c) 2002-2009, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Concurrent Conjunction}\label{sec:concurrent}
This file implements the concurrent conjunction of two constraints
\texttt{(\&)}.

<<constraints.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "search.h"
#include "cam.h"

@
The code for a concurrent conjunction of two constraints creates a new
thread only when both arguments are unevaluated applications. In that
case, the first argument is evaluated in the child thread and the
parent thread evaluates the second argument. After evaluating the
second argument, the parent thread is suspended until the first
constraint is solved. If the first argument is an updatable
application node, this is achieved by evaluating the first argument in
the parent after the second one. If the first argument is a
non-updatable application, a fresh queue-me node is created for this
purpose.

\textbf{Don't try to avoid allocating a fresh queue-me node by
  flipping the arguments if the first argument is a non-updatable
  application and the second one is an updatable application, since
  this would destroy the global thread order maintained by the thread
  management code.} %'

Note that an unbound variable can be returned from a concurrent
conjunction, This follows the specification
\begin{verbatim}
  success & y = y
  x & success = x
\end{verbatim}
It is up to the caller to decide how an unbound variable is handled.
For instance, in the implementation of concurrent conjunction below,
the current thread is delayed until the first argument is instantiated
when both arguments are unbound variables.

\ToDo{Make the implementation of \texttt{\&} more symmetric in this
  case so that the current thread is woken after either of the
  variables is instantiated.}

<<constraints.c>>=
DECLARE_LABEL(extern, ___38_);
DECLARE_LABEL(static, ___38__1);
DECLARE_LABEL(static, ___38__2);
DECLARE_LABEL(static, ___38__3);

FUNCTION(___38_)
{
    Node *c1, *c2, *aux;
 ENTRY_LABEL(extern, ___38_)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.r[1]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;

    switch ( node_kind(c1) )
    {
    case FAPP_KIND:
	switch ( node_kind(c2) )
	{
	case GAPP_KIND:
	case SUSPEND_KIND:
	case FAPP_KIND:
	    regs.r[0] = c1;
	    regs.r[1] = c2;
	    CHECK_HEAP(2, queueMe_node_size);
	    aux	      = (Node *)regs.hp;
	    aux->info = queueMe_info_table;
	    aux->q.wq = 0;
	    regs.hp  += queueMe_node_size;

	    SAVE_RET2(aux, regs.r[1]);
	    regs.r[1] = aux;
	    start_thread(2, ___38__1);

	    SAVE_REGS(1);
	    CALL_ENT(regs.r[0], update);
	}
	/* FALL THROUGH!!! */
    case SUSPEND_KIND:
	switch ( node_kind(c2) )
	{
	case GAPP_KIND:
	case SUSPEND_KIND:
	case FAPP_KIND:
	    SAVE_RET2(c1, c2);
	    regs.r[0] = c1;
	    start_thread(1, ___38__1);
	    ENT(regs.r[0]);
	case QUEUEME_KIND:
	case LVAR_KIND:
	case GVAR_KIND:
	    SAVE_RET1(c2);
	    CALL_ENT(c1, ___38__2);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	ENT(c1);

    case QUEUEME_KIND:
	switch ( node_kind(c2) )
	{
	case GAPP_KIND:
	case SUSPEND_KIND:
	case FAPP_KIND:
	    SAVE_RET1(c1);
	    CALL_ENT(c2, ___38__2);
	case QUEUEME_KIND:
	case LVAR_KIND:
	case GVAR_KIND:
	    SAVE_RET1(c2);
	    CALL_ENT(c1, ___38__2);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	ENT(c1);

    case GAPP_KIND:
	switch ( node_kind(c2) )
	{
	case GAPP_KIND:
	    regs.r[0] = c1->g.node;
	    regs.r[1] = c2->g.node;
	    suspend_search(2, regs.bp->btSpc);
	    GOTO(___38_);
	case SUSPEND_KIND:
	case FAPP_KIND:
	    /* Note: no concurrent evaluation possible here */
	    SAVE_RET2(c1, c2);
	    CALL_ENT(c1, ___38__1);
	case QUEUEME_KIND:
	case LVAR_KIND:
	case GVAR_KIND:
	    SAVE_RET1(c2);
	    CALL_ENT(c1, ___38__2);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	ENT(c1);

    case LVAR_KIND:
    case GVAR_KIND:
	/* evaluate the other argument then delay */
	switch ( node_tag(c2) )
	{
	case EVAL_TAG:
	    SAVE_RET1(c1);
	    CALL_ENT(c2, ___38__2);
	case LVAR_TAG:
	    SAVE_RET1(c2);
	    CALL1(sync_var, ___38__3, c1);
	}
	RET(c1);

    default:
	assert(node_kind(c1) == CAPP_KIND);
    }

    /* trivial case */
    if ( c2->info->tag == EVAL_TAG )
	ENT(c2);
    RET(c2);
}

static
FUNCTION(___38__1)
{
 ENTRY_LABEL(static, ___38__1)
    CALL_RET2(___38_, 2, regs.sp[0], regs.sp[1]);
}

@
When an argument has been evaluated to head normal form, it must be
either a variable or the constant [[Success]]. In the former case, we
may return the variable if the other argument was evaluated to
[[Success]] in the meantime. In the latter case we can simply return
the other argument to the caller except if it is still a queue-me
node.

<<constraints.c>>=
static
FUNCTION(___38__2)
{
    Node *c1, *c2;
 ENTRY_LABEL(static, ___38__2)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.sp[0]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;

    if ( node_tag(c1) == LVAR_TAG )
    {
	switch ( node_kind(c2) )
	{
	case QUEUEME_KIND:
	    regs.sp[0] = c1;
	    CALL_ENT(c2, ___38__2);
	case LVAR_KIND:
	case GVAR_KIND:
	    regs.sp[0] = c2;
	    CALL1(sync_var, ___38__3, c1);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	RETURN(c1, 1);
    }

    assert(node_kind(c1) == CAPP_KIND);
    if ( node_kind(c2) == QUEUEME_KIND )
	ENTER(c2, 1);
    RETURN(c2, 1);
}

@
After waiting until an unbound variable has been instantiated, we can
always return the other argument. Note that the code below is invoked
only if the other argument was a variable node.

<<constraints.c>>=
static
FUNCTION(___38__3)
{
    Node *c1, *c2;
 ENTRY_LABEL(static, ___38__3)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.sp[0]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;
    assert(node_kind(c1) == CAPP_KIND);
    assert(node_kind(c2) == CAPP_KIND || node_kind(c2) == LVAR_KIND);

    RETURN(c2, 1);
}

@ 
The unsafe function [[spawnConstraint]] forks a new concurrent
computation, but does not wait for its termination. It is defined for
compatibility with PAKCS. No new thread is started when the first
argument is already in head normal form.

<<constraints.c>>=
DECLARE_LABEL(extern, __spawnConstraint);
DECLARE_LABEL(static, __spawnConstraint_1);

FUNCTION(__spawnConstraint)
{
    Node *c, *x;
 ENTRY_LABEL(extern, __spawnConstraint)
    c = regs.r[0];
    for (;;)
    {
	switch ( node_kind(c) )
	{
	case INDIR_KIND:
	    c = c->n.node;
	    continue;
	case GAPP_KIND:
	case SUSPEND_KIND:
	case FAPP_KIND:
	    SAVE_REGS(1);
	    regs.r[0] = c;
	    start_thread(1, __spawnConstraint_1);
	    ENT(regs.r[0]);
	}
	break;
    }

    x = regs.r[1];
    if ( is_tagged_ptr(x) )
	ENT(x);
    RET(x);
}

static
FUNCTION(__spawnConstraint_1)
{
    Node *x;
 ENTRY_LABEL(static, __spawnConstraint_1)
    x = regs.sp[0];
    if ( is_tagged_ptr(x) )
	ENTER(x, 1);
    RETURN(x, 1);
}
