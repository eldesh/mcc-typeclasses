% -*- noweb-code-mode: c-mode -*-
% $Id: constraints.nw 2671 2008-04-21 06:55:42Z wlux $
%
% Copyright (c) 2002-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Concurrent Conjunction}\label{sec:concurrent}
This file implements the concurrent conjunction of two constraints
\texttt{(\&)}.

<<constraints.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "cam.h"

@
The code for a parallel conjunction of two constraints tries to avoid
creating a new thread whenever this is possible. The only case when a
new thread must be started is when both arguments are unevaluated
application nodes. In this case, the evaluation of the first argument
is started on a new thread. In order to synchronize the current thread
and its new child, at least one of the applications must be updatable.
Otherwise, a new queue-me node is created for this purpose.

Note that an unbound variable can be returned from a concurrent
conjunction, This follows the specification
\begin{verbatim}
  success & y = y
  x & success = x
\end{verbatim}
It is up to the caller to decide how an unbound variable is handled.
For instance, in the implementation of concurrent conjunction below,
the current thread is delayed until the first argument is instantiated
when both arguments are unbound variables.

\ToDo{Make the implementation of \texttt{\&} more symmetric in this
  case so that the current thread is woken after either of the
  variables is instantiated.}

<<constraints.c>>=
DECLARE_LABEL(extern, ___38_);
DECLARE_LABEL(static, ___38__1);
DECLARE_LABEL(static, ___38__2);
DECLARE_LABEL(static, ___38__3);

FUNCTION(___38_)
{
    Node *c1, *c2, *aux;
 ENTRY_LABEL(extern, ___38_)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.r[1]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;

    switch ( node_kind(c1) )
    {
    case LAZY_KIND:
	switch ( node_tag(c1) )
	{
	case NOUPD_TAG:
	    if ( node_kind(c2) == LAZY_KIND )
		switch ( node_tag(c2) )
		{
		case NOUPD_TAG:
		    regs.r[0] = c1;
		    regs.r[1] = c2;
		    CHECK_HEAP(2, queueMe_node_size);
		    aux	       = (Node *)regs.hp;
		    aux->info  = queueMe_info_table;
		    aux->q.spc = regs.ss;
		    aux->q.wq  = 0;
		    regs.hp   += queueMe_node_size;

		    SAVE_RET2(aux, regs.r[1]);
		    regs.r[1] = aux;
		    start_thread(2, ___38__1);

		    SAVE_REGS(1);
		    CALL_INDIR_ENT(regs.r[0], update);
		case UPD_TAG:
		    aux = c1;
		    c1	= c2;
		    c2	= aux;
		    break;
		}
	    /* FALL THROUGH!!! */
	case UPD_TAG:
	    switch ( node_kind(c2) )
	    {
	    case LAZY_KIND:
		if ( node_tag(c2) != QUEUEME_TAG )
		{
		    SAVE_RET2(c1, c2);
		    regs.r[0] = c1;
		    start_thread(1, ___38__1);
		    ENT(regs.r[0]);
		}
		/* FALL THROUGH!!! */
	    case LVAR_KIND:
		SAVE_RET1(c2);
		CALL_INDIR_ENT(c1, ___38__2);
	    default:
		assert(node_tag(c2) == CAPP_KIND);
	    }
	    break;

	case QUEUEME_TAG:
	    switch ( node_kind(c2) )
	    {
	    case LAZY_KIND:
		if ( node_kind(c2) != QUEUEME_TAG )
		{
		    SAVE_RET1(c1);
		    CALL_INDIR_ENT(c2, ___38__2);
		}
		/* FALL_THROUGH!!! */
	    case LVAR_KIND:
		SAVE_RET1(c2);
		CALL_INDIR_ENT(c1, ___38__2);
	    default:
		assert(node_kind(c2) == CAPP_KIND);
	    }
	    break;

	default:
	    unexpected_tag("(&)", node_tag(c1));
	}
	ENT(c1);

    case LVAR_KIND:
	/* evaluate the other argument then delay */
	switch ( node_kind(c2) )
	{
	case LAZY_KIND:
	    SAVE_RET1(c1);
	    CALL_INDIR_ENT(c2, ___38__2);
	case LVAR_KIND:
	    SAVE_RET1(c2);
	    CALL1(sync_var, ___38__3, c1);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	RET(c1);

    default:
	assert(node_kind(c1) == CAPP_KIND);
    }

    /* trivial case */
    if ( is_lazy_node(c2) )
	ENT(c2);
    RET(c2);
}

static
FUNCTION(___38__1)
{
 ENTRY_LABEL(static, ___38__1)
    CALL_RET2(___38_, 2, regs.sp[0], regs.sp[1]);
}

@
When an argument has been evaluated to head normal form, it must be
either a variable or the constant [[Success]]. In the former case, we
may return the variable if the other argument was evaluated to
[[Success]] in the meantime. In the latter case we can simply return
the other argument to the caller except if it is still a queue-me
node.

<<constraints.c>>=
static
FUNCTION(___38__2)
{
    Node *c1, *c2;
 ENTRY_LABEL(static, ___38__2)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.sp[0]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;

    if ( node_kind(c1) == LVAR_KIND )
    {
	switch ( node_kind(c2) )
	{
	case LAZY_KIND:
	    assert(node_tag(c2) == QUEUEME_TAG);
	    regs.sp[0] = c1;
	    CALL_ENT(c2, ___38__2);
	case LVAR_KIND:
	    regs.sp[0] = c2;
	    CALL1(sync_var, ___38__3, c1);
	default:
	    assert(node_kind(c2) == CAPP_KIND);
	}
	RETURN(c1, 1);
    }

    assert(node_kind(c1) == CAPP_KIND);
    if ( node_kind(c2) == LAZY_KIND )
    {
	assert(node_tag(c2) == QUEUEME_TAG);
	ENTER(c2, 1);
    }
    RETURN(c2, 1);
}

@
After waiting until an unbound variable has been instantiated, we can
always return the other argument. Note that the code below is invoked
only if the other argument was a variable node.

<<constraints.c>>=
static
FUNCTION(___38__3)
{
    Node *c1, *c2;
 ENTRY_LABEL(static, ___38__3)
    for ( c1 = regs.r[0]; node_kind(c1) == INDIR_KIND; c1 = c1->n.node )
	;
    for ( c2 = regs.sp[0]; node_kind(c2) == INDIR_KIND; c2 = c2->n.node )
	;
    assert(node_kind(c1) == CAPP_KIND);
    assert(node_kind(c2) == CAPP_KIND || node_kind(c2) == LVAR_KIND);

    RETURN(c2, 1);
}

@ 
The unsafe function [[spawnConstraint]] forks a new concurrent
computation, but does not wait for its termination. It is defined for
compatibility with PAKCS. No new thread is started when the first
argument is already in head normal form.

<<constraints.c>>=
DECLARE_LABEL(extern, __spawnConstraint);
DECLARE_LABEL(static, __spawnConstraint_1);

FUNCTION(__spawnConstraint)
{
    Node *c, *x;
 ENTRY_LABEL(extern, __spawnConstraint)
    for ( c = regs.r[0]; node_kind(c) == INDIR_KIND; c = c->n.node )
	;

    if ( node_kind(c) == LAZY_KIND && node_tag(c) != QUEUEME_TAG )
    {
	SAVE_REGS(1);
	regs.r[0] = c;
	start_thread(1, __spawnConstraint_1);
	ENT(regs.r[0]);
    }

    x = regs.r[1];
    if ( is_tagged_ptr(x) )
	ENT(x);
    RET(x);
}

static
FUNCTION(__spawnConstraint_1)
{
    Node *x;
 ENTRY_LABEL(static, __spawnConstraint_1)
    x = regs.sp[0];
    if ( is_tagged_ptr(x) )
	ENTER(x, 1);
    RETURN(x, 1);
}
