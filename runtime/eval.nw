% -*- noweb-code-mode: c-mode -*-
% $Id: eval.nw 2334 2007-06-23 09:33:35Z wlux $
%
% Copyright (c) 2001-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Evaluation}\label{sec:eval}
Every node has an entry point, which is called when the program has to
evaluate a node. The common entry points are defined in this module,
entry points for functions and lazy applications nodes are generated
by the compiler. All entry points are called with the node to be
evaluated on the top of the stack.

<<eval.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "trail.h"
#include "threads.h"
#include "spaces.h"
#include "search.h"
#include "trace.h"
#include "eval.h"
#include "cam.h"

@
Some nodes, e.g. thread nodes, do not represent values and cannot be
evaluated at all. The entry point [[no_eval]] aborts the program if
such a node is ever entered.

<<eval.h>>=
DECLARE_LABEL(extern, no_eval);

@
<<eval.c>>=
FUNCTION(no_eval)
{
 ENTRY_LABEL(extern, no_eval)
    curry_panic("internal error: no_eval entered\n");
}

@ 
Numbers, data constructor applications, and partial applications are
already in weak head normal form.  Their evaluation code,
[[eval_whnf]], simply returns the node to the caller.

<<eval.h>>=
DECLARE_LABEL(extern, eval_whnf);

@
<<eval.c>>=
FUNCTION(eval_whnf)
{
 ENTRY_LABEL(extern, eval_whnf)
    RET(regs.r[0]);
}

@
An indirection node is evaluated by dereferencing the node and calling
the evaluation method of the referenced node. In order to speed up the
evaluation of indirection chains, we use a loop that follows such
chains until finding a node which is not an indirection node. If the
referenced node is a tagged integer, we return to the caller
immediately.

<<eval.h>>=
DECLARE_LABEL(extern, eval_indir);

@
<<eval.c>>=
FUNCTION(eval_indir)
{
    Node *node;
 ENTRY_LABEL(extern, eval_indir)
    node = regs.r[0];
    ASSERT(is_tagged_ptr(node) && is_indir_node(node));

    /* dereference the indirection */
    do
        node = node->n.node;
    while ( is_tagged_ptr(node) && is_indir_node(node) );

    /* enter the node */
    if ( is_tagged_ptr(node) )
	ENT(node);
    RET(node);
}

@
The [[eval_queueMe]] code is used when the node on the top of the
stack is a queue-me node. In this case, the current thread is
suspended until the evaluation of the corresponding application is
finished and the queue-me node is overwritten with the result.

When this code is invoked with an update frame on the top of the
stack, the queue-me node recorded in the update frame is overwritten
with an indirection to the queue-me node just entered and the update
frame is removed from the stack.

As a minor optimization, if the current thread would return to
[[stop_thread]] after the queue-me node being entered is overwritten
with its result, the current thread is terminated immediately.

<<eval.h>>=
DECLARE_LABEL(extern, eval_queueMe);

@
<<eval.c>>=
FUNCTION(eval_queueMe)
{
    Node	*susp, *susp2;
    ThreadQueue wq;
 ENTRY_LABEL(extern, eval_queueMe)
    susp = regs.r[0];
    if ( regs.ret == update )
    {
	susp2 = regs.sp[0];
	assert(is_queueMe_node(susp2) && is_local_space(susp2->q.spc));
	if ( is_local_space(susp->q.spc) || !susp2->q.wq )
	{
	    wq = susp2->q.wq;
#if !COPY_SEARCH_SPACE
	    SAVE(susp2, n.node);
	    susp2->info++;
#else
	    susp2->info	  = &indir_info;
#endif
	    susp2->n.node = susp;

	    if ( wq )
	    {
		wq = join_queues(susp->q.wq, wq);
		if ( wq != susp->q.wq )
		{
		    SAVE(susp, q.wq);
		    susp->q.wq = wq;
		}
	    }

	    regs.ret = (Label)regs.sp[1];
	    regs.sp += 2;
	    if ( regs.ret == stop_thread )
		GOTO(stop_thread);
	}
    }
    else if ( regs.ret == stop_thread )
	GOTO(stop_thread);

    if ( !is_local_space(susp->q.spc) )
	suspend_search(1, susp->q.spc);
    SAVE_RET1(regs.r[0]);
    regs.ret = resume;
    GOTO(suspend_thread);
}

@
When a thread is continued, which has been suspended because of
entering a queue-me node, the node on the top of the stack has to be
dereferenced before actually returning. The [[resume]] code performs
this task. Note that the node on the top of the stack is always in
weak head normal form when [[resume]] is entered. Therefore, it is
safe to return to the caller without entering the result.

<<eval.h>>=
DECLARE_LABEL(extern, resume);

@ 
<<eval.c>>=
FUNCTION(resume)
{
    Node *result;
 ENTRY_LABEL(extern, resume)
    /* dereference the indirection */
    result = regs.sp[0];
    while ( is_tagged_ptr(result) && is_indir_node(result) )
	result = result->n.node;

    /* return to the caller */
    RETURN(result, 1);
}

@
The [[update]] code is responsible for updating a lazy application
node with the result of the application. All threads that were delayed
because they also tried to evaluate the application are woken, but the
current thread is not interrupted.

<<eval.h>>=
DECLARE_LABEL(extern, update);

@
<<eval.c>>=
FUNCTION(update)
{
    Node	*result, *susp;
    ThreadQueue wq;
 ENTRY_LABEL(extern, update)
    result = regs.r[0];
    susp   = regs.sp[0];
    ASSERT(is_tagged_ptr(susp) && is_queueMe_node(susp) &&
	   is_local_space(susp->q.spc));

    /* update the suspended application */
    TRACE(("%I %N = %N\n", susp, result));
    wq = susp->q.wq;
#if !COPY_SEARCH_SPACE
    SAVE(susp, q.wq);
    susp->info++;
#else
    susp->info	 = &indir_info;
#endif
    susp->n.node = result;

    /* wake all threads on the wait-queue of the application */
    if ( wq )
	wake_threads(wq);

    /* return to the caller */
    RETURN(regs.r[0], 1);
}

@ 
When an unbound variable is matched in a rigid switch and when a
non-local variable is matched in a flexible switch, the running thread
is suspended until the variable is instantiated. This is handled by
the runtime system code [[sync_var]], which also ensures that the
bound variable node will be dereferenced after the thread is resumed.

<<eval.h>>=
DECLARE_LABEL(extern, sync_var);

@ 
<<eval.c>>=
FUNCTION(sync_var)
{
 ENTRY_LABEL(extern, sync_var)
    if ( !is_local_space(regs.r[0]->v.spc) )
	suspend_search(1, regs.r[0]->v.spc);
    SAVE_RET1(regs.r[0]);
    regs.ret = resume;
    GOTO(delay_thread);
}

@ 
When stability is enabled, the current thread suspends before it
instantiates an unbound variable non-deterministically. After the
thread is resumed, it must check whether the variable was bound in the
meantime. In this case, execution returns to the beginning of the
switch, otherwise the variable is instantiated non-deterministically.
This check is implemented in the [[flex_yield_resume]] code, which
expects an array with the continuations that instantiate the variable,
the variable node, and the entry point of the switch in that order on
the stack.

<<eval.h>>=
#if YIELD_NONDET
DECLARE_LABEL(extern, flex_yield_resume);
#endif

@ 
<<eval.c>>=
#if YIELD_NONDET
FUNCTION(flex_yield_resume)
{
    Node *node;
 ENTRY_LABEL(extern, flex_yield_resume)
    node = regs.sp[1];
    for (;;)
    {
	if ( is_tagged_ptr(node) )
	    switch ( node->info->kind )
	    {
	    case INDIR_KIND:
		node = node->n.node;
		continue;
	    case LVAR_KIND:
		regs.sp[1] = node;
		GOTO(regs.handlers->choices);
	    }
	break;
    }
    RETURN(node, 2);
}
#endif

@ 
The compiler transforms applications of higher order functions into
first order applications by inserting applications of the (binary)
primitive [[@]]. The code of this function first evaluates the
function argument to a (ground) head normal form. If the result is a
partial application missing exactly one argument, a tail call to its
application entry point is performed. Otherwise, a new partial
application node is returned to the caller. The info vector of the new
closure is computed by using the fact that the node descriptors for
all partial applications of a function are allocated in an array which
is indexed by the number of arguments to which the function is
applied.

Note that the partial application's application entry point expects
the additional argument and the return address on the stack, which
allows jumping to the entry point without restoring the argument and
return address from the stack. %'

Actually, the compiler generates a whole family of functions [[@]]$_n$
for each module and number of arguments $n$ to which an unknown
function is applied in that module. The function [[@]] is defined here
because it is used in other runtime system functions. The compiler
also uses this function in place of [[@]]$_1$.

Note that we do not provide a function info table for [[@]] because
this function is never applied partially.

<<eval.h>>=
DECLARE_LABEL(extern, ___64_);
DECLARE_LABEL(extern, ___64__1);
extern NodeInfo ___64__info, ___64__lazy_info_table[];

@ 
<<eval.c>>=
DECLARE_LABEL(static, eval_clos_2);
DECLARE_LABEL(static, eval_lazy_2);

NodeInfo ___64__info		  = FUNINFO("@", ___64_, 2);
NodeInfo ___64__lazy_info_table[] = LAZYINFO("@", ___64_, 2);

static
FUNCTION(eval_clos_2)
{
    Node *clos;
 ENTRY_LABEL(static, eval_clos_2)
    clos = regs.r[0];
    EXEC2(clos->info->entry, clos->c.args[0], clos->c.args[1]);
}

static
FUNCTION(eval_lazy_2)
{
    Node  *susp, *x, *y;
    Label entry;
 ENTRY_LABEL(static, eval_lazy_2)
    /* suspend the search if the node is not local */
    if ( !is_local_space(regs.r[0]->s.spc) )
	suspend_search(1, regs.r[0]->s.spc);

    /* get the arguments */
    susp  = regs.r[0];
    entry = susp->info->entry;
    x	  = susp->s.args[0];
    y	  = susp->s.args[1];

    /* create an indirection if there is an update frame immediately above */
    if ( regs.ret == update )
    {
#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, n.node);
	    susp->info += 2;
	}
	else
#endif
	    susp->info = &indir_info;
	assert(is_queueMe_node(regs.sp[0]));
	susp->n.node = regs.sp[0];
    }

    /* otherwise, lock the application node and create an update frame */
    else
    {
	SAVE_RET1(susp);
	regs.ret = update;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, q.wq);
	    susp->info++;
	}
	else
#endif
	    susp->info = queueMe_info_table;
	susp->q.wq = 0;
    }

    /* enter the callee */
    EXEC2(entry, x, y);
}

FUNCTION(___64_)
{
 ENTRY_LABEL(extern, ___64_)
    TRACE_FUN("@", 2);
    SAVE_REGS(1);
    EVAL_NODE(___64__1);
}

FUNCTION(___64__1)
{
    unsigned int argc, sz;
    Node	 *clos;
 ENTRY_LABEL(extern, ___64__1)
    MATCH_RIGID_PAPP(___64__1);
    clos = regs.r[0];

    /* evaluate the application if just one argument is missing */
    if ( clos->info->tag == 1 )
	EXEC1(clos->info->apply, clos);

    /* otherwise allocate a new closure for the application */
    assert(clos->info->tag > 1);
    argc = closure_argc(clos);
    sz	 = node_size(clos);
    CHECK_HEAP(1, sz + 1);

    /* create a new closure from the old closure and the argument */
    clos = (Node *)regs.hp;
    memcpy(clos, regs.r[0], sz * word_size);
    clos->info++;
    clos->c.args[argc] = regs.sp[0];
    regs.hp	      += sz + 1;

    /* return to the caller */
    RETURN(clos, 1);
}

@ 
The unsafe primitive function \texttt{isVar} returns \texttt{True} if
its argument evaluates to an unbound variable. This function is
implemented only for compatibility with PAKCS.

<<eval.c>>=
DECLARE_CONST(__Prelude__True);
DECLARE_CONST(__Prelude__False);

DECLARE_LABEL(extern, __isVar);
DECLARE_LABEL(static, __isVar_1);

FUNCTION(__isVar)
{
 ENTRY_LABEL(extern, __isVar)
    SAVE_REGS(0);
    EVAL(__isVar_1);
}

static
FUNCTION(__isVar_1)
{
    Node *r;
 ENTRY_LABEL(static, __isVar_1)
    if ( is_tagged_ptr(regs.r[0]) && is_variable_node(regs.r[0]) )
	r = CONST(__Prelude__True);
    else
	r = CONST(__Prelude__False);
    RETURN(r, 0);
}

@ 
The polymorphic function \texttt{ensureGround} ensures that the normal
form of its argument is a ground data term. This is done lazily so
that \texttt{ensureGround} is semantically equivalent to
\texttt{Prelude.id} otherwise.

<<eval.c>>=
DECLARE_LABEL(extern, __ensureGround);
DECLARE_LABEL(static, __ensureGround_1);

DECLARE_LABEL(static, eval_lazy_1);

static
FUNCTION(eval_lazy_1)
{
    Node  *susp, *x;
    Label entry;
 ENTRY_LABEL(static, eval_lazy_1)
    /* suspend the search if the node is not local */
    if ( !is_local_space(regs.r[0]->s.spc) )
	suspend_search(1, regs.r[0]->s.spc);

    /* get the argument */
    susp  = regs.r[0];
    entry = susp->info->entry;
    x	  = susp->s.args[0];

    /* create an indirection if there is an update frame immediately above */
    if ( regs.ret == update )
    {
#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, n.node);
	    susp->info += 2;
	}
	else
#endif
	    susp->info = &indir_info;
	assert(is_queueMe_node(regs.sp[0]));
	susp->n.node = regs.sp[0];
    }

    /* otherwise, lock the application node and create an update frame */
    else
    {
	SAVE_RET1(susp);
	regs.ret = update;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, q.wq);
	    susp->info++;
	}
	else
#endif
	    susp->info = queueMe_info_table;
	susp->q.wq = 0;
    }

    /* enter the callee */
    EXEC1(entry, x);
}

FUNCTION(__ensureGround)
{
 ENTRY_LABEL(extern, __ensureGround)
    TRACE_FUN("ensureGround", 1);
    SAVE_REGS(0);
    EVAL(__ensureGround_1);
}

static
FUNCTION(__ensureGround_1)
{
    boolean	    is_vect;
    unsigned int    n, sz;
    Node	    *node, **argp, *susp;
    static NodeInfo ensureGround_lazy_info_table[] =
	LAZYINFO("ensureGround", __ensureGround, 1);
 ENTRY_LABEL(static, __ensureGround_1)
    MATCH_RIGID(__ensureGround_1);
    node = regs.r[0];
    if ( is_tagged_ptr(node) )
    {
	switch ( node_kind(node) )
	{
	case VECTOR_KIND:
	    is_vect = true;
	    n	    = vector_argc(node);
	    sz	    = node->a.length;
	    break;
	case CAPP_KIND:
	case PAPP_KIND:
	    is_vect = false;
	    n	    = closure_argc(node);
	    sz	    = node->info->length;
	    break;
	default:
	    is_vect = false;
	    n	    = 0;
	    sz	    = 0;
	    break;
	}

	if ( n > 0 )
	{
	    CHECK_HEAP(1, sz + n * suspend_node_size(1));

	    node = (Node *)(regs.hp + n * suspend_node_size(1));
	    memcpy(node, regs.r[0], sz * word_size);

	    for ( argp = is_vect ? node->a.args : node->c.args;
		  n > 0;
		  argp++, n-- )
	    {
		susp		= (Node *)regs.hp;
		susp->info	= ensureGround_lazy_info_table;
		susp->s.spc	= regs.ss;
		susp->s.args[0]	= *argp;
		regs.hp	       += suspend_node_size(1);

		*argp = susp;
	    }

	    ASSERT((Node *)regs.hp == node);
	    regs.hp += sz;
	}
    }

    RETURN(node, 0);
}
