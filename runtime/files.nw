% -*- noweb-code-mode: c-mode -*-
% $Id: files.nw 2296 2007-06-19 22:37:03Z wlux $
%
% Copyright (c) 2001-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Files}
The functions in this file implement the primitive monadic actions
that read from and write to files and streams. This module has an
initialization function that initializes the standard channels and
optionally changes the buffer mode for standard input and standard
output. Pass [[-1]] as first argument to [[init_files]] in order to
use the default buffer mode.

<<files.h>>=
extern void init_files(int, long);

@ 
<<files.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "spaces.h"
#include "search.h"
#include "trail.h"
#include "eval.h"
#include "data.h"
#include "cstring.h"
#include "cam.h"
#include "io_monad.h"
#include "trace.h"

#if !HAVE_WORKING_VFORK
# define vfork fork
#endif

@ 
Files are implemented as finalized objects so that a file is
closed automatically when it becomes garbage. A file node comprises
its (C) file pointer, a set of flags, and an optional buffer. At
present, two flag bits are used which are set when the file is
readable and writable, respectively. When a file is closed, both bits
are cleared and the file pointer is set to [[0]]. The file is in a
semi-closed state when the readable and writable bits are cleared, but
the file pointer is not [[0]]. This is used for file handles to which
[[hGetContents]] has been applied.

When a file handle that is connected to a process is finalized, the
runtime system tries to read its termination status in order not to
leave zombie processes around. Since the garbage collection
should not be blocked until the process really terminates,
[[finalize_process]] calls [[waitpid]] with the [[WNOHANG]] flag.

<<files.c>>=
#define MATCH_RIGID_FILE(l)	MATCH_RIGID_ABSTRACT(l)

enum file_flags { readable, writable };
#define mask(flag) (1<<(flag))

enum { FILE_TAG, PROCESS_TAG };

#define file_node_size wordsof(Handle)
typedef struct file_node {
    NodeInfo *info;
    FILE     *fp;
    short    flags;
    short    bmode;
    long     bsize;
    char     *buffer;
} Handle;

#define process_node_size wordsof(ProcessHandle)
typedef struct process_node {
    NodeInfo *info;
    FILE     *fp;
    short    flags;
    short    bmode;
    long     bsize;
    char     *buffer;
    pid_t    pid;
    int	     status;
} ProcessHandle;

#define is_open(file)	  ((file)->flags & (mask(readable) | mask(writable)))
#define is_readable(file) ((file)->flags & mask(readable))
#define is_writable(file) ((file)->flags & mask(writable))

static void close_handle(Handle *file);
static void finalize_file(Node *node);
static void finalize_process(Node *node);

static NodeInfo file_info = {
    ABSTRACT_KIND, FILE_TAG, file_node_size, ot_binary, "<Handle>",
    eval_whnf, 0, 0, finalize_file
};

static NodeInfo process_info = {
    ABSTRACT_KIND, PROCESS_TAG, process_node_size, ot_binary, "<ProcessHandle>",
    eval_whnf, 0, 0, finalize_process
};

static void
close_handle(Handle *file)
{
    if ( file->fp )
    {
	fclose(file->fp);
	file->fp    = NULL;
	file->flags = 0;
	if ( file->buffer )
	    free(file->buffer);
    }
}

static void
finalize_file(Node *file)
{
    close_handle((Handle *)file);
}

static void
finalize_process(Node *node)
{
    ProcessHandle *proc = (ProcessHandle *)node;

    finalize_file(node);
    if ( proc->pid )
	waitpid(proc->pid, &proc->status, WNOHANG);
}

@ 
Two file \verb|Handle|s are considered equal, if they are physically
the same.

<<files.c>>=
DECLARE_CONST(__Prelude__False);
DECLARE_CONST(__Prelude__True);

#define Prelude_False CONST(__Prelude__False)
#define Prelude_True  CONST(__Prelude__True)

DECLARE_LABEL(extern, __primEqHandle);
DECLARE_LABEL(static, __primEqHandle_1);
DECLARE_LABEL(static, __primEqHandle_2);

FUNCTION(__primEqHandle)
{
 ENTRY_LABEL(extern, __primEqHandle)
    SAVE_REGS(1);
    EVAL_BOXED(__primEqHandle_1);
}

static
FUNCTION(__primEqHandle_1)
{
 ENTRY_LABEL(static, __primEqHandle_1)
    MATCH_RIGID_FILE(__primEqHandle_1);
    SWAPn(0);
    EVAL_BOXED(__primEqHandle_2);
}

static
FUNCTION(__primEqHandle_2)
{
    Node *r;
 ENTRY_LABEL(static, __primEqHandle_2)
    MATCH_RIGID_FILE(__primEqHandle_2);
    r = regs.sp[0] == regs.r[0] ? Prelude_True : Prelude_False;
    RETURN(r, 1);
}

@ 
The functions [[stdin]], [[stdout]], and [[stderr]] return predefined
handles for the standard file channels. The nodes are allocated
statically in the runtime system. However, the file pointers of these
nodes cannot be initialized statically because under Linux -- in
contrast to most other operating systems -- the standard file
pointers are not declared as pointers into a static array of file
descriptors, but as global variables.

Note that we assume that the standard error channel is always
unbuffered, whereas the setting of the standard input and output
channels is not known -- unless it is changed in [[init_files]].

<<files.c>>=
static Handle stdin_node = {
    &file_info, NULL, mask(readable), -1, 0, NULL
};
static Handle stdout_node = {
    &file_info, NULL, mask(writable), -1, 0, NULL
};
static Handle stderr_node = {
    &file_info, NULL, mask(writable), _IONBF, 0, NULL
};


DECLARE_LABEL(extern, __stdin);
DECLARE_LABEL(extern, __stdout);
DECLARE_LABEL(extern, __stderr);

FUNCTION(__stdin)
{
 ENTRY_LABEL(extern, __stdin)
    RET((Node *)&stdin_node);
}

FUNCTION(__stdout)
{
 ENTRY_LABEL(extern, __stdout)
    RET((Node *)&stdout_node);
}

FUNCTION(__stderr)
{
 ENTRY_LABEL(extern, __stderr)
    RET((Node *)&stderr_node);
}

@
The function [[openFile]] opens a file with the specified file name
and file mode. Files can be opened for reading, writing, and with
read-write access, respectively. The file access mode is specified
using a constant from the type \texttt{IOMode} that is declared as
follows in the library module \texttt{IO}.
\begin{verbatim}
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
\end{verbatim}

\ToDo{\texttt{openFile} should implement the
single-writer/multiple-reader locking semantics mandated by the
Haskell library report.}

<<files.c>>=
enum {
    ReadMode_tag,
    WriteMode_tag,
    AppendMode_tag,
    ReadWriteMode_tag
};

DECLARE_CONST(__IO__ReadMode);
DECLARE_CONST(__IO__WriteMode);
DECLARE_CONST(__IO__AppendMode);
DECLARE_CONST(__IO__ReadWriteMode);

DECLARE_LABEL(extern, __openFile);
DECLARE_LABEL(static, __openFile_1);
DECLARE_LABEL(static, __openFile_2);

FUNCTION(__openFile)
{
 ENTRY_LABEL(extern, __openFile)
    TRACE_FUN("openFile", 3);
    SAVE_REGS(2);
    EVAL_BOXED(__openFile_1);
}

static
FUNCTION(__openFile_1)
{
 ENTRY_LABEL(static, __openFile_1)
    SWAPn(0);
    EVAL_BOXED(__openFile_2);
}

static
FUNCTION(__openFile_2)
{
    const char *fn, *mode;
    int	       flags;
    FILE       *fp;
    Handle     *file;
 ENTRY_LABEL(static, __openFile_2)
    /* determine the access mode */
    MATCH_RIGID_DATA(__openFile_2);
    switch ( node_tag(regs.r[0]) )
    {
    case ReadMode_tag:
	mode  = "r";
	flags = mask(readable);
	break;
    case WriteMode_tag:
	mode  = "w";
	flags = mask(writable);
	break;
    case AppendMode_tag:
	mode  = "a";
	flags = mask(writable);
	break;
    case ReadWriteMode_tag:
	mode  = "r+";
	flags = mask(readable) | mask(writable);
	break;
    default:
	unexpected_tag("openFile (mode)", node_tag(regs.r[0]));
    }

    /* open the file */
    fn = to_string(regs.sp[0]);
    fp = fopen(fn, mode);
    free((char *)fn);
    if ( fp == NULL )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);

    /* create the file node */
    CHECK_HEAP(0, file_node_size);
    file	 = (Handle *)regs.hp;
    file->info	 = &file_info;
    file->fp	 = fp;
    file->flags  = flags;
    file->bmode  = -1;
    file->bsize  = 0;
    file->buffer = NULL;
    regs.hp	+= file_node_size;
    register_final((Node *)file);

    /* return the file */
    RETURN((Node *)file, 2);
}

@ 
The function [[openFd]] is a variant of [[openFile]] that creates a
new file node for a file descriptor.

<<files.c>>=
DECLARE_LABEL(extern, __openFd);
DECLARE_LABEL(static, __openFd_1);
DECLARE_LABEL(static, __openFd_2);

FUNCTION(__openFd)
{
 ENTRY_LABEL(extern, __openFd)
    TRACE_FUN("openFd", 3);
    SAVE_REGS(2);
    EVAL(__openFd_1);
}

static
FUNCTION(__openFd_1)
{
 ENTRY_LABEL(static, __openFd_1)
    MATCH_RIGID_INT(__openFd_1);
    SWAPn(0);
    EVAL_BOXED(__openFd_2);
}

static
FUNCTION(__openFd_2)
{
    const char *mode;
    int	       flags;
    FILE       *fp;
    Handle     *file;
 ENTRY_LABEL(static, __openFd_2)
    /* determine the access mode */
    MATCH_RIGID_DATA(__openFd_2);
    switch ( node_tag(regs.r[0]) )
    {
    case ReadMode_tag:
	mode  = "r";
	flags = mask(readable);
	break;
    case WriteMode_tag:
	mode  = "w";
	flags = mask(writable);
	break;
    case AppendMode_tag:
	mode  = "a";
	flags = mask(writable);
	break;
    case ReadWriteMode_tag:
	mode  = "r+";
	flags = mask(readable) | mask(writable);
	break;
    default:
	unexpected_tag("openFd (mode)", node_tag(regs.r[0]));
    }

    /* open the file */
    fp = fdopen(long_val(regs.sp[0]), mode);
    if ( fp == NULL )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);

    /* create the file node */
    CHECK_HEAP(0, file_node_size);
    file	 = (Handle *)regs.hp;
    file->info	 = &file_info;
    file->fp	 = fp;
    file->flags  = flags;
    file->bmode  = -1;
    file->bsize  = 0;
    file->buffer = NULL;
    regs.hp	+= file_node_size;
    register_final((Node *)file);

    /* return the file */
    RETURN((Node *)file, 2);
}

@
The function [[hClose]] closes a file handle. Calling [[hClose]] for a
closed file handle has no effect.

<<files.c>>=
DECLARE_LABEL(extern, __hClose);
DECLARE_LABEL(static, __hClose_1);

FUNCTION(__hClose)
{
 ENTRY_LABEL(extern, __hClose)
    SAVE_REGS(1);
    EVAL_BOXED(__hClose_1);
}

static
FUNCTION(__hClose_1)
{
 ENTRY_LABEL(static, __hClose_1)
    MATCH_RIGID_FILE(__hClose_1);
    close_handle((Handle *)regs.r[0]);
    RETURN(unit, 1);
}

@
The functions [[hIsOpen]], [[hIsClosed]], [[hIsReadable]],
[[hIsWritable]], and [[hIsSeekable]] test whether these properties
apply to a file handle. Note that for a semi-closed handle neither
[[hIsOpen]] nor [[hIsClosed]] returns \texttt{True}.

<<files.c>>=
DECLARE_LABEL(extern, __hIsOpen);
DECLARE_LABEL(static, __hIsOpen_1);

DECLARE_LABEL(extern, __hIsClosed);
DECLARE_LABEL(static, __hIsClosed_1);

DECLARE_LABEL(extern, __hIsReadable);
DECLARE_LABEL(static, __hIsReadable_1);

DECLARE_LABEL(extern, __hIsWritable);
DECLARE_LABEL(static, __hIsWritable_1);

DECLARE_LABEL(extern, __hIsSeekable);
DECLARE_LABEL(static, __hIsSeekable_1);

FUNCTION(__hIsOpen)
{
 ENTRY_LABEL(extern, __hIsOpen)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsOpen_1);
}

static
FUNCTION(__hIsOpen_1)
{
    Node *r;
 ENTRY_LABEL(static, __hIsOpen_1)
    MATCH_RIGID_FILE(__hIsOpen_1);
    r = is_open((Handle *)regs.r[0]) ? Prelude_True : Prelude_False;
    RETURN(r, 1);
}

FUNCTION(__hIsClosed)
{
 ENTRY_LABEL(extern, __hIsClosed)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsClosed_1);
}

static
FUNCTION(__hIsClosed_1)
{
    Node *r;
 ENTRY_LABEL(static, __hIsClosed_1)
    MATCH_RIGID_FILE(__hIsClosed_1);
    r = ((Handle *)regs.r[0])->fp == NULL ? Prelude_True : Prelude_False;
    RETURN(r, 1);
}

FUNCTION(__hIsReadable)
{
 ENTRY_LABEL(extern, __hIsReadable)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsReadable_1);
}

static
FUNCTION(__hIsReadable_1)
{
    Node *r;
 ENTRY_LABEL(static, __hIsReadable_1)
    MATCH_RIGID_FILE(__hIsReadable_1);
    r = is_readable((Handle *)regs.r[0]) ? Prelude_True : Prelude_False;
    RETURN(r, 1);
}

FUNCTION(__hIsWritable)
{
 ENTRY_LABEL(extern, __hIsWritable)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsWritable_1);
}

static
FUNCTION(__hIsWritable_1)
{
    Node *r;
 ENTRY_LABEL(static, __hIsWritable_1)
    MATCH_RIGID_FILE(__hIsWritable_1);
    r = is_writable((Handle *)regs.r[0]) ? Prelude_True : Prelude_False;
    RETURN(r, 1);
}

FUNCTION(__hIsSeekable)
{
 ENTRY_LABEL(extern, __hIsSeekable)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsSeekable_1);
}

static
FUNCTION(__hIsSeekable_1)
{
    Handle *file;
    Node   *r;
 ENTRY_LABEL(static, __hIsSeekable_1)
    MATCH_RIGID_FILE(__hIsSeekable_1);
    file = (Handle *)regs.r[0];

    if ( !is_open(file) )
	r = Prelude_False;
    else if ( ftell(file->fp) != - 1 )
	r = Prelude_True;
    else
    {
	clearerr(file->fp);
	r = Prelude_False;
    }
    RETURN(r, 1);
}

@
The function [[hIsEOF]] returns whether all of the specified file has
been read, i.e., whether the next call to [[hGetChar]] for the handle
will raise an end-of-file exception.

Note that the semantics of [[hIsEOF]] is different from the C
semantics. Whereas [[hIsEOF]] returns [[True]] after the last
character of the file has been read, the C library sets the
end-of-file condition only after reading the end-of-file character.
Therefore, our implementation reads the next character from the file
and puts it back with [[ungetc]]. Unfortunately, this may block the
program until the next character is available.

<<files.c>>=
DECLARE_LABEL(extern, __hIsEOF);
DECLARE_LABEL(static, __hIsEOF_1);

FUNCTION(__hIsEOF)
{
 ENTRY_LABEL(extern, __hIsEOF)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsEOF_1);
}

static
FUNCTION(__hIsEOF_1)
{
    int	   c;
    Handle *file;
 ENTRY_LABEL(static, __hIsEOF_1)
    MATCH_RIGID_FILE(__hIsEOF_1);
    file = (Handle *)regs.r[0];

    if ( !is_readable(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hIsEOF: handle not readable"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    c = getc(file->fp);
    if ( c == EOF && ferror(file->fp) )
	CALL_RET2(__ioError, 1, from_string(0, strerror(errno)), regs.sp[0]);
    ungetc(c, file->fp);

    RETURN(c == EOF ? Prelude_True : Prelude_False, 1);
}

@ 
The function [[hGetChar]] reads a single character from the specified
input handle. The function raises an end-of-file exception when
reading beyond the last character of the input. An access exception is
reported when the handle is not open for reading. Note that this also
happens when the handle is in a semi-closed state after
[[hGetContents]] has been applied to it.

<<files.c>>=
DECLARE_LABEL(extern, __hGetChar);
DECLARE_LABEL(static, __hGetChar_1);

FUNCTION(__hGetChar)
{
 ENTRY_LABEL(extern, __hGetChar)
    SAVE_REGS(1);
    EVAL_BOXED(__hGetChar_1);
}

static
FUNCTION(__hGetChar_1)
{
    int	   c;
    Handle *file;
 ENTRY_LABEL(static, __hGetChar_1)
    MATCH_RIGID_FILE(__hGetChar_1);
    file = (Handle *)regs.r[0];

    if ( !is_readable(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hGetChar: handle not readable"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    c = getc(file->fp);
    if ( c == EOF )
	CALL_RET2(__ioError, 1,
		  from_string(0,
			      feof(file->fp) ? "End of file" : strerror(errno)),
		  regs.sp[0]);

    RETURN((Node *)(char_table + (c & 0xff)), 1);
}

@
The function [[hLookAhead]] returns the next character from the input
file without removing it from the input stream.

<<files.c>>=
DECLARE_LABEL(extern, __hLookAhead);
DECLARE_LABEL(static, __hLookAhead_1);

FUNCTION(__hLookAhead)
{
 ENTRY_LABEL(extern, __hLookAhead)
    SAVE_REGS(1);
    EVAL_BOXED(__hLookAhead_1);
}

static
FUNCTION(__hLookAhead_1)
{
    int	   c;
    Handle *file;
 ENTRY_LABEL(static, __hLookAhead_1)
    MATCH_RIGID_FILE(__hLookAhead_1);
    file = (Handle *)regs.r[0];

    if ( !is_readable(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hLookAhead: handle not readable"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    c = getc(file->fp);
    if ( c == EOF )
	CALL_RET2(__ioError, 1,
		  from_string(0,
			      feof(file->fp) ? "End of file" : strerror(errno)),
		  regs.sp[0]);
    ungetc(c, file->fp);

    RETURN((Node *)(char_table + (c & 0xff)), 1);
}

@
The function [[hGetLine]] reads a single line from the specified
handle. We implement this function in the runtime system instead of
defining it in terms of [[hIsEOF]] and [[hGetChar]] because this makes
a more efficient implementation possible using the [[fgets]] function.
Note that [[fgets]] retains a newline character in the input buffer;
we have to remove it before converting the string. If no newline has
been read, we continue to read more characters from the standard input
until reaching either the end-of-file or reading a newline character.

Concatenation of the line segments is a little bit tricky. We do not
use the \texttt{(++)} operator from the prelude in order to avoid the
quadratic complexity introduced by it when constructing the string
from left to right. Instead we use an indirection node at the end of
each segment and set its pointer after reading the next segment. Note
that this destructive update does not have to be trailed because
[[hGetLine]] is an atomic action with respect to the Curry runtime
system.

<<files.c>>=
DECLARE_LABEL(extern, __hGetLine);
DECLARE_LABEL(static, __hGetLine_1);

FUNCTION(__hGetLine)
{
 ENTRY_LABEL(extern, __hGetLine)
    SAVE_REGS(1);
    EVAL_BOXED(__hGetLine_1);
}

static
FUNCTION(__hGetLine_1)
{
    char buf[256], *cp;
    Node *line, *tail;
    FILE *fp;
 ENTRY_LABEL(static, __hGetLine_1)
    MATCH_RIGID_FILE(__hGetLine_1);

    if ( !is_readable((Handle *)regs.r[0]) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hGetLine: handle not readable"),
		  regs.sp[0]);

    fp = ((Handle *)regs.r[0])->fp;
    assert(fp != NULL);
    if ( !fgets(buf, sizeof(buf), fp) )
	CALL_RET2(__ioError, 1,
		  from_string(0, feof(fp) ? "End of file" : strerror(errno)),
		  regs.sp[0]);

    regs.r[3] = regs.r[0];
    regs.r[0] = nil;
    regs.r[1] = regs.r[2] = 0;

    /* in this loop:
       r[0]: head of line
       r[1]: pointer to indirection tail node
       r[2]: pointer to last line segment
       r[3]: file handle
       NB the file handle in r[3] is not used in the loop below;
          nevertheless, it must be kept in a register so that the
	  file is not closed by the garbage collector while we are
	  reading from it.
     */
    do
    {
	for ( cp = buf; *cp != '\n' && *cp != '\0'; cp++ )
	    ;

	if ( *cp == '\n' )
	{
	    *cp  = '\0';
	    tail = nil;
	}
	else
	{
	    CHECK_HEAP(4, indir_node_size);
	    tail	 = (Node *)regs.hp;
	    tail->info	 = &indir_info;
#if !COPY_SEARCH_SPACE
	    tail->n.spc	 = regs.ss;
#endif
	    tail->n.node = nil;
	    regs.hp	+= indir_node_size;
	}

	regs.r[1] = tail;
	line	  = prefix_string(4, buf, tail);
	if ( regs.r[0] == nil )
	    regs.r[0] = line;
	else
	    regs.r[2]->n.node = line;
	regs.r[2] = regs.r[1];
    } while ( regs.r[2] != nil && fgets(buf, sizeof(buf), fp) );

    RETURN(regs.r[0], 1);
}

@ 
The function [[hGetContents]] returns the contents of the specified
file as a lazy stream. The handle is put into a semi-closed state by
setting the flags to [[0]]. The character stream is constructed on
demand with the help of the [[lazyRead]] function.

An alert reader might be surprised that [[hGetContents]] returns a
suspended application node. However, recall that this node should be
considered the first component of a pair composed of a result and the
state of the world. From these, only the result is really returned
because the representation of the world would be a simple constant
(cf. p.~\pageref{eq:monadic-io} in Sect.~\ref{sec:io-monad}).

<<files.c>>=
DECLARE_LABEL(extern, __hGetContents);
DECLARE_LABEL(static, __hGetContents_1);
DECLARE_LABEL(static, lazyRead);

DECLARE_LABEL(static, eval_lazy_1);

static NodeInfo lazyRead_lazy_info_table[] = LAZYINFO("lazyRead", lazyRead, 1);

static
FUNCTION(eval_lazy_1)
{
    Node  *susp, *x;
    Label entry;
 ENTRY_LABEL(static, eval_lazy_1)
    /* suspend the search if the node is not local */
    if ( !is_local_space(regs.r[0]->s.spc) )
	suspend_search(1, regs.r[0]->s.spc);

    /* get the argument */
    susp  = regs.r[0];
    entry = susp->info->entry;
    x	  = susp->s.args[0];

    /* create an indirection if there is an update frame immediately above */
    if ( regs.ret == update )
    {
#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, n.node);
	    susp->info += 2;
	}
	else
#endif
	    susp->info = &indir_info;
	assert(is_queueMe_node(regs.sp[0]));
	susp->n.node = regs.sp[0];
    }

    /* otherwise, lock the application node and create an update frame */
    else
    {
	SAVE_RET1(susp);
	regs.ret = update;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < regs.hlim )
	{
	    DO_SAVE(susp, q.wq);
	    susp->info++;
	}
	else
#endif
	    susp->info = queueMe_info_table;
	susp->q.wq = 0;
    }

    /* enter the callee */
    EXEC1(entry, x);
}

FUNCTION(__hGetContents)
{
 ENTRY_LABEL(extern, __hGetContents)
    SAVE_REGS(1);
    EVAL_BOXED(__hGetContents_1);
}

static
FUNCTION(__hGetContents_1)
{
    Node   *susp;
    Handle *file;
 ENTRY_LABEL(static, __hGetContents_1)
    MATCH_RIGID_FILE(__hGetContents_1);
    file = (Handle *)regs.r[0];

    if ( !is_readable(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hGetContents: handle not readable"),
		  regs.sp[0]);

    /* put the file into a semi-closed state */
    file->flags = 0;

    /* construct the (lazy) input stream */
    CHECK_HEAP(1, suspend_node_size(1));
    susp	    = (Node *)regs.hp;
    susp->info	    = lazyRead_lazy_info_table;
    susp->s.spc	    = regs.ss;
    susp->s.args[0] = regs.r[0];
    regs.hp	   += suspend_node_size(1);

    RETURN(susp, 1);
}

static
FUNCTION(lazyRead)
{
    int	   c;
    Node   *list, *tail;
    Handle *file;
 ENTRY_LABEL(static, lazyRead)
    TRACE_FUN("lazyRead", 1);

    file = (Handle *)regs.r[0];
    if ( file->fp == NULL )
	list = nil;
    else
    {
	c = fgetc(file->fp);
	if ( c == EOF )
	{
	    close_handle(file);
	    list = nil;
	}
	else
	{
	    CHECK_HEAP(1, suspend_node_size(1) + cons_node_size);

	    tail	    = (Node *)regs.hp;
	    tail->info	    = lazyRead_lazy_info_table;
	    tail->s.spc	    = regs.ss;
	    tail->s.args[0] = regs.r[0];
	    regs.hp	   += suspend_node_size(1);

	    list	    = (Node *)regs.hp;
	    list->info	    = &cons_info;
	    list->c.args[0] = (Node *)(char_table + (c & 0xff));
	    list->c.args[1] = tail;
	    regs.hp	   += cons_node_size;
	}
    }

    RET(list);
}

@
The function [[hPutChar]] writes a single character to the specified
handle.

<<files.c>>=
DECLARE_LABEL(extern, __hPutChar);
DECLARE_LABEL(static, __hPutChar_1);
DECLARE_LABEL(static, __hPutChar_2);

FUNCTION(__hPutChar)
{
 ENTRY_LABEL(extern, __hPutChar)
    SAVE_REGS(2);
    EVAL_BOXED(__hPutChar_1);
}

static
FUNCTION(__hPutChar_1)
{
 ENTRY_LABEL(static, __hPutChar_1)
    MATCH_RIGID_FILE(__hPutChar_1);
    SWAPn(0);
    EVAL_BOXED(__hPutChar_2);
}

static
FUNCTION(__hPutChar_2)
{
    Handle *file;
 ENTRY_LABEL(static, __hPutChar_2)
    MATCH_RIGID_CHAR(__hPutChar_2);
    file = (Handle *)regs.sp[0];

    if ( !is_writable(file) )
	CALL_RET2(__ioError, 2,
		  from_string(0, "hPutChar: handle not writable"),
		  regs.sp[1]);

    assert(file->fp != NULL);
    if ( putc(regs.r[0]->ch.ch, file->fp) == EOF )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);

    RETURN(unit, 2);
}

@ 
The function [[hPutStr]] writes a string to a file handle.

<<files.c>>=
DECLARE_LABEL(extern, __hPutStr);
DECLARE_LABEL(static, __hPutStr_1);
DECLARE_LABEL(static, __hPutStr_2);
DECLARE_LABEL(static, __hPutStr_3);

FUNCTION(__hPutStr)
{
 ENTRY_LABEL(extern, __hPutStr)
    SAVE_REGS(2);
    EVAL_BOXED(__hPutStr_1);
}

static
FUNCTION(__hPutStr_1)
{
 ENTRY_LABEL(static, __hPutStr_1)
    MATCH_RIGID_FILE(__hPutStr_1);
    if ( !is_writable((Handle *)regs.r[0]) )
	CALL_RET2(__ioError, 2,
		  from_string(0, "hPutStr: handle not writable"),
		  regs.sp[1]);

    SWAPn(0);
    EVAL_BOXED(__hPutStr_2);
}

static
FUNCTION(__hPutStr_2)
{
    Node *list;
 ENTRY_LABEL(static, __hPutStr_2)
    MATCH_RIGID_DATA(__hPutStr_2);
    list = regs.r[0];
    switch ( node_tag(list) )
    {
    case NIL_TAG:
	RETURN(unit, 2);
    case CONS_TAG:
	CHECK_STACK1();
	regs.sp   -= 1;
	regs.sp[0] = list->c.args[1];
	regs.r[0]  = list->c.args[0];
	EVAL_BOXED(__hPutStr_3);
    default:
	unexpected_tag("hPutStr", node_tag(list));
    }
}

static
FUNCTION(__hPutStr_3)
{
    Handle *file;
 ENTRY_LABEL(static, __hPutStr_3)
    MATCH_RIGID_CHAR(__hPutStr_3);

    file = (Handle *)regs.sp[1];
    if ( fputc(regs.r[0]->ch.ch, file->fp) == EOF )
	CALL_RET2(__ioError, 3, from_string(0, strerror(errno)), regs.sp[2]);

    regs.r[0] = *regs.sp++;
    EVAL_BOXED(__hPutStr_2);
}

@
The function [[hFileSize]] returns the size of a file in bytes,
provided that the file is seekable.

<<files.c>>=
DECLARE_LABEL(extern, __hFileSize);
DECLARE_LABEL(static, __hFileSize_1);

FUNCTION(__hFileSize)
{
 ENTRY_LABEL(extern, __hFileSize)
    SAVE_REGS(1);
    EVAL_BOXED(__hFileSize_1);
}

static
FUNCTION(__hFileSize_1)
{
    long   curpos, endpos;
    Node   *r;
    Handle *file;
 ENTRY_LABEL(static, __hFileSize_1)
    MATCH_RIGID_FILE(__hFileSize_1);
    file = (Handle *)regs.r[0];

    if ( !is_open(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hFileSize: handle not open"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    curpos = ftell(file->fp);
    if ( curpos == -1 || fseek(file->fp, 0, SEEK_END) == -1 )
	CALL_RET2(__ioError, 1, from_string(0, strerror(errno)), regs.sp[0]);

    endpos = ftell(file->fp);
    if ( endpos == -1 || fseek(file->fp, curpos, SEEK_SET) == -1 )
	CALL_RET2(__ioError, 1, from_string(0, strerror(errno)), regs.sp[0]);

#if !ONLY_BOXED_OBJECTS
    if ( !is_large_int(endpos) )
	r = mk_unboxed(endpos);
    else
#endif
    {
	CHECK_HEAP(0, int_node_size);
	r	 = (Node *)regs.hp;
	r->info	 = &int_info;
	r->i.i	 = endpos;
	regs.hp	+= int_node_size;
    }
    RETURN(r, 1);
}

@
The function [[hIsTerminalDevice]] returns [[True]] if the specified
handle is connected to a terminal and [[False]] otherwise. We use the
[[isatty]] function for testing this property.

<<files.c>>=
DECLARE_LABEL(extern, __hIsTerminalDevice);
DECLARE_LABEL(static, __hIsTerminalDevice_1);

FUNCTION(__hIsTerminalDevice)
{
 ENTRY_LABEL(extern, __hIsTerminalDevice)
    SAVE_REGS(1);
    EVAL_BOXED(__hIsTerminalDevice_1);
}

static
FUNCTION(__hIsTerminalDevice_1)
{
    Handle *file;
 ENTRY_LABEL(static, __hIsTerminalDevice_1)
    MATCH_RIGID_FILE(__hIsTerminalDevice_1);
    file = (Handle *)regs.r[0];

    if ( !is_open(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hIsTerminalDevice: handle not open"),
		  regs.sp[0]);
    assert(file->fp != NULL);

    RETURN(isatty(fileno(file->fp)) ? Prelude_True : Prelude_False, 1);
}

@
The function [[hGetBuffering]] returns the buffering mode used for the
given file handle. Unfortunately, there is no portable way to
determine the buffering mode used for a file handle. Therefore, the
mode is saved in the file structure when [[hSetBuffering]] is called
(see below). The initial buffering mode is determined by checking
whether the file is connected to a terminal or to a file. In the
former case we assume that line buffering is used, otherwise block
buffering is assumed.

The buffer mode is returned as an instance of the type
\texttt{BufferMode} declared in module \texttt{IO} as follows.
\begin{verbatim}
  data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
\end{verbatim}

<<files.c>>=
enum { Nothing_tag, Just_tag };
DECLARE_CONST(__Prelude__Nothing);
DECLARE_DATA(__Prelude__Just);

enum { NoBuffering_tag, LineBuffering_tag, BlockBuffering_tag };
DECLARE_CONST(__IO__NoBuffering);
DECLARE_CONST(__IO__LineBuffering);
DECLARE_DATA(__IO__BlockBuffering);

DECLARE_LABEL(extern, __hGetBuffering);
DECLARE_LABEL(static, __hGetBuffering_1);

FUNCTION(__hGetBuffering)
{
 ENTRY_LABEL(extern, __hGetBuffering)
    SAVE_REGS(1);
    EVAL_BOXED(__hGetBuffering_1);
}

static
FUNCTION(__hGetBuffering_1)
{
    short  bmode;
    long   bsize;
    Node   *size, *r;
    Handle *file;
 ENTRY_LABEL(static, __hGetBuffering_1)
    MATCH_RIGID_FILE(__hGetBuffering_1);
    file = (Handle *)regs.r[0];

    if ( !is_open(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hGetBuffering: handle not open"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    for (;;)
    {
	bmode = file->bmode;
	bsize = file->bsize;
	switch ( bmode )
	{
	case -1:
	    file->bmode = isatty(fileno(file->fp)) ? _IOLBF : _IOFBF;
	    continue;
	case _IONBF:
	    r = CONST(__IO__NoBuffering);
	    break;
	case _IOLBF:
	    r = CONST(__IO__LineBuffering);
	    break;
	case _IOFBF:
	    CHECK_HEAP(0, int_node_size + 2 * closure_node_size(1));
	    if ( bsize )
	    {
#if !ONLY_BOXED_OBJECTS
		if ( !is_large_int(bsize) )
		    r = mk_unboxed(bsize);
		else
#endif
		{
		    r	     = (Node *)regs.hp;
		    r->info  = &int_info;
		    r->i.i   = bsize;
		    regs.hp += int_node_size;
		}

		size		= (Node *)regs.hp;
		size->info	= INFO(__Prelude__Just);
		size->c.args[0] = r;
		regs.hp	       += closure_node_size(1);
	    }
	    else
		size = CONST(__Prelude__Nothing);

	    r		 = (Node *)regs.hp;
	    r->info	 = INFO(__IO__BlockBuffering);
	    r->c.args[0] = size;
	    regs.hp	+= closure_node_size(1);
	    break;
	default:
	    curry_panic("hGetBuffering: invalid buffer mode %d\n", bmode);
	}
	break;
    }

    RETURN(r, 1);
}

@
The function [[hSetBuffering]] changes the current buffering mode of a
file handle.

<<files.c>>=
DECLARE_LABEL(extern, __hSetBuffering);
DECLARE_LABEL(static, __hSetBuffering_1);
DECLARE_LABEL(static, __hSetBuffering_2);
DECLARE_LABEL(static, __hSetBuffering_3);
DECLARE_LABEL(static, __hSetBuffering_4);

FUNCTION(__hSetBuffering)
{
 ENTRY_LABEL(extern, __hSetBuffering)
    SAVE_REGS(2);
    EVAL_BOXED(__hSetBuffering_1);
}

static
FUNCTION(__hSetBuffering_1)
{
 ENTRY_LABEL(static, __hSetBuffering_1)
    MATCH_RIGID_FILE(__hSetBuffering_1);
    SWAPn(0);
    EVAL_BOXED(__hSetBuffering_2);
}

static
FUNCTION(__hSetBuffering_2)
{
    short  bmode;
    Handle *file;
 ENTRY_LABEL(static, __hSetBuffering_2)
    MATCH_RIGID_DATA(__hSetBuffering_2);
    switch ( node_tag(regs.r[0]) )
    {
    case NoBuffering_tag:
	bmode = _IONBF;
	break;
    case LineBuffering_tag:
	bmode = _IOLBF;
	break;
    case BlockBuffering_tag:
	regs.r[0] = regs.r[0]->c.args[0];
	EVAL_BOXED(__hSetBuffering_3);
    default:
	unexpected_tag("hSetBuffering", node_tag(regs.r[0]));
    }

    file = (Handle *)regs.sp[0];
    if ( !is_open(file) )
	CALL_RET2(__ioError, 2,
		  from_string(0, "hSetBuffering: handle not open"),
		  regs.sp[1]);

    assert(file->fp != NULL);
    if ( setvbuf(file->fp, NULL, bmode, 0) == -1 )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);
    file->bmode = bmode;
    file->bsize = 0;
    if ( file->buffer )
	free(file->buffer);
    file->buffer = NULL;

    RETURN(unit, 2);
}

static
FUNCTION(__hSetBuffering_3)
{
    Handle *file;
 ENTRY_LABEL(static, __hSetBuffering_3)
    MATCH_RIGID_DATA(__hSetBuffering_3);
    switch ( node_tag(regs.r[0]) )
    {
    case Nothing_tag:
	break;
    case Just_tag:
	regs.r[0] = regs.r[0]->c.args[0];
	EVAL(__hSetBuffering_4);
    default:
	unexpected_tag("hSetBuffering (mode)", node_tag(regs.r[0]));
    }

    file = (Handle *)regs.sp[0];
    if ( !is_open(file) )
	CALL_RET2(__ioError, 2,
		  from_string(0, "hSetBuffering: handle not open"),
		  regs.sp[1]);

    assert(file->fp != NULL);
    if ( setvbuf(file->fp, NULL, _IOFBF, 0) == -1 )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);
    file->bmode = _IOFBF;
    file->bsize = 0;
    if ( file->buffer )
	free(file->buffer);
    file->buffer = NULL;

    RETURN(unit, 2);
}

static
FUNCTION(__hSetBuffering_4)
{
    long   bsize;
    char   *buffer;
    Node   *exc;
    Handle *file;
 ENTRY_LABEL(static, __hSetBuffering_4)
    MATCH_RIGID_INT(__hSetBuffering_4);
    file = (Handle *)regs.sp[0];
    if ( !is_open(file) )
	CALL_RET2(__ioError, 2,
		  from_string(0, "hSetBuffering: handle not open"),
		  regs.sp[1]);

    bsize = long_val(regs.r[0]);
    if ( bsize > 0 )
    {
	buffer = (char *)malloc(bsize);
	if ( buffer == NULL )
	    sys_error("hSetBuffering");
    }
    else
	buffer = NULL;

    assert(file->fp != NULL);
    if ( setvbuf(file->fp, buffer, _IOFBF, bsize) == -1 )
    {
	exc = from_string(0, strerror(errno));
	free(buffer);
	CALL_RET2(__ioError, 2, exc, regs.sp[1]);
    }
    file->bmode = _IOFBF;
    file->bsize = bsize;
    if ( file->buffer )
	free(file->buffer);
    file->buffer = buffer;

    RETURN(unit, 2);
}

@
The function [[hFlush]] flushes the output buffer associated with
the specified handle.

<<files.c>>=
DECLARE_LABEL(extern, __hFlush);
DECLARE_LABEL(static, __hFlush_1);

FUNCTION(__hFlush)
{
 ENTRY_LABEL(extern, __hFlush)
    SAVE_REGS(1);
    EVAL_BOXED(__hFlush_1);
}

static
FUNCTION(__hFlush_1)
{
    Handle *file;
 ENTRY_LABEL(static, __hFlush_1)
    MATCH_RIGID_FILE(__hFlush_1);
    file = (Handle *)regs.r[0];

    if ( !is_writable(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hFlush: handle not writable"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    if ( fflush(file->fp) == -1 )
	CALL_RET2(__ioError, 1, from_string(0, strerror(errno)), regs.sp[0]);

    RETURN(unit, 1);
}

@
The function [[hTell]] returns the current I/O position of the file
associated with the specified handle.

<<files.c>>=
DECLARE_LABEL(extern, __hTell);
DECLARE_LABEL(static, __hTell_1);

FUNCTION(__hTell)
{
 ENTRY_LABEL(extern, __hTell)
    SAVE_REGS(1);
    EVAL_BOXED(__hTell_1);
}

static
FUNCTION(__hTell_1)
{
    long   curpos;
    Node   *r;
    Handle *file;
 ENTRY_LABEL(static, __hTell_1)
    MATCH_RIGID_FILE(__hTell_1);
    file = (Handle *)regs.r[0];

    if ( !is_open(file) )
	CALL_RET2(__ioError, 1,
		  from_string(0, "hTell: handle not open"),
		  regs.sp[0]);

    assert(file->fp != NULL);
    curpos = ftell(file->fp);
    if ( curpos == -1 )
	CALL_RET2(__ioError, 1, from_string(0, strerror(errno)), regs.sp[0]);

#if !ONLY_BOXED_OBJECTS
    if ( !is_large_int(curpos) )
	r = mk_unboxed(curpos);
    else
#endif
    {
	CHECK_HEAP(0, int_node_size);
	r	 = (Node *)regs.hp;
	r->info	 = &int_info;
	r->i.i	 = curpos;
	regs.hp += int_node_size;
    }
    RETURN(r, 1);
}

@
The function [[hSeek]] sets the I/O position of the specified handle
to a new position. The second argument determines how the offset
(the third argument) is interpreted. It must be a constant from the
type \texttt{SeekMode} defined in the module \texttt{IO} as follows.
\begin{verbatim}
  data SeekMode = AbsoluteSeek | RelativeSeek | SeekFromEnd
\end{verbatim}

<<files.c>>=
enum { AbsoluteSeek_tag, RelativeSeek_tag, SeekFromEnd_tag };
DECLARE_CONST(__IO__AbsoluteSeek);
DECLARE_CONST(__IO__RelativeSeek);
DECLARE_CONST(__IO__SeekFromEnd);

DECLARE_LABEL(extern, __hSeek);
DECLARE_LABEL(static, __hSeek_1);
DECLARE_LABEL(static, __hSeek_2);
DECLARE_LABEL(static, __hSeek_3);

FUNCTION(__hSeek)
{
 ENTRY_LABEL(extern, __hSeek)
    SAVE_REGS(3);
    EVAL_BOXED(__hSeek_1);
}

static
FUNCTION(__hSeek_1)
{
 ENTRY_LABEL(static, __hSeek_1)
    MATCH_RIGID_FILE(__hSeek_1);
    SWAPn(0);
    EVAL_BOXED(__hSeek_2);
}

static
FUNCTION(__hSeek_2)
{
 ENTRY_LABEL(static, __hSeek_2)
    MATCH_RIGID_DATA(__hSeek_2);
    SWAPn(1);
    EVAL(__hSeek_3);
}

static
FUNCTION(__hSeek_3)
{
    int	   smode;
    Handle *file;
 ENTRY_LABEL(static, __hSeek_3)
    MATCH_RIGID_INT(__hSeek_3);

    file = (Handle *)regs.sp[0];
    if ( !is_open(file) )
	CALL_RET2(__ioError, 3,
		  from_string(0, "hSeek: handle not open"),
		  regs.sp[2]);

    switch ( node_tag(regs.sp[1]) )
    {
    case AbsoluteSeek_tag:
	smode = SEEK_SET;
	break;
    case RelativeSeek_tag:
	smode = SEEK_CUR;
	break;
    case SeekFromEnd_tag:
	smode = SEEK_END;
	break;
    default:
	unexpected_tag("hSeek (mode)", node_tag(regs.sp[1]));
    }

    assert(file->fp != NULL);
    if ( fseek(file->fp, long_val(regs.r[0]), smode) == -1 )
	CALL_RET2(__ioError, 3, from_string(0, strerror(errno)), regs.sp[2]);

    RETURN(unit, 3);
}

@ 
The function [[openProcess]] executes a shell command and returns a
file descriptor connected to the standard input and output of the
subprocess. We cannot use [[popen]] here, as using it with the [[r+]]
mode is a non-portable extension.

<<files.c>>=
DECLARE_LABEL(extern, __openProcess);
DECLARE_LABEL(static, __openProcess_1);
DECLARE_LABEL(static, __openProcess_2);

FUNCTION(__openProcess)
{
 ENTRY_LABEL(extern, __openProcess)
    SAVE_REGS(2);
    EVAL_BOXED(__openProcess_1);
}

static
FUNCTION(__openProcess_1)
{
 ENTRY_LABEL(static, __openProcess_1)
    SWAPn(0);
    EVAL_BOXED(__openProcess_2);
}

static
FUNCTION(__openProcess_2)
{
    int		  r, fds[2], flags;
    pid_t	  pid;
    const char	  *cmd, *mode;
    Node	  *exc;
    FILE	  *fp;
    ProcessHandle *proc;
 ENTRY_LABEL(static, __openProcess_2)
    /* determine the access mode */
    MATCH_RIGID_DATA(__openProcess_2);
    cmd = to_string(regs.sp[0]);
    switch ( node_tag(regs.r[0]) )
    {
    case ReadMode_tag:
	mode  = "r";
	flags = mask(readable);
	break;
    case WriteMode_tag:
    case AppendMode_tag:
	mode  = "w";
	flags = mask(writable);
	break;
    case ReadWriteMode_tag:
	mode  = "r+";
	flags = mask(readable) | mask(writable);
	break;
    default:
	unexpected_tag("openProcess (mode)", node_tag(regs.r[0]));
    }

    /* depending on the mode create either a pipe or a socket pair */
    if ( flags == (mask(readable) | mask(writable)) )
	r = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
    else
	r = pipe(fds);
    if ( r == -1 )
	CALL_RET2(__ioError, 2, from_string(0, strerror(errno)), regs.sp[1]);

    /* start a new process for the command */
    pid = vfork();
    switch ( pid )
    {
    case 0:
	/* set up appropriate connections in the child process */
	/* NB when a pipe is used (i.e., read-only or write-only
	 *    connection), the appropriate end of the pipe is used;
	 *    otherwise (i.e., read-write connection), we arbitrarily
	 *    choose the second descriptor of the socket pair. */
	if ( flags == mask(readable) )
	    dup2(fds[1], 1);
	else if ( flags == mask(writable) )
	    dup2(fds[0], 0);
	else
	{
	    dup2(fds[1], 0);
	    dup2(fds[1], 1);
	}

	/* close the pipe/socketpair handles */
	close(fds[0]);
	close(fds[1]);

	/* start the child process */
	execl("/bin/sh", "sh", "-c", cmd, (char *)0);
	_exit(1);
    case -1:
	exc = from_string(0, strerror(errno));
	close(fds[0]);
	close(fds[1]);
	CALL_RET2(__ioError, 2, exc, regs.sp[1]);
    default:
	free((char *)cmd);
	break;
    }

    /* close the unused descriptor */
    if ( flags == mask(writable) )
    {
	close(fds[0]);
	fds[0] = fds[1];
    }
    else
	close(fds[1]);

    /* create a file for the pipe/socketpair */
    fp	= fdopen(fds[0], mode);
    if ( fp == NULL )
    {
	exc = from_string(0, strerror(errno));
	close(fds[0]);
	CALL_RET2(__ioError, 2, exc, regs.sp[1]);
    }

    /* create the process node */
    CHECK_HEAP(0, process_node_size);
    proc	 = (ProcessHandle *)regs.hp;
    proc->info	 = &process_info;
    proc->fp	 = fp;
    proc->flags  = flags;
    proc->bmode  = _IOFBF;
    proc->bsize	 = 0;
    proc->buffer = NULL;
    proc->pid	 = pid;
    proc->status = 0;
    regs.hp	+= process_node_size;
    register_final((Node *)proc);

    /* return the process node */
    RETURN((Node *)proc, 2);
}

@ 
The function [[pClose]] closes the connection to a process and returns
its termination status. This function raises an IO error when it is
applied to a handle that is not connected to a process. However, it is
safe to call [[pClose]] more than once for a handle that was created
by [[openProcess]].

<<files.c>>=
DECLARE_LABEL(extern, __pClose);
DECLARE_LABEL(static, __pClose_1);

FUNCTION(__pClose)
{
 ENTRY_LABEL(extern, __pClose)
    SAVE_REGS(1);
    EVAL_BOXED(__pClose_1);
}

static
FUNCTION(__pClose_1)
{
    int		  res;
    ProcessHandle *proc;
    Node	  *r;
 ENTRY_LABEL(static, __pClose_1)
    MATCH_RIGID_FILE(__pClose_1);
    proc = (ProcessHandle *)regs.r[0];
    if ( proc->info != &process_info )
	CALL_RET2(__ioError, 1,
		  from_string(0,
			      "pClose applied to a handle that "
			      "is not connected to a process"),
		  regs.sp[0]);

    if ( proc->fp )
    {
	fclose(proc->fp);
	proc->fp    = NULL;
	proc->flags = 0;
	if ( proc->buffer )
	    free(proc->buffer);
	waitpid(proc->pid, &proc->status, 0);
	proc->pid = 0;
    }
    else if ( proc->pid )
    {
	waitpid(proc->pid, &proc->status, 0);
	proc->pid = 0;
    }

    if ( WIFSIGNALED(proc->status) )
	res = -WTERMSIG(proc->status);
    else
    {
	ASSERT(WIFEXITED(proc->status));
	res = WEXITSTATUS(proc->status);
    }

#if !ONLY_BOXED_OBJECTS
    if ( !is_large_int(res) )
	r = mk_unboxed((long)res);
    else
#endif
    {
	CHECK_HEAP(0, int_node_size);
	r	 = (Node *)regs.hp;
	r->info	 = &int_info;
	r->i.i	 = res;
	regs.hp += int_node_size;
    }
    RETURN(r, 1);
}

@ 
The function [[connectTcpSocket]] creates a socket that is connected
to a specified port at a given host.

<<files.c>>=
DECLARE_LABEL(extern, __connectTcpSocket);
DECLARE_LABEL(static, __connectTcpSocket_1);
DECLARE_LABEL(static, __connectTcpSocket_2);
DECLARE_LABEL(static, __connectTcpSocket_3);

FUNCTION(__connectTcpSocket)
{
 ENTRY_LABEL(extern, __connectTcpSocket)
    SAVE_REGS(3);
    EVAL_BOXED(__connectTcpSocket_1);
}

static
FUNCTION(__connectTcpSocket_1)
{
 ENTRY_LABEL(static, __connectTcpSocket_1)
    SWAPn(0);
    EVAL(__connectTcpSocket_2);
}

static
FUNCTION(__connectTcpSocket_2)
{
 ENTRY_LABEL(static, __connectTcpSocket_2)
    MATCH_RIGID_INT(__connectTcpSocket_2)
    SWAPn(1);
    EVAL_BOXED(__connectTcpSocket_3);
}

static
FUNCTION(__connectTcpSocket_3)
{
    int		       fd, port, flags;
    const char	       *host, *mode;
    Node	       *exc;
    FILE	       *fp;
    Handle	       *sock;
    struct hostent     *hostent;
    struct sockaddr_in addr;
 ENTRY_LABEL(static, __connectTcpSocket_3)
    MATCH_RIGID_DATA(__connectTcpSocket_3)
    host = to_string(regs.sp[0]);
    port = long_val(regs.sp[1]);
    switch ( node_tag(regs.r[0]) )
    {
    case ReadMode_tag:
	mode  = "r";
	flags = mask(readable);
	break;
    case WriteMode_tag:
    case AppendMode_tag:
	mode  = "w";
	flags = mask(writable);
	break;
    case ReadWriteMode_tag:
	mode  = "r+";
	flags = mask(readable) | mask(writable);
	break;
    default:
	unexpected_tag("connectTcpSocket (mode)", node_tag(regs.r[0]));
    }

    /* setup the socket address structure */
    hostent	    = gethostbyname(host);
    addr.sin_family = AF_INET;
    addr.sin_port   = htons(port);
    if ( hostent )
	addr.sin_addr.s_addr = *(unsigned long *)hostent->h_addr_list[0];
    else if ( (addr.sin_addr.s_addr = inet_addr(host)) == (in_addr_t)~0 )
    {
	exc = from_string(0, "unknown host");
	free((char *)host);
	CALL_RET2(__ioError, 3, exc, regs.sp[2]);
    }
    free((char *)host);

    /* create a new socket */
    fd = socket(AF_INET, SOCK_STREAM, 0);
    if ( fd < 0 )
	CALL_RET2(__ioError, 3, from_string(0, strerror(errno)), regs.sp[2]);

    /* connect the socket to specified port */
    if ( connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0 )
    {
	exc = from_string(0, strerror(errno));
	close(fd);
	CALL_RET2(__ioError, 3, exc, regs.sp[2]);
    }

    /* create a file for the scoket */
    fp = fdopen(fd, mode);
    if ( fp == NULL )
    {
	exc = from_string(0, strerror(errno));
	close(fd);
	CALL_RET2(__ioError, 3, exc, regs.sp[2]);
    }

    /* create the file node */
    CHECK_HEAP(0, file_node_size);
    sock	 = (Handle *)regs.hp;
    sock->info	 = &file_info;
    sock->fp	 = fp;
    sock->flags  = flags;
    sock->bmode  = _IOFBF;
    sock->bsize	 = 0;
    sock->buffer = NULL;
    regs.hp	+= file_node_size;
    register_final((Node *)sock);

    /* return the socket */
    RETURN((Node *)sock, 3);
}

@
The function [[init_files]] initializes the standard channels and
optionally changes the buffer mode for standard input and output.

<<files.c>>=
void
init_files(int bmode, long bsize)
{
    char *buffer;

    /* set up the standard file pointers */
    stdin_node.fp = stdin;
    stdout_node.fp = stdout;
    stderr_node.fp = stderr;

    /* eventually change buffer modes for standard input and output */
    if ( bmode != -1 )
    {
	/* don't allocate buffers if the file is not fully buffered */
	if ( bmode != _IOFBF )
	    bsize = 0;

	/* change the buffer mode for the standard input channel */
	if ( bsize )
	{
	    buffer = (char *)malloc(bsize);
	    if ( buffer == NULL )
		sys_error("init_files (input buffer)");
	}
	else
	    buffer = NULL;
	if ( setvbuf(stdin, buffer, bmode, bsize) == -1 )
	    sys_error("setvbuf (stdin)");
	stdin_node.bmode  = bmode;
	stdin_node.bsize  = bsize;
	stdin_node.buffer = buffer;

	/* change the buffer mode for the standard input channel */
	if ( bsize )
	{
	    buffer = (char *)malloc(bsize);
	    if ( buffer == NULL )
		sys_error("init_files (output buffer)");
	}
	else
	    buffer = NULL;
	if ( setvbuf(stdout, buffer, bmode, bsize) == -1 )
	    sys_error("setvbuf (stdout)");
	stdout_node.bmode  = bmode;
	stdout_node.bsize  = bsize;
	stdout_node.buffer = buffer;
    }
}
