% -*- noweb-code-mode: c-mode -*-
% $Id: integer.nw 2624 2008-02-16 17:53:31Z wlux $
%
% Copyright (c) 2007-2008, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Multi-Precision Integer Primitives}
This file contains the implementation of the arithmetic operations of
the multi-precision \texttt{Integer} type. Our implementation is based
on the Gnu MP library\footnote{\url{http://www.swox.com/gmp/}}. All
functions employ the \texttt{rawcall} calling convention.

Note that ``small'' numbers are represented as tagged integers. The
functions below always return tagged integers when possible but they
do not rely on ``small'' arguments being represented as tagged
integers.

<<integer.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <math.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "prims.h"
#include "heap.h"
#include "eval.h"
#include "integer.h"

DECLARE_CONST(__Prelude__LT);
DECLARE_CONST(__Prelude__EQ);
DECLARE_CONST(__Prelude__GT);

#define pair_node_size	closure_node_size(2)
#define pair_info	___40__44__41__info
static DEFINE_DATA(___40__44__41_, "(,)", 0, 2);

@ 
The first three primitives implement conversions between standard and
multi-precision integer numbers and from multi-precision integer
numbers to floating-point numbers.

<<integer.h>>=
extern Node *primToInteger(Node *);
extern Node *primFromInteger(Node *);
extern Node *primIntegerToFloat(Node *);

@ 
<<integer.c>>=
Node *
primToInteger(Node *x)
{
    Node *z;

#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	z = x;
    else
#endif
    {
	long l = x->i.i;

	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set_si(z->bi.mpz, l);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    return z;
}

Node *
primFromInteger(Node *x)
{
    Node *i;

#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	i = x;
    else
#endif
    {
	long l = mpz_get_si(x->bi.mpz);

#if !NO_POINTER_TAGS
	if ( !is_large_int(l) )
	    i = tag_int(l);
	else
#endif
	{
	    CHECK_HEAP(0, int_node_size);
	    i	     = (Node *)regs.hp;
	    i->info  = &int_info;
	    i->i.i   = l;
	    regs.hp += int_node_size;
	}
    }

    return i;
}

Node *
primIntegerToFloat(Node *x)
{
    double d;
    Node   *f;

#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	d = (double)untag_int(x);
    else
#endif
	d = mpz_get_d(x->bi.mpz);

    CHECK_HEAP(0, float_node_size);
    f	     = (Node *)regs.hp;
    f->info  = &float_info;
    put_double_val(f, d);
    regs.hp += float_node_size;

    return f;
}

@ 
The primitive for the \texttt{properFraction} method of the
\texttt{RealFrac} class returns the (truncated) integer part of its
floating-point argument and the fractional part as a pair.

<<integer.h>>=
extern Node *primProperFraction(Node *);

@
<<integer.c>>=
Node *
primProperFraction(Node *x)
{
    double d, frac;
    Node   *p, *i, *f;

    get_double_val(d, x);
    frac = modf(d, &d);

#if !NO_POINTER_TAGS
    if ( !is_large_int(d) )
    {
	CHECK_HEAP(0, pair_node_size + float_node_size);
	i = tag_int((long)d);
    }
    else
#endif
    {
	CHECK_HEAP(0, pair_node_size + bigint_node_size + float_node_size);
	i	 = (Node *)regs.hp;
	i->info  = &bigint_info;
	mpz_init_set_d(i->bi.mpz, d);
	regs.hp += bigint_node_size;
	register_final(i);
    }

    f	     = (Node *)regs.hp;
    f->info  = &float_info;
    put_double_val(f, frac);
    regs.hp += float_node_size;

    p	     = (Node *)regs.hp;
    p->info  = &pair_info;
    p->c.args[0] = i;
    p->c.args[1] = f;
    regs.hp += pair_node_size;

    return p;
}

@ 
We provide only a single primitive for comparing integer numbers, the
generic \texttt{compare} function. All other operations, including
tests for (in)equality are derived from this primitive by matching the
result of \texttt{compare}.

<<integer.h>>=
extern Node *primCompareInteger(Node *, Node *);

@ 
<<integer.c>>=
Node *
primCompareInteger(Node *x, Node *y)
{
    int cmp;

#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    cmp = x > y ? 1 : x < y ? -1 : 0;
	else
	    cmp = -mpz_cmp_si(y->bi.mpz, untag_int(x));
    }
    else if ( is_tagged_int(y) )
	cmp = mpz_cmp_si(x->bi.mpz, untag_int(y));
    else
#endif
	cmp = mpz_cmp(x->bi.mpz, y->bi.mpz);

    return cmp > 0 ? CONST(__Prelude__GT) :
	   cmp < 0 ? CONST(__Prelude__LT) :
	   CONST(__Prelude__EQ);
}

@ 
The \texttt{succ}essor and \texttt{pred}ecessor methods of the
\texttt{Enum} class can be implemented trivially as [[pred n = n - 1]]
and [[succ n = n + 1]]. Nevertheless, we provide primitives for both
methods here since they can be implemented more efficiently.

<<integer.h>>=
extern Node *primSuccInteger(Node *);
extern Node *primPredInteger(Node *);

@ 
<<integer.c>>=
Node *
primSuccInteger(Node *x)
{
    Node *z;
    mpz_t succ;

    mpz_init(succ);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	mpz_set_si(succ, untag_int(x) + 1);
    else
#endif
	mpz_add_ui(succ, x->bi.mpz, 1);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(succ) )
	z = tag_int(mpz_get_si(succ));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, succ);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(succ);
    return z;
}

Node *
primPredInteger(Node *x)
{
    Node *z;
    mpz_t pred;

    mpz_init(pred);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	mpz_set_si(pred, untag_int(x) - 1);
    else
#endif
	mpz_sub_ui(pred, x->bi.mpz, 1);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(pred) )
	z = tag_int(mpz_get_si(pred));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, pred);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(pred);
    return z;
}

@ 
The following functions implement addition, subtraction, and
multiplication for multi-precision integer numbers.

<<integer.h>>=
extern Node *primAddInteger(Node *, Node *);
extern Node *primSubInteger(Node *, Node *);
extern Node *primMulInteger(Node *, Node *);

@ 
<<integer.c>>=
Node *
primAddInteger(Node *x, Node *y)
{
    Node *z;
    mpz_t sum;

    mpz_init(sum);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(sum, untag_int(x) + untag_int(y));
	else
	{
	    mpz_set_si(sum, untag_int(x));
	    mpz_add(sum, sum, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(sum, untag_int(y));
	mpz_add(sum, x->bi.mpz, sum);
    }
    else
#endif
	mpz_add(sum, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(sum) )
	z = tag_int(mpz_get_si(sum));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, sum);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(sum);
    return z;
}

Node *
primSubInteger(Node *x, Node *y)
{
    Node *z;
    mpz_t diff;

    mpz_init(diff);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(diff, untag_int(x) - untag_int(y));
	else
	{
	    mpz_set_si(diff, untag_int(x));
	    mpz_sub(diff, diff, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(diff, untag_int(y));
	mpz_sub(diff, x->bi.mpz, diff);
    }
    else
#endif
	mpz_sub(diff, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(diff) )
	z = tag_int(mpz_get_si(diff));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, diff);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(diff);
    return z;
}

Node *
primMulInteger(Node *x, Node *y)
{
    Node *z;
    mpz_t prod;

    mpz_init(prod);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	{
	    mpz_set_si(prod, untag_int(x));
	    mpz_mul_si(prod, prod, untag_int(y));
	}
	else
	    mpz_mul_si(prod, y->bi.mpz, untag_int(x));
    }
    else if ( is_tagged_int(y) )
	mpz_mul_si(prod, x->bi.mpz, untag_int(y));
    else
#endif
	mpz_mul(prod, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(prod) )
	z = tag_int(mpz_get_si(prod));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, prod);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(prod);
    return z;
}

@ 
We also provide primitives for the remaining methods of the
\texttt{Num} class. Once again, these methods have trivial
implementations in Curry, but we can provide more efficient
primitives for them.

<<integer.h>>=
extern Node *primNegateInteger(Node *);
extern Node *primAbsInteger(Node *);
extern Node *primSignumInteger(Node *);

@ 
<<integer.c>>=
Node *
primNegateInteger(Node *x)
{
    Node *z;
    mpz_t neg;

    mpz_init(neg);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	mpz_set_si(neg, -untag_int(x));
    else
#endif
	mpz_neg(neg, x->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(neg) )
	z = tag_int(mpz_get_si(neg));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, neg);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(neg);
    return z;
}

Node *
primAbsInteger(Node *x)
{
    Node *z;
    mpz_t abs;

    mpz_init(abs);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
	mpz_set_si(abs, labs(untag_int(x)));
    else
#endif
	mpz_abs(abs, x->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(abs) )
	z = tag_int(mpz_get_si(abs));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	z	 = (Node *)regs.hp;
	z->info  = &bigint_info;
	mpz_init_set(z->bi.mpz, abs);
	regs.hp += bigint_node_size;
	register_final(z);
    }

    mpz_clear(abs);
    return z;
}

Node *
primSignumInteger(Node *x)
{
    int  sgn;
    Node *z;

#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	long l = untag_int(x);

	sgn = l > 0 ? 1 : l < 0 ? -1 : 0;
    }
    else
#endif
	sgn = mpz_sgn(x->bi.mpz);

#if !NO_POINTER_TAGS
    z = tag_int((long)sgn);
#else
    CHECK_HEAP(0, bigint_node_size);
    z	     = (Node *)regs.hp;
    z->info  = &bigint_info;
    mpz_init_set_si(z->bi.mpz, sgn);
    regs.hp += bigint_node_size;
    register_final(z);
#endif

    return z;
}

@ 
With respect to integer division and modulus, the methods of the
\texttt{Integral} class, we provide both variants of the operations,
those rounding the quotient towards negative infinity (\texttt{div}
and \texttt{mod}) and those rounding towards zero (\texttt{quot} and
\texttt{rem}). Fortunately all these operations, including returning
the quotient together with the remainder, are provided by the Gnu MP
library.

Here are the primitives rounding towards negative infinity.

<<integer.h>>=
extern Node *primDivInteger(Node *, Node *);
extern Node *primModInteger(Node *, Node *);
extern Node *primDivModInteger(Node *, Node *);

@ 
<<integer.c>>=
Node *
primDivInteger(Node *x, Node *y)
{
    Node *q;
    mpz_t quot;

    mpz_init(quot);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(quot, primDivInt(untag_int(x), untag_int(y)));
	else
	{
	    mpz_set_si(quot, untag_int(x));
	    mpz_fdiv_q(quot, quot, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(quot, untag_int(y));
	mpz_fdiv_q(quot, x->bi.mpz, quot);
    }
    else
#endif
	mpz_fdiv_q(quot, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(quot) )
	q = tag_int(mpz_get_si(quot));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	q	 = (Node *)regs.hp;
	q->info  = &bigint_info;
	mpz_init_set(q->bi.mpz, quot);
	regs.hp += bigint_node_size;
	register_final(q);
    }

    mpz_clear(quot);
    return q;
}

Node *
primModInteger(Node *x, Node *y)
{
    Node *r;
    mpz_t rem;

    mpz_init(rem);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(rem, primModInt(untag_int(x), untag_int(y)));
	else
	{
	    mpz_set_si(rem, untag_int(x));
	    mpz_fdiv_r(rem, rem, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(rem, untag_int(y));
	mpz_fdiv_r(rem, x->bi.mpz, rem);
    }
    else
#endif
	mpz_fdiv_r(rem, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(rem) )
	r = tag_int(mpz_get_si(rem));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	r	 = (Node *)regs.hp;
	r->info  = &bigint_info;
	mpz_init_set(r->bi.mpz, rem);
	regs.hp += bigint_node_size;
	register_final(r);
    }

    mpz_clear(rem);
    return r;
}

Node *
primDivModInteger(Node *x, Node *y)
{
    Node *p, *q, *r;
    mpz_t quot, rem;

    mpz_init(quot);
    mpz_init(rem);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	{
	    mpz_set_si(quot, primDivInt(untag_int(x), untag_int(y)));
	    mpz_set_si(rem, primModInt(untag_int(x), untag_int(y)));
	}
	else
	{
	    mpz_set_si(quot, untag_int(x));
	    mpz_fdiv_qr(quot, rem, quot, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(rem, untag_int(y));
	mpz_fdiv_qr(quot, rem, x->bi.mpz, rem);
    }
    else
#endif
	mpz_fdiv_qr(quot, rem, x->bi.mpz, y->bi.mpz);

    CHECK_HEAP(0, pair_node_size + 2 * bigint_node_size);
#if !NO_POINTER_TAGS
    if ( !is_large_mpz(quot) )
	q = tag_int(mpz_get_si(quot));
    else
#endif
    {
	q	 = (Node *)regs.hp;
	q->info  = &bigint_info;
	mpz_init_set(q->bi.mpz, quot);
	regs.hp += bigint_node_size;
	register_final(q);
    }

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(rem) )
	r = tag_int(mpz_get_si(rem));
    else
#endif
    {
	r	 = (Node *)regs.hp;
	r->info  = &bigint_info;
	mpz_init_set(r->bi.mpz, rem);
	regs.hp += bigint_node_size;
	register_final(r);
    }

    p		 = (Node *)regs.hp;
    p->info	 = &pair_info;
    p->c.args[0] = q;
    p->c.args[1] = r;
    regs.hp	+= pair_node_size;

    mpz_clear(rem);
    mpz_clear(quot);
    return p;
}

@ 
And now the ones rounding towards zero.

<<integer.h>>=
extern Node *primQuotInteger(Node *, Node *);
extern Node *primRemInteger(Node *, Node *);
extern Node *primQuotRemInteger(Node *, Node *);

@ 
<<integer.c>>=
Node *
primQuotInteger(Node *x, Node *y)
{
    Node *q;
    mpz_t quot;

    mpz_init(quot);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(quot, primQuotInt(untag_int(x), untag_int(y)));
	else
	{
	    mpz_set_si(quot, untag_int(x));
	    mpz_tdiv_q(quot, quot, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(quot, untag_int(y));
	mpz_tdiv_q(quot, x->bi.mpz, quot);
    }
    else
#endif
	mpz_tdiv_q(quot, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(quot) )
	q = tag_int(mpz_get_si(quot));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	q	 = (Node *)regs.hp;
	q->info  = &bigint_info;
	mpz_init_set(q->bi.mpz, quot);
	regs.hp += bigint_node_size;
	register_final(q);
    }

    mpz_clear(quot);
    return q;
}

Node *
primRemInteger(Node *x, Node *y)
{
    Node *r;
    mpz_t rem;

    mpz_init(rem);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	    mpz_set_si(rem, primRemInt(untag_int(x), untag_int(y)));
	else
	{
	    mpz_set_si(rem, untag_int(x));
	    mpz_tdiv_r(rem, rem, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(rem, untag_int(y));
	mpz_tdiv_r(rem, x->bi.mpz, rem);
    }
    else
#endif
	mpz_tdiv_r(rem, x->bi.mpz, y->bi.mpz);

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(rem) )
	r = tag_int(mpz_get_si(rem));
    else
#endif
    {
	CHECK_HEAP(0, bigint_node_size);
	r	 = (Node *)regs.hp;
	r->info  = &bigint_info;
	mpz_init_set(r->bi.mpz, rem);
	regs.hp += bigint_node_size;
	register_final(r);
    }

    mpz_clear(rem);
    return r;
}

Node *
primQuotRemInteger(Node *x, Node *y)
{
    Node *p, *q, *r;
    mpz_t quot, rem;

    mpz_init(quot);
    mpz_init(rem);
#if !NO_POINTER_TAGS
    if ( is_tagged_int(x) )
    {
	if ( is_tagged_int(y) )
	{
	    mpz_set_si(quot, primQuotInt(untag_int(x), untag_int(y)));
	    mpz_set_si(rem, primRemInt(untag_int(x), untag_int(y)));
	}
	else
	{
	    mpz_set_si(quot, untag_int(x));
	    mpz_tdiv_qr(quot, rem, quot, y->bi.mpz);
	}
    }
    else if ( is_tagged_int(y) )
    {
	mpz_set_si(rem, untag_int(y));
	mpz_tdiv_qr(quot, rem, x->bi.mpz, rem);
    }
    else
#endif
	mpz_tdiv_qr(quot, rem, x->bi.mpz, y->bi.mpz);

    CHECK_HEAP(0, pair_node_size + 2 * bigint_node_size);
#if !NO_POINTER_TAGS
    if ( !is_large_mpz(quot) )
	q = tag_int(mpz_get_si(quot));
    else
#endif
    {
	q	 = (Node *)regs.hp;
	q->info  = &bigint_info;
	mpz_init_set(q->bi.mpz, quot);
	regs.hp += bigint_node_size;
	register_final(q);
    }

#if !NO_POINTER_TAGS
    if ( !is_large_mpz(rem) )
	r = tag_int(mpz_get_si(rem));
    else
#endif
    {
	r	 = (Node *)regs.hp;
	r->info  = &bigint_info;
	mpz_init_set(r->bi.mpz, rem);
	regs.hp += bigint_node_size;
	register_final(r);
    }

    p		 = (Node *)regs.hp;
    p->info	 = &pair_info;
    p->c.args[0] = q;
    p->c.args[1] = r;
    regs.hp	+= pair_node_size;

    mpz_clear(rem);
    mpz_clear(quot);
    return p;
}
