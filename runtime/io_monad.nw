% -*- noweb-code-mode: c-mode -*-
% $Id: io_monad.nw 2271 2007-06-16 16:30:52Z wlux $
%
% Copyright (c) 2001-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Monadic Code}\label{sec:io-monad}
The monadic driver is implemented in the file [[io_monad.c]]. The main
entry point into this module is the function [[curry_exec]], which
executes a monadic goal.

The function [[curry_exit]] stops the execution of the program with
the given return code, which will be returned from [[curry_exec]].

The function [[fail_with]] prints an error message and stops the
execution with return code 1. It is effectively equivalent to calling
\texttt{Prelude.error} with the formatted error message.

The functions [[curry_argc]] and [[curry_argv]] return the arguments
that were passed to [[curry_exec]].

<<io_monad.h>>=
extern int  curry_exec(NodeInfo *main_info_table, int argc, char **argv);
extern void curry_exit(int rc) __attribute__((noreturn));

extern void fail_with(const char *format, ...)
    __attribute__((noreturn, format(printf, 1, 2)));

extern int  curry_argc(void);
extern char **curry_argv(void);

DECLARE_LABEL(extern, __ioError);

@ 
<<io_monad.c>>=
#include "config.h"
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "spaces.h"
#include "eval.h"
#include "data.h"
#include "io_monad.h"
#include "cstring.h"
#include "trace.h"
#include "cam.h"

DECLARE_LABEL(static, start_io);
DECLARE_LABEL(static, stop_io);
DECLARE_LABEL(static, choices_io);
DECLARE_LABEL(static, deadlock_io);
DECLARE_LABEL(static, fail_io);

@ 
In this file we also provide the handler functions for
non-deterministic instructions, suspensions, and failures.
Non-deterministic code will raise an error in monadic code, deadlocks
and failures will terminate the program with an appropriate (error)
message.

@ 
<<io_monad.c>>=
static const struct nondet_handlers io_handlers = {
    choices_io, deadlock_io, fail_io
};

static
FUNCTION(choices_io)
{
 ENTRY_LABEL(static, choices_io)
    fail_with("cannot duplicate the world");
}

static
FUNCTION(deadlock_io)
{
 ENTRY_LABEL(static, deadlock_io)
    fail_with("deadlock");
}

static
FUNCTION(fail_io)
{
 ENTRY_LABEL(static, fail_io)
    fail_with("failed");
}

@
The global entry point [[start_io]] prepares the abstract machine for
evaluating the monadic goal on the top of the stack. The IO monad is
based on the type \texttt{IO}, which can be defined as
\begin{equation}
  \mbox{\texttt{type IO a = World -> (a,World)}}\label{eq:monadic-io}
\end{equation}
where the type \texttt{World} represents the state of the external
world. The state of the file system, etc. are managed implicitly in
the runtime system. Therefore, we can simply use the constant
\texttt{()} as representation of the world. Since the representation
is constant, we can use a simpler reader monad instead of a state
monad to implement the \texttt{IO} type. Therefore, the runtime system
really uses
\begin{equation}
  \mbox{\texttt{type IO a = () -> a}}\label{eq:our-io}
\end{equation}
Note that the IO monad is lazy, i.e., the result of a monadic action
is computed only when it is used by the program. Thus, the program
\verb|return undefined >> putStrLn "Hello world"| will print the
string \verb|Hello world| on the standard output. While this is
straight forward to implement using
representation~(\ref{eq:monadic-io}), we must be careful not to
evaluate the returned node in our representation~(\ref{eq:our-io}).

The program used for executing a monadic goal evaluates the goal to
head-normal form, but does not compute nor print the result of the
monadic action itself.

<<io_monad.c>>=
static int  io_argc;
static char **io_argv;
static int  curry_rc = 0;

int
curry_exec(NodeInfo *main_info, int argc, char **argv)
{
    io_argc = argc;
    io_argv = argv;

    assert(main_info->kind == LAZY_KIND && main_info->tag == NOUPD_TAG &&
	   main_info->length == closure_node_size(0));

    regs.r[0] = (Node *)&main_info;
    run(start_io);
    regs.hlim = heap_base;
    release_mem();
    return curry_rc;
}

void
curry_exit(int rc)
{
    curry_rc = rc;
    halt();
}
int
curry_argc()
{
    return io_argc;
}

char **
curry_argv()
{
    return io_argv;
}

static
FUNCTION(start_io)
{
 ENTRY_LABEL(static, start_io)
    regs.handlers = &io_handlers;
    TRACE(("start program\n"));
    start_thread(1, 0);
    /* Hack: Change the return address of the main thread */
    CALL2(___64_, stop_io, regs.r[0], unit);
}

static
FUNCTION(stop_io)
{
 ENTRY_LABEL(static, stop_io)
    curry_exit(0);
}

void
fail_with(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    fprintf(stderr, "Error: ");
    vfprintf(stderr, format, args);
    fprintf(stderr, "\n");
    va_end(args);

    curry_exit(1);
}

@
The code for the primitive I/O actions \texttt{return}, \texttt{(>>)},
and \texttt{(>>=)} is implemented in this file, too. The function
\texttt{(>>)} could be defined as prelude function but we can
implement it more efficiently here. Note that all functions take an
additional argument due to the underlying representation of the
\texttt{IO} monad. Also note that \texttt{return} does not evaluate
its argument because of the lazy IO monad semantics.

<<io_monad.c>>=
DECLARE_LABEL(extern, __return);

FUNCTION(__return)
{
 ENTRY_LABEL(extern, __return)
    RET(regs.r[0]);
}

DECLARE_LABEL(extern, ___62__62_);
DECLARE_LABEL(static, ___62__62__1);

FUNCTION(___62__62_)
{
 ENTRY_LABEL(extern, ___62__62_)
    SAVE_REGS(2);
    CALL2(___64_, ___62__62__1, regs.r[0], regs.r[2]);
}

static
FUNCTION(___62__62__1)
{
 ENTRY_LABEL(static, ___62__62__1)
    CALL_RET2(___64_, 2, regs.sp[0], regs.sp[1]);
}

DECLARE_LABEL(extern, ___62__62__61_);
DECLARE_LABEL(static, ___62__62__61__1);
DECLARE_LABEL(static, ___62__62__61__2);

FUNCTION(___62__62__61_)
{
 ENTRY_LABEL(extern, ___62__62__61_)
    SAVE_REGS(2);
    CALL2(___64_, ___62__62__61__1, regs.r[0], regs.r[2]);
}

static
FUNCTION(___62__62__61__1)
{
    Node *f, *x;
 ENTRY_LABEL(static, ___62__62__61__1)
    f = *regs.sp++;
    x = regs.r[0];
    CALL2(___64_, ___62__62__61__2, f, x);
}

static
FUNCTION(___62__62__61__2)
{
 ENTRY_LABEL(static, ___62__62__61__2)
    assert(regs.r[0]->info->kind == PAPP_KIND && regs.r[0]->info->tag == 1);
    GOTO(regs.r[0]->info->apply);
}

@
The function [[catch]] lets the user catch I/O exceptions in monadic
code. The function is passed a monadic action and an exception
handler. It creates a new exception frame on the stack and saves the
handler and the previous exception frame in the new frame, and then
executes the monadic action in the new context. When the action
returns normally, the frame is removed from the stack and the result
is returned to the caller.

<<io_monad.c>>=
DECLARE_LABEL(extern, __catch);
DECLARE_LABEL(static, __catch_1);

FUNCTION(__catch)
{
    unsigned int   frm_sz;
    ExceptionFrame *prevFrame;
 ENTRY_LABEL(extern, __catch)
    frm_sz = wordsof(ExceptionFrame);
    CHECK_STACK(frm_sz + 1);

    /* create and initialize the new exception frame */
    prevFrame	      = regs.efp;
    regs.sp	     -= frm_sz + 1;
    regs.efp	      = (ExceptionFrame *)regs.sp;
    regs.efp->handler = regs.r[1];
    regs.efp->frame   = prevFrame;
    regs.sp[frm_sz]   = (Node *)regs.ret;

    /* invoke the action */
    CALL2(___64_, __catch_1, regs.r[0], regs.r[2]);
}

static
FUNCTION(__catch_1)
{
 ENTRY_LABEL(static, __catch_1)
    assert((Node **)regs.efp == regs.sp);
    regs.efp = regs.efp->frame;
    RETURN(regs.r[0], wordsof(ExceptionFrame));
}

@
The function [[ioError]] raises a user exception. It removes the stack
up to and including the current exception frame and applies the
exception handler from that frame to the exception value. If no
exception handler is available -- as may happen when
[[unsafePerformIO]] is used -- the program is aborted using the
[[error]] function from the prelude.

<<io_monad.c>>=
DECLARE_LABEL(extern, __Prelude__error);
DECLARE_LABEL(static, __ioError_1);

FUNCTION(__ioError)
{
    Node	   *exc, *handler;
    ExceptionFrame *curFrame;
 ENTRY_LABEL(extern, __ioError)
    exc = regs.r[0];
    TRACE(("%I throw %N\n", exc));

    if ( regs.efp == 0 )
	EXEC1(__Prelude__error,
	      prefix_string(0, "Uncaught I/O exception:\n", exc));

    curFrame = regs.efp;
    handler  = regs.efp->handler;
    regs.efp = regs.efp->frame;

    regs.sp    = (Node **)curFrame + wordsof(ExceptionFrame) - 1;
    regs.sp[0] = regs.r[1];
    CALL2(___64_, __ioError_1, handler, exc);
}

static
FUNCTION(__ioError_1)
{
 ENTRY_LABEL(static, __ioError_1)
    assert(regs.r[0]->info->kind == PAPP_KIND && regs.r[0]->info->tag == 1);
    GOTO(regs.r[0]->info->apply);
}

@
The function [[unsafePerformIO]] allows executing a monadic action
and returning its result into a regular function. The function can be
used for implementing a simple (unsafe) trace function and can also
serve for generating unique entities~\cite{AugustssonRittriSynek94:Unique}.

Recall that the IO monad is lazy, therefore we must evaluate the result
of the monadic action to head normal form, eventually.

\textbf{As the name of the function suggests, its use is totally
unsafe. This function is a hack and should not be used casually.}

<<io_monad.c>>=
DECLARE_LABEL(extern, __unsafePerformIO);
DECLARE_LABEL(static, __unsafePerformIO_1);

FUNCTION(__unsafePerformIO)
{
 ENTRY_LABEL(extern, __unsafePerformIO)
    SAVE_REGS(0);
    CALL2(___64_, __unsafePerformIO_1, regs.r[0], unit);
}

static
FUNCTION(__unsafePerformIO_1)
{
    Node *x;
 ENTRY_LABEL(static, __unsafePerformIO_1)
    x = regs.r[0];
    if ( is_boxed(x) )
	ENTER(x, 0);
    RETURN(x, 0);
}

@
The [[fixIO]] function was recently introduced in Haskell in order to
allow recursive bindings in a monad. The function is the fixpoint
operator in the IO monad with type [[(a -> IO a) -> IO a]] and
corresponds to the regular fix point operator [[fix :: (a -> a) -> a]]
that can be defined as
\begin{equation}
  \mbox{\texttt{fix f = let x = f x in x}}\label{eq:fix}
\end{equation}
in Curry.\footnote{Actually, this definition is not valid according to
the Curry report because of the recursive value binding. However, it
is accepted as an extension by our compiler.} The following is an
attempt to implement fixIO in Curry. Using the
representation~(\ref{eq:monadic-io}) of \texttt{IO a} together with
\texttt{type World = ()}, [[fixIO]] can be defined as follows.
\begin{equation}
  \mbox{\texttt{fixIO f () = let (x,()) = f x () in (x,())}}\label{eq:fixIO}
\end{equation}
As we use the representation~(\ref{eq:our-io}) instead
of~(\ref{eq:monadic-io}), our implementation is even closer to the
definition of \texttt{fix}.
\begin{equation}
  \mbox{\texttt{fixIO f () = let x = f x () in x}}\label{eq:our-fixIO}
\end{equation}

<<io_monad.c>>=
DECLARE_LABEL(extern, __fixIO);

FUNCTION(__fixIO)
{
    Node *clos, *susp;
 ENTRY_LABEL(extern, __fixIO)
    CHECK_HEAP(2, closure_node_size(2) + suspend_node_size(2));
    clos     = (Node *)regs.hp;
    susp     = (Node *)(regs.hp + closure_node_size(2));
    regs.hp += closure_node_size(2) + suspend_node_size(2);

    clos->info	    = &___64__info;
    clos->c.args[0] = regs.r[0];
    clos->c.args[1] = susp;

    susp->info	    = ___64__lazy_info_table;
    susp->s.spc	    = regs.ss;
    susp->s.args[0] = clos;
    susp->s.args[1] = regs.r[1];

    ENT(susp);
}
