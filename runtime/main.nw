% -*- noweb-code-mode: c-mode -*-
% $Id: main.nw 1899 2006-04-19 10:50:11Z wlux $
%
% Copyright (c) 2001-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
@
\subsection{Runtime system initialization}
The [[main]] function of a Curry program must initialize the runtime
system by calling the function [[curry_init]]. This function parses
the command line options and initializes the runtime system
accordingly. At the end, the program should call [[curry_terminate]]
in order to display the statistics gathered during the run.

The main program is also responsible for providing default sizes for
the heap, the stack, and the trail. To this end it must define the
global variables [[heapsize]], [[stacksize]], and [[trailsize]]. The
actual sizes can be changed at runtime with the runtime system options
\texttt{-h}, \texttt{-k}, and \texttt{-t}, respectively. The defaults
sizes (4 MBytes for the heap and 512 kBytes for the stack and the
trail) are available with the preprocessor constants
[[DEFAULT_HEAPSIZE]], [[DEFAULT_STACKSIZE]], and
[[DEFAULT_TRAILSIZE]] which can be redefined at compile time.

The sizes and base addresses of the heap, the stack, and the trail are
rounded to the next page boundary. Fur the purpose of rounding, the
global variable [[pagemask]] is set to 1 less than the operating
system's page size. If the page size cannot be determined
from the operating system, a default of 4k is used. %'

<<main.h>>=
#define k 1024
#define M k*k

#ifndef DEFAULT_HEAPSIZE
# define DEFAULT_HEAPSIZE 4*M
#endif

#ifndef DEFAULT_STACKSIZE
# define DEFAULT_STACKSIZE 512*k
#endif
#ifndef DEFAULT_TRAILSIZE
# define DEFAULT_TRAILSIZE 512*k
#endif

#ifndef DEFAULT_SHOW_STATS
# define DEFAULT_SHOW_STATS 0
#endif

#ifndef DEFAULT_DO_TRACE
# define DEFAULT_DO_TRACE 0
#endif

extern unsigned long heapsize;
extern unsigned int  stacksize;
extern unsigned int  trailsize;

extern int do_trace;
extern int show_stats;

extern unsigned long pagemask;

extern void curry_init(int *argc, char *argv[]);
extern void curry_terminate(void);

@ 
The function [[curry_init]] extracts the runtime system options from
the command line and initializes the runtime system using these
options. Options to the runtime system must be enclosed by
\texttt{+RTS} and \texttt{-RTS}. The latter may be omitted if no
further arguments follow it on the command line. When [[curry_init]]
returns, all runtime system options have been removed from the
argument vector.

The function [[curry_terminate]] performs some clean up after the
program has finished. At present, this function only prints the
current statistics.

<<main.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "trail.h"
#include "files.h"
#include "trace.h"
#include "main.h"
#include "stats.h"

static void	     bad_option(void) __attribute__((noreturn));
static unsigned int  parse_size(const char *, const char *);
static unsigned long parse_size_long(const char *, const char *);

#define DEFAULT_PAGESIZE 4*k

unsigned long pagemask;

static void
bad_option()
{
    fprintf(stderr, "Valid runtime system options:\n");
    fprintf(stderr, " -b MODE  set buffer mode for standard input/output\n");
    fprintf(stderr, "          valid MODEs: n  unbuffered\n");
    fprintf(stderr, "                       l  line buffered\n");
    fprintf(stderr, "                       f  fully buffered\n");
    fprintf(stderr, " -d       trace program execution\n");
    fprintf(stderr, " -h SIZE  set heap size to SIZE bytes (default: %lu)\n",
	    heapsize);
    fprintf(stderr, " -p       print statistics at end of run\n");
    fprintf(stderr, " -k SIZE  set stack size to SIZE bytes (default: %u)\n",
	    stacksize);
#if !COPY_SEARCH_SPACE
    fprintf(stderr, " -t SIZE  set trail size to SIZE bytes (default: %u)\n",
	    trailsize);
#endif
    exit(1);
}

void
curry_init(int *p_argc, char *argv[])
{
    boolean rts;
    char    *cp, *arg;
    int	    i, j, argc;
    int     pagesize, bufmode = -1, bufsize = 0;

    /* get system page size */
    pagesize = getpagesize();
    if ( pagesize == -1 )
	pagesize = DEFAULT_PAGESIZE;
    pagemask = pagesize - 1;

    /* process rts options */
    argc = *p_argc;
    rts	 = false;
    for ( i = j = 1; i < argc; i++ )
    {
	cp = argv[i];
	if ( !rts )
	    if ( strcmp(cp, "+RTS") == 0 )
		rts = true;
	    else
		argv[j++] = cp;
	else if ( strcmp(cp, "-RTS") == 0 )
	    rts = false;
	else
	{
	    if ( *cp == '-' )
		for ( cp++; *cp != '\0'; cp++ )
		    switch ( *cp )
		    {
		    case 'd':
			do_trace++;
			break;
		    case 'p':
			show_stats++;
			break;
		    case 'b':
		    case 'h':
		    case 'k':
#if !COPY_SEARCH_SPACE
		    case 't':
#endif
			if ( cp[1] != '\0' )
			    arg = cp + 1;
			else if ( ++i < argc )
			    arg = argv[i];
			else
			{
			    fprintf(stderr, "%s: missing argument after -%c\n",
				    argv[0], *cp);
			    bad_option();
			}
			switch ( *cp )
			{
			case 'b':
			    if ( strcmp(arg, "n") == 0 )
				bufmode = _IONBF;
			    else if ( strcmp(arg, "l") == 0 )
				bufmode = _IOLBF;
			    else if ( strcmp(arg, "f") == 0 )
				bufmode = _IOFBF;
			    else if ( *arg == 'f' )
			    {
				bufmode = _IOFBF;
				bufsize = parse_size("buffer size", arg + 1);
			    }
			    else
			    {
				fprintf(stderr,
					"%s: invalid file buffer mode %s\n",
					argv[0], arg);
				bad_option();
			    }
			    break;
			case 'h':
			    heapsize = parse_size_long("heap size", arg);
			    break;
			case 'k':
			    stacksize = parse_size("stack size", arg);
			    break;
#if !COPY_SEARCH_SPACE
			case 't':
			    trailsize = parse_size("trail size", arg);
			    break;
#endif
			}
			cp = "\0";
			break;
		    default:
			fprintf(stderr,
				"%s: unknown runtime system option %c\n",
				argv[0], *cp);
			bad_option();
		    }
	    else
	    {
		fprintf(stderr, "%s: unknown runtime system argument %s\n",
			argv[0], cp);
		bad_option();
	    }
	}
    }
    argv[j] = NULL;
    *p_argc = j;

    /* initialize runtime system */
    init_chars();
    init_stack(stacksize);
#if !COPY_SEARCH_SPACE
    init_trail(trailsize);
#endif
    init_heap(heapsize);
    init_files(bufmode, bufsize);
    stats_init(show_stats);
}

void
curry_terminate()
{
    stats_terminate(hp - heap_base);
}

@ 
As a handy abbreviation, the functions [[parse_size]] and
[[parse_size_long]] parse numbers with the suffixes [[k]] and [[K]] as
kBytes and with the suffixes [[m]] and [[M]] as MBytes. 

<<main.c>>=
static unsigned int
parse_size(const char *what, const char *arg)
{
    long size;
    char *end;

    size = strtol(arg, &end, 0);
    if ( *end != '\0' )
    {
	if ( strcmp(end, "m") == 0 || strcmp(end, "M") == 0 )
	    size = size > INT_MAX / M ? INT_MAX : size * M;
	else if ( strcmp(end, "k") == 0 || strcmp(end, "K") == 0 )
	    size = size > INT_MAX / k ? INT_MAX : size * k;
	else
	    size = -1;
    }

    if ( size <= 0 )
    {
	fprintf(stderr, "invalid %s: %s\n", what, arg);
	exit(1);
    }

    return size > INT_MAX ? INT_MAX : size;
}

static unsigned long
parse_size_long(const char *what, const char *arg)
{
    long size;
    char *end;

    size = strtol(arg, &end, 0);
    if ( *end != '\0' )
    {
	if ( strcmp(end, "m") == 0 || strcmp(end, "M") == 0 )
	    size = size > LONG_MAX / M ? LONG_MAX : size * M;
	else if ( strcmp(end, "k") == 0 || strcmp(end, "K") == 0 )
	    size = size > LONG_MAX / k ? LONG_MAX : size * k;
	else
	    size = -1;
    }

    if ( size <= 0 )
    {
	fprintf(stderr, "invalid %s: %s\n", what, arg);
	exit(1);
    }

    return size > LONG_MAX ? LONG_MAX : size;
}
