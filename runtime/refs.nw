% -*- noweb-code-mode: c-mode -*-
% $Id: refs.nw 2262 2007-06-16 14:46:48Z wlux $
%
% Copyright (c) 2004-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Mutable References}
The \texttt{IOExts} library implements mutable references in the
\texttt{IO} monad. The implementation is based on three primitives,
which are defined in this file.

<<refs.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "trail.h"
#include "eval.h"
#include "threads.h"
#include "data.h"
#include "cam.h"

#define MATCH_RIGID_IOREF(l)	MATCH_RIGID_ABSTRACT(l)

typedef struct ioref_node {
    NodeInfo *info;
    Node     *ref;
} IORef;

#define ioref_node_size wordsof(IORef)

static NodeInfo ioref_info = {
    ABSTRACT_KIND, 0, closure_node_size(1), 0, "<IORef>", eval_whnf, 0, 0, 0
};

@ 
Two mutable references are considered equal, if they are physically
the same.

<<refs.c>>=
DECLARE_CONST(__Prelude__False);
DECLARE_CONST(__Prelude__True);

#define Prelude_False CONST(__Prelude__False)
#define Prelude_True  CONST(__Prelude__True)

DECLARE_LABEL(extern, __primEqIORef);
DECLARE_LABEL(static, __primEqIORef_1);
DECLARE_LABEL(static, __primEqIORef_2);

FUNCTION(__primEqIORef)
{
 ENTRY_LABEL(extern, __primEqIORef)
    EVAL_BOXED(__primEqIORef_1);
}

static
FUNCTION(__primEqIORef_1)
{
 ENTRY_LABEL(static, __primEqIORef_1)
    MATCH_RIGID_IOREF(__primEqIORef_1);
    SWAPn(1);
    EVAL_BOXED(__primEqIORef_2);
}

static
FUNCTION(__primEqIORef_2)
{
    Node *r;
 ENTRY_LABEL(static, __primEqIORef_2)
    MATCH_RIGID_IOREF(__primEqIORef_2);
    r	     = regs.sp[1] == regs.sp[0] ? Prelude_True : Prelude_False;
    regs.sp += 2;
    RETURN(r);
}

@ 
The function [[newIORef]] creates a new [[IORef]] and initializes it
with the specified value.

<<refs.c>>=
DECLARE_LABEL(extern, __newIORef);

FUNCTION(__newIORef)
{
    IORef *ref;
 ENTRY_LABEL(extern, __newIORef)
    CHECK_HEAP(ioref_node_size);
    ref	      = (IORef *)regs.hp;
    ref->info = &ioref_info;
    ref->ref  = regs.sp[0];
    regs.hp  += ioref_node_size;

    regs.sp += 2;
    RETURN((Node *)ref);
}

@ 
The function [[readIORef]] returns the value that is currently saved
in a mutable reference. Note that the value is \emph{not} evaluated
to head normal form because the \texttt{IO} monad is lazy.

<<refs.c>>=
DECLARE_LABEL(extern, __readIORef);
DECLARE_LABEL(static, __readIORef_1);

FUNCTION(__readIORef)
{
 ENTRY_LABEL(extern, __readIORef)
    EVAL_BOXED(__readIORef_1);
}

static
FUNCTION(__readIORef_1)
{
    IORef *ref;
 ENTRY_LABEL(static, __readIORef_1)
    MATCH_RIGID_IOREF(__readIORef_1);
    ref	     = (IORef *)regs.sp[0];
    regs.sp += 2;
    RETURN(ref->ref);
}

@ 
The function [[writeIORef]] updates the value saved in a mutable
reference. The old value is saved on the trail even though the
\texttt{IO} monad is expected to run only deterministic code. However,
trailing prevents program crashes when this function is used inside an
[[unsafePerformIO]]. Note that this makes it impossible to use mutable
references for generating globally unique indices that are different
even across different branches of a non-deterministic search.

<<refs.c>>=
DECLARE_LABEL(extern, __writeIORef);
DECLARE_LABEL(static, __writeIORef_1);

FUNCTION(__writeIORef)
{
 ENTRY_LABEL(extern, __writeIORef)
    EVAL_BOXED(__writeIORef_1);
}

static
FUNCTION(__writeIORef_1)
{
    IORef *ref;
 ENTRY_LABEL(static, __writeIORef_1)
    MATCH_RIGID_IOREF(__writeIORef_1);
    ref = (IORef *)regs.sp[0];
    SAVE(ref, ref);
    ref->ref = regs.sp[1];
    regs.sp += 3;
    RETURN(unit);
}
