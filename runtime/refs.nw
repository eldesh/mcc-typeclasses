% -*- noweb-code-mode: c-mode -*-
% $Id: refs.nw 2853 2009-05-29 11:55:01Z wlux $
%
% Copyright (c) 2004-2008, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Mutable References}
The \texttt{IOExts} library implements mutable references in the
\texttt{IO} monad. The implementation is based on three primitives,
which are defined in this file.

<<refs.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "eval.h"
#include "trail.h"
#include "refs.h"

typedef struct ioref_node {
    NodeInfo *info;
    Node     *ref;
} IORef;

#define ioref_node_size wordsof(IORef)

static NodeInfo ioref_info = {
    ABSTRACT_KIND, 0, closure_node_size(1), 0, "<IORef>", eval_whnf, 0, 0, 0
};

@ 
The function [[primNewIORef]] creates a new mutable reference and
initializes it with the specified value. The initial value is passed
in the form \texttt{Wrap}~$e$ in order to prevent evaluation of $e$ by
the foreign function interface code.

<<refs.h>>=
extern Node *primNewIORef(Node *);

@ 
<<refs.c>>=
Node *
primNewIORef(Node *wrappedArg)
{
    IORef *ref;

    BEGIN_LOCAL_ROOTS1(wrappedArg)
    CHECK_HEAP(0, ioref_node_size);
    ref	      = (IORef *)regs.hp;
    ref->info = &ioref_info;
    ref->ref  = wrappedArg->c.args[0];
    regs.hp  += ioref_node_size;
    END_LOCAL_ROOTS

    return (Node *)ref;
}

@ 
The function [[primReadIORef]] returns the value that is currently
saved in a mutable reference.

<<refs.h>>=
extern Node *primReadIORef(Node *);

@ 
<<refs.c>>=
Node *
primReadIORef(Node *refNode)
{
    IORef *ref;

    assert(refNode->info == &ioref_info);
    ref = (IORef *)refNode;
    return ref->ref;
}

@ 
The function [[primWriteIORef]] updates the value saved in a mutable
reference. The assigned value is passed in the form \texttt{Wrap}~$e$
in order to prevent evaluation of $e$ by the foreign function
interface code. The old value is saved on the trail even though the
\texttt{IO} monad is expected to run only deterministic code. However,
trailing prevents program crashes when this function is used inside an
[[unsafePerformIO]]. Note that this makes it impossible to use mutable
references for generating globally unique indices that are different
even across different branches of a non-deterministic search.

<<refs.h>>=
extern void primWriteIORef(Node *, Node *);

@ 
<<refs.c>>=
void
primWriteIORef(Node *refNode, Node *wrappedArg)
{
    IORef *ref;

    assert(refNode->info == &ioref_info);
    ref = (IORef *)refNode;
    SET_FIELD(ref, ref, wrappedArg->c.args[0]);
}
