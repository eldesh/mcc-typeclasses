% -*- noweb-code-mode: c-mode -*-
% $Id: run.nw 1744 2005-08-23 16:17:12Z wlux $
%
% Copyright (c) 2001-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Execution}\label{sec:execution}
While C can be used conveniently as a ``high-level'' assembly
language, there is one gap which complicates the efficient
implementation of declarative languages, viz. the lack of a general
tail-call in the language.\footnote{The Gnu C compiler optimizes
tail-calls into jumps to the beginning of the function. However,
this works only for calls to the same function.}

There are various possible strategies known to handle this
problem. The most simple solution is to provide a trampoline loop. If
a function wants to perform a tail call, it simply returns the address
of the callee to the trampoline, which then in turn calls this
function. This strategy is portable but inefficient because of its
additional overhead.

A more efficient solution is possible for the Gnu C compiler. With the
help of assembler labels inserted into the code and using computed
\texttt{goto}s, a tail call is performed by jumping directly to these
labels. Implemented this way, the standard function prologue, which
sets up the local stack frame of the callee, is skipped over and no
additional stack space is allocated. The stack space is allocated in
the driver function, which now only has to jump to the first code
address. This strategy will fail if the function prologue has to do
more work than just setting up a stack frame; it can therefore be
turned off by defining the pre-processor macro [[USE_TRAMPOLINE]].

The type of a code label which can be used in a tail call is either
a function which returns a [[void]] pointer\footnote{In fact, the
function returns another function with the same type. However, such a
recursive type cannot be declared in C.} or is itself a [[void]]
pointer in order to be used in (computed) \texttt{goto} statements.

<<run.h>>=
#if !USE_TRAMPOLINE
# ifndef __GNUC__
#  error "direct jumps require Gnu C; reconfigure with --enable-trampoline"
# endif
#endif

#if USE_TRAMPOLINE
typedef void *(*Label)(void);
#else
typedef void *Label;
#endif

@ 
Every code block of the abstract machine code is translated into a C
function on its own. In case of the trampoline execution model, these
functions simply return to their caller (the trampoline) when they
want to perform a jump to another code block via the [[GOTO]] macro.

In case of the direct jump model, which was derived from the
implementation of the Mercury runtime
system~\cite{HendersonConwaySomogyi95:Portable}, we use Gnu C's
ability to handle labels as values. With the extended assembler
feature of Gnu C, a label is inserted immediately after the function's
prologue. The macro [[GOTO]] then jumps directly to that label. By
renaming the function itself and adding a function declaration which
associates the function name with its entry point, we can simply use
the function name in both models to refer to the entry point of a
function.

Getting the direct jump model to work is a little bit tricky. At least
on the Intel x86 architecture, some versions of Gnu C may not pop the
arguments of the last call before a computed [[goto]] statement if no
label is declared in the function. Furthermore, if only one label is
declared in a function, computed [[goto]]s in that function are
``optimized'' into jumps to that label. This means that at least two
labels must be declared in a function in order to generate correct
code for the direct jump model. The macros below therefore insert one
label immediately after the entry point label and additional labels
after each computed [[goto]] statement. In order to prevent Gnu C from
assuming that the code can fall through a [[GOTO]] macro, those labels
are followed immediately by a call to the [[halt]] function.

The assembler statement within the [[GOTO]] macro serves two purposes.
It marks the local label used and it ensures that the compiler will
not cache any global variables over the goto statement with the help
of a [[memory]] clobber description. Unfortunately, this may also
cause some redundant register reloads when the argument of the
[[GOTO]] macro is an expression that computes the jump
target.\footnote{Many versions of Gnu C generate correct code without
the clobber description, but at least for Gnu C version 3.2 on x86
targets it is necessary.}

<<run.h>>=
#if USE_TRAMPOLINE

# define FUNCTION(f)		void *f(void)
# define DECLARE_ENTRYPOINT(l)	extern void *l(void)
# define DECLARE_LABEL(l)       static void *l(void)
# define EXPORT_LABEL(l)
# define ENTRY_LABEL(l)

# define GOTO(l)		return (void *)(l)

#else /* !USE_TRAMPOLINE */

# define C_STACK_SIZE 8192

# if __GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 1
#  define _USED			__attribute__((used))
#  define _USE(l)
# else
#  define _USED
#  define _USE(l)		: : "g" (_FUNC(l))
# endif

# define FUNCTION(f)		void _FUNC(f)(void)
# define DECLARE_ENTRYPOINT(l)			\
    void _FUNC(l)(void) _USED;			\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define DECLARE_LABEL(l)			\
    static void _FUNC(l)(void) _USED;		\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define _FUNC(f) f##_func
# define EXPORT_LABEL(l)	__asm__(" .globl " _ENTRY_LABEL(l) "\n");
# define ENTRY_LABEL(l)				\
    __asm__(_ENTRY_LABEL(l) ":" _USE(l));	\
    __asm__("" : : "g"(&&entry)); entry:
# define _ENTRY_LABEL(l)	#l "_entry"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* work around an instruction scheduler bug in gcc 2.91 for sparc */
extern Label ip;
#  define _GOTO(l)		ip = (Label)(l); goto *ip
# else
#  define _GOTO(l)		goto *(Label)(l)
# endif
# define GOTO(l) ({			      \
	__label__ _l;			      \
	__asm__("" : : "g"(&&_l) : "memory"); \
	_GOTO(l);			      \
    _l: halt();				      \
    })

#endif /* !USE_TRAMPOLINE */

@ 
The [[run]] function executes the compiled code starting at label
[[ip]]. The execution of the compiled code should be terminated by a
call to the [[halt]] function.

<<run.h>>=
extern void run(Label ip);
extern void halt(void) __attribute__ ((noreturn));

@ 
If the runtime system is compiled with [[USE_TRAMPOLINE]], the [[run]]
function is a trampoline loop that repeatedly calls the function
returned from the previous call. In order to improve efficiency, the
loop has been unrolled 8 times and does not perform a null pointer
test. In order to stop execution, a [[longjmp]] to the context stored
in [[halt_buf]] has to be performed. This jump buffer is initialized
at the beginning of the [[run]] function.

<<run.c>>=
#include "config.h"
#include <setjmp.h>
#include "run.h"

static jmp_buf halt_buf;

#if USE_TRAMPOLINE
void
run(Label ip)
{
    if ( setjmp(halt_buf) == 0 )
    {
	while ( 1 )
	{
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	    ip = (Label)(*ip)();
	}
    }
}
#endif /* USE_TRAMPOLINE */

@
If the runtime system uses direct jumps via Gnu C extensions, the
[[run]] function initializes the [[halt_buf]] structure and then calls
the auxiliary function [[do_run]]. This function allocates a stack
frame which is large enough to handle the allocation requirements of
all functions in the program and then jumps to the entry point of the
program. The compiled functions should never return, but use a
[[longjmp]] in order to terminate execution.

We do not allocate the stack frame in the [[run]] function and call
the main entry point from there because the compiler may save some
registers in the stack frame and their contents could be overwritten
by the tail called functions otherwise.

Furthermore, the [[do_run]] function performs a redundant call to the
[[trace]] function so that it is not treated as a leaf procedure. This
is necessary on some architectures in order to ensure that a proper
stack frame is set up for [[do_run]]. Any other function which
effectively performs no operation, but cannot be inlined by the
compiler would do as well.

<<run.c>>=
#if !USE_TRAMPOLINE
#include "trace.h"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* needed to work around an instruction scheduler bug in gcc 2.91 for sparc */
Label ip;
# endif

static void do_run(Label ip);

void
run(Label ip)
{
    if ( setjmp(halt_buf) == 0 )
	do_run(ip);
}

static void
do_run(Label ip)
{
    char dummy[C_STACK_SIZE];

    /* hack to avoid unused variable warning */
    __asm__("" : : "g"(dummy));

    /* DO NOT REMOVE THIS CALL! */
    trace("");

    goto *ip;
}
#endif /* !USE_TRAMPOLINE */

@ 
The [[halt]] function stops execution of the abstract machine code by
performing a non-local jump to the context saved in [[halt_buf]].

<<run.c>>=
void
halt()
{
    longjmp(halt_buf, 1);
}
