% -*- noweb-code-mode: c-mode -*-
% $Id: run.nw 2751 2008-08-30 13:24:59Z wlux $
%
% Copyright (c) 2001-2008, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Execution}\label{sec:execution}
While C can be used conveniently as a ``high-level'' assembly
language, the lack of general tail-calls in the language complicates
the efficient implementation of declarative languages. The common
workaround is to use a trampoline loop. In order to perform a
tail-call, a function simply returns the address of the callee to the
trampoline, which then calls that function. This strategy is portable
but may be inefficient due to the overhead introduced by returning to
the trampoline. Furthermore, the indirect call sequence prevents
intra-procedural optimizations by the C compiler and may also
interfere with instruction prefetching.

As a remedy, Baker~\cite{Baker95:CheneyMTA} proposed implementing
tail-calls as normal function calls and jumping back to the trampoline
only when the C runtime stack fills up, which can be detected either
with an explicit address comparison or by using a protected virtual
memory page at the high end of the stack. Experiments with our
compiler show that this technique can substantially improve
performance on x86 and x86-64 targets reducing execution time by up to
a factor of 2 for some benchmarks. On PowerPC and probably most other
RISC processors there is no such clear advantage. Usually these
processors feature better branch prediction due to the use of a
dedicated return address register. Furthermore, for the standard
trampoline implementation many functions become leaf procedures which
do not need to allocate a stack frame of their own. In fact, on SPARC
hosts Baker's ``Cheney on the M.T.A.'' technique even turns out to be
counterproductive, since it effectively generates an expensive
register spill exception for each call. %'

A more efficient solution is possible for the Gnu C compiler. With the
help of assembler labels inserted into the code and using computed
\texttt{goto}s, a tail-call is performed by jumping directly to these
labels. Implemented this way, the standard function prologue, which
sets up the local stack frame of the callee, is skipped over and no
additional stack space is allocated. The stack space is allocated in
the driver function, which now only has to jump to the first code
address. This strategy will fail if the function prologue has to do
more work than just setting up a stack frame, which, for instance, is
the case on many architectures when generating position independent
code. Therefore, it can be turned off by defining the preprocessor
macro [[USE_TRAMPOLINE]].

The type of a code label which can be used in a tail-call is either
a function which returns a [[void]] pointer\footnote{In fact, the
function returns another function with the same type. However, such
recursive types cannot be declared in C.} or is itself a [[void]]
pointer in order to be used in (computed) \texttt{goto} statements.

<<run.h>>=
#if !USE_TRAMPOLINE
# ifndef __GNUC__
#  error "direct jumps require Gnu C; reconfigure with --enable-trampoline"
# endif
#endif

#if USE_TRAMPOLINE
typedef void *(*Label)(void);
#else
typedef void *Label;
#endif

@ 
Every code block of the abstract machine code is translated into a C
function of its own. In case of the trampoline execution model and
depending on whether a standard trampoline loop or the ``Cheney on the
M.T.A.''  technique is employed, these functions either simply return
the address of the jump target to their caller (the trampoline) or
call the target block directly when they want to perform a jump to
another code block via the [[GOTO]] macro. When the ``Cheney on the
M.T.A.'' technique is used, the entry code of each abstract machine
function uses the [[C_STACK_CHECK]] macro to check whether the alloted
C runtime stack space is exhausted and returns to the trampoline in
that case. Usually, this is implemented with a single [[longjmp]].
However, if the preprocessor flag [[USE_RETURN]] is defined, the code
will return normally to the trampoline. This may be useful when using
the ``Cheney on the M.T.A.''  technique with small stack sizes on a
target with an expensive [[longjmp]] implementation. Note that for Gnu
C, the stack check is implemented with the built-in function
[[__builtin_frame_address]] so as to not disable the tail call
optimization by taking the address of a local variable.

In case of the direct jump model, which was derived from the
implementation of the Mercury runtime
system~\cite{HendersonConwaySomogyi95:Portable}, we use Gnu C's
ability to handle labels as values. With the extended assembler
feature of Gnu C, a label is inserted immediately after the function's
prologue with the [[ENTRY_LABEL]] macro. The code generated by the
[[GOTO]] macro then jumps directly to that label. By renaming the
function itself in the [[DECLARE_LABEL]] and [[FUNCTION]] macros and
adding a function declaration in [[DECLARE_LABEL]], which associates
the function name with its entry point, we can simply use the function
name in both models to refer to the entry point of a function. The
first argument of the macros [[DECLARE_LABEL]] and [[ENTRY_LABEL]]
specifies whether the label has internal or external linkage using the
C language keywords [[static]] and [[extern]], respectively.

Getting the direct jump model to work is a little bit tricky. At least
on the Intel x86 architecture, some versions of Gnu C may not pop the
arguments of the last call before a computed [[goto]] statement if no
label is declared in the function. Furthermore, if only one label is
declared in a function, computed [[goto]]s in that function are
``optimized'' into jumps to that label. This means that at least two
labels must be declared in a function in order to generate correct
code for the direct jump model. The macros below therefore insert one
label immediately after the entry point label and additional labels
after each computed [[goto]] statement. In order to prevent Gnu C from
assuming that the code can fall through a [[GOTO]] macro, those labels
are followed immediately by a call to the [[halt]] function.

The assembler statement within the [[GOTO]] macro serves two purposes.
It marks the local label used and it ensures that the compiler will
not cache any global variables over the [[goto]] statement with the
help of a [[memory]] clobber description. Unfortunately, this may also
cause some redundant register reloads when the argument of the
[[GOTO]] macro is an expression that computes the jump
target.\footnote{Many versions of Gnu C generate correct code without
the clobber description, but at least for Gnu C version 3.2 on x86
targets it is necessary.}

<<run.h>>=
#if USE_TRAMPOLINE

# define FUNCTION(f)		void *f(void)
# define DECLARE_LABEL(link, l) link void *l(void)
# define ENTRY_LABEL(link, l)

# if C_STACK_SIZE > 0

#  if __GNUC__
#   define _C_STACK_POINTER
#   define _C_STACK_TOP		__builtin_frame_address(0)
#  else
#   define _C_STACK_POINTER	char _c_sp
#   define _C_STACK_TOP		&_c_sp
#  endif
#  if C_STACK_GROWS_UPWARD
#   define _C_STACK_OVERFLOW	_C_STACK_TOP >= c_stack.limit
#  else
#   define _C_STACK_OVERFLOW	_C_STACK_TOP <= c_stack.limit
#  endif

#  if USE_RETURN
#   define _c_stack_reset(l)	return (void *)(l)
#  else
#   define _c_stack_reset(l)	jump(l)
#  endif

#  define C_STACK_CHECK(l) {						\
	_C_STACK_POINTER; if ( _C_STACK_OVERFLOW ) _c_stack_reset(l);	\
    }

extern struct _c_stack {
    unsigned int size;
    void	 *limit;
} c_stack;

#  define GOTO(l)		return l()

# else /* C_STACK_SIZE <= 0 */

#  define C_STACK_CHECK(l)
#  define GOTO(l)		return (void *)(l)

# endif /* C_STACK_SIZE <= 0 */

#else /* !USE_TRAMPOLINE */

# undef C_STACK_SIZE
# define C_STACK_SIZE 8192

# if __GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 1
#  define _USED			__attribute__((used))
#  define _USE(l)
# else
#  define _USED
#  define _USE(l)		: : "g" (_FUNC(l))
# endif

# define FUNCTION(f)		void _FUNC(f)(void)
# define DECLARE_LABEL(link, l)			\
    link void _FUNC(l)(void) _USED;		\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define _FUNC(f) f##_func
# define ENTRY_LABEL(link, l)			\
    __asm__(_##link##_LABEL(_ENTRY_LABEL(l))	\
	    _ENTRY_LABEL(l) ":" _USE(l));	\
    __asm__("" : : "g"(&&entry)); entry:
# define _ENTRY_LABEL(l)	#l "_entry"
# define _extern_LABEL(l)	" .globl " l "\n"
# define _static_LABEL(l)
# define C_STACK_CHECK(l)

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* work around an instruction scheduler bug in gcc 2.91 for sparc */
extern Label ip;
#  define _GOTO(l)		ip = (Label)(l); goto *ip
# else
#  define _GOTO(l)		goto *(Label)(l)
# endif
# define GOTO(l) ({			      \
	__label__ _l;			      \
	__asm__("" : : "g"(&&_l) : "memory"); \
	_GOTO(l);			      \
    _l: halt();				      \
    })

#endif /* !USE_TRAMPOLINE */

@ 
The [[run]] function executes the compiled code starting at label
[[ip]]. The execution of compiled code must be terminated by calling
the [[halt]] function. Execution can be continued at an arbitrary
address by calling the [[jump]] function. [[Jump]] is similar to
[[GOTO]], but can be used from foreign C code. On the other hand, it
is implemented less efficiently than [[GOTO]] and therefore should not
be used in compiled code. If the jump address is zero, execution of
compiled code is halted.

<<run.h>>=
extern void run(Label ip);
extern void jump(Label ip) __attribute__((noreturn));
#define halt() jump(0)

@ 
In order to achieve an efficient implementation with the trampoline
model, the trampoline loop does not check the continuation address
returned to it. Therefore, it is impossible to stop execution of
compiled code by returning, e.g., a null pointer to the
trampoline. Instead, we use a [[longjmp]] back into the [[run]]
function in order to stop execution.

The [[run]] function only saves the context for this [[longjmp]] in
the global variable [[jump_buf]] and then calls the private function
[[do_run]], which either executes the trampoline loop or prepares the
stack frame in which the compiled code is executed in the direct jump
configuration.

The [[jump]] function stops execution of compiled abstract machine
code by performing a non-local jump to the context saved in
[[jump_buf]]. If the continuation address is zero, the machine is
halted and [[run]] returns to its caller. Otherwise, [[do_run]] is
entered again with the address passed to [[jump]].

The [[noinline]] attribute of [[do_run]] is important in order to
prevent an overzealous Gnu C compiler from inlining the code of
[[do_run]] in the [[run]] function. This could lead to worse code
because the optimizer may save local variables to the stack rather
than keeping them in processor registers so that their values are not
clobbered by a non-local return to the [[setjmp]] call. Furthermore,
the code, which executes in [[do_run]]'s stack frame in the direct
jump configuration, otherwise might overwrite register values saved in
[[run]]'s stack frame.

If the preprocessor macro [[COUNT_CALLS]] is defined while compiling
the file [[run.c]], the number of tail-calls performed via the
trampoline is computed and shown on standard error when the program
exits.

<<run.c>>=
#include "config.h"
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
# include <stdio.h>
#endif
#include <setjmp.h>
#include "debug.h"
#include "run.h"

static Label   jump_ip;
static jmp_buf jump_buf;

#if __GNUC__ >= 3
# define NOINLINE  noinline,
#else
# define NOINLINE
#endif

static void do_run(Label ip) __attribute__((NOINLINE noreturn));

#if USE_TRAMPOLINE && defined(COUNT_CALLS)
static int	     depth;
static unsigned long n_calls;
#endif

void
run(Label ip)
{
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
    if ( depth++ == 0 )
	n_calls = 0;
#endif
    if ( setjmp(jump_buf) )
	ip = jump_ip;
    if ( ip )
	do_run(ip);
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
    if ( --depth == 0 )
	fprintf(stderr, "[%lu trampoline iterations]\n", n_calls);
#endif
}

void
jump(Label ip)
{
    jump_ip = ip;
    longjmp(jump_buf, 1);
}

@ 
If the runtime system is compiled with the trampoline configuration
and the ``Cheney on the M.T.A'' technique is not used, the [[do_run]]
function is a tight loop that repeatedly calls the function returned
from the previous call. In order to improve efficiency, the loop has
been unrolled 8 times and does not perform null pointer tests. On the
other hand, when the ``Cheney on the M.T.A.'' technique is used and
[[USE_RETURN]] is not defined the code never returns directly to the
trampoline. Thus, [[do_run]] just fires off a call to the label.

<<run.c>>=
#if USE_TRAMPOLINE

# ifdef COUNT_CALLS
#  define COUNT(ip)	(n_calls++, (ip))
# else
#  define COUNT(ip)	(ip)
# endif

# if C_STACK_SIZE > 0
struct _c_stack c_stack = { C_STACK_SIZE, 0 };
# endif

static void
do_run(Label ip)
{
# if C_STACK_SIZE > 0
    _C_STACK_POINTER;
#  if C_STACK_GROWS_UPWARD
    c_stack.limit = (char *)_C_STACK_TOP + c_stack.size;
#  else
    c_stack.limit = (char *)_C_STACK_TOP - c_stack.size;
#  endif
# endif

# if C_STACK_SIZE > 0 && !USE_RETURN
    COUNT(ip());
    curry_panic("internal error: unexpected return from Curry code\n");
# else
    for (;;)
    {
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
    }
# endif
}
#endif /* USE_TRAMPOLINE */

@
If the runtime system uses direct jumps via Gnu C extensions, the
[[do_run]] function allocates a stack frame which should be large
enough to handle the allocation requirements of all functions in the
program and then jumps to the entry point of the program. The compiled
functions must never return, but call the [[jump]] function in order
to terminate execution.

The [[do_run]] function performs a seemingly redundant call of the
[[trace]] function. This call is necessary so that [[do_run]] is not
compiled as a leaf procedure and therefore a proper stack frame is set
up for it on all architectures. Any other function, which effectively
performs no operation but cannot be inlined by the compiler, would do
as well.

<<run.c>>=
#if !USE_TRAMPOLINE
#include "trace.h"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* needed to work around an instruction scheduler bug in gcc 2.91 for sparc */
Label ip;
# endif

static void
do_run(Label ip)
{
    char dummy[C_STACK_SIZE];

    /* hack to avoid unused variable warning */
    __asm__("" : : "g"(dummy));

    /* DO NOT REMOVE THIS CALL! */
    trace("");

    goto *ip;
}
#endif /* !USE_TRAMPOLINE */
