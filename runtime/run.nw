% -*- noweb-code-mode: c-mode -*-
% $Id: run.nw 2273 2007-06-16 16:33:22Z wlux $
%
% Copyright (c) 2001-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Execution}\label{sec:execution}
While C can be used conveniently as a ``high-level'' assembly
language, there is one gap which complicates the efficient
implementation of declarative languages, viz. the lack of a general
tail-call in the language.\footnote{The Gnu C compiler optimizes
tail-calls into jumps to the beginning of the function. However,
this works only for calls to the same function.}

There are various possible strategies known to handle this
problem. The most simple solution is to provide a trampoline loop. If
a function wants to perform a tail call, it simply returns the address
of the callee to the trampoline, which then in turn calls this
function. This strategy is portable but inefficient because of its
additional overhead.

A more efficient solution is possible for the Gnu C compiler. With the
help of assembler labels inserted into the code and using computed
\texttt{goto}s, a tail call is performed by jumping directly to these
labels. Implemented this way, the standard function prologue, which
sets up the local stack frame of the callee, is skipped over and no
additional stack space is allocated. The stack space is allocated in
the driver function, which now only has to jump to the first code
address. This strategy will fail if the function prologue has to do
more work than just setting up a stack frame; it can therefore be
turned off by defining the pre-processor macro [[USE_TRAMPOLINE]].

The type of a code label which can be used in a tail call is either
a function which returns a [[void]] pointer\footnote{In fact, the
function returns another function with the same type. However, such a
recursive type cannot be declared in C.} or is itself a [[void]]
pointer in order to be used in (computed) \texttt{goto} statements.

<<run.h>>=
#if !USE_TRAMPOLINE
# ifndef __GNUC__
#  error "direct jumps require Gnu C; reconfigure with --enable-trampoline"
# endif
#endif

#if USE_TRAMPOLINE
typedef void *(*Label)(void);
#else
typedef void *Label;
#endif

@ 
Every code block of the abstract machine code is translated into a C
function on its own. In case of the trampoline execution model, these
functions simply return to their caller (the trampoline) when they
want to perform a jump to another code block via the [[GOTO]] macro.

In case of the direct jump model, which was derived from the
implementation of the Mercury runtime
system~\cite{HendersonConwaySomogyi95:Portable}, we use Gnu C's
ability to handle labels as values. With the extended assembler
feature of Gnu C, a label is inserted immediately after the function's
prologue with the [[ENTRY_LABEL]] macro. The code generated by the
[[GOTO]] macro then jumps directly to that label. By renaming the
function itself in the [[DECLARE_LABEL]] and [[FUNCTION]] macros and
adding a function declaration in [[DECLARE_LABEL]], which associates
the function name with its entry point, we can simply use the function
name in both models to refer to the entry point of a function. The
first argument of the macros [[DECLARE_LABEL]] and [[ENTRY_LABEL]]
specifies whether the label has internal or external linkage using the
C language keywords [[static]] and [[extern]], respectively.

Getting the direct jump model to work is a little bit tricky. At least
on the Intel x86 architecture, some versions of Gnu C may not pop the
arguments of the last call before a computed [[goto]] statement if no
label is declared in the function. Furthermore, if only one label is
declared in a function, computed [[goto]]s in that function are
``optimized'' into jumps to that label. This means that at least two
labels must be declared in a function in order to generate correct
code for the direct jump model. The macros below therefore insert one
label immediately after the entry point label and additional labels
after each computed [[goto]] statement. In order to prevent Gnu C from
assuming that the code can fall through a [[GOTO]] macro, those labels
are followed immediately by a call to the [[halt]] function.

The assembler statement within the [[GOTO]] macro serves two purposes.
It marks the local label used and it ensures that the compiler will
not cache any global variables over the [[goto]] statement with the
help of a [[memory]] clobber description. Unfortunately, this may also
cause some redundant register reloads when the argument of the
[[GOTO]] macro is an expression that computes the jump
target.\footnote{Many versions of Gnu C generate correct code without
the clobber description, but at least for Gnu C version 3.2 on x86
targets it is necessary.}

<<run.h>>=
#if USE_TRAMPOLINE

# define FUNCTION(f)		void *f(void)
# define DECLARE_LABEL(link, l) link void *l(void)
# define ENTRY_LABEL(link, l)

# define GOTO(l)		return (void *)(l)

#else /* !USE_TRAMPOLINE */

# define C_STACK_SIZE 8192

# if __GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 1
#  define _USED			__attribute__((used))
#  define _USE(l)
# else
#  define _USED
#  define _USE(l)		: : "g" (_FUNC(l))
# endif

# define FUNCTION(f)		void _FUNC(f)(void)
# define DECLARE_LABEL(link, l)			\
    link void _FUNC(l)(void) _USED;		\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define _FUNC(f) f##_func
# define ENTRY_LABEL(link, l)			\
    __asm__(_##link##_LABEL(_ENTRY_LABEL(l))	\
	    _ENTRY_LABEL(l) ":" _USE(l));	\
    __asm__("" : : "g"(&&entry)); entry:
# define _ENTRY_LABEL(l)	#l "_entry"
# define _extern_LABEL(l)	" .globl " l "\n"
# define _static_LABEL(l)

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* work around an instruction scheduler bug in gcc 2.91 for sparc */
extern Label ip;
#  define _GOTO(l)		ip = (Label)(l); goto *ip
# else
#  define _GOTO(l)		goto *(Label)(l)
# endif
# define GOTO(l) ({			      \
	__label__ _l;			      \
	__asm__("" : : "g"(&&_l) : "memory"); \
	_GOTO(l);			      \
    _l: halt();				      \
    })

#endif /* !USE_TRAMPOLINE */

@ 
The [[run]] function executes the compiled code starting at label
[[ip]]. The execution of compiled code must be terminated by calling
the [[halt]] function. Execution can be continued at an arbitrary
address by calling the [[jump]] function. [[Jump]] is similar to
[[GOTO]], but can be used from foreign C code. On the other hand, it
is implemented less efficiently than [[GOTO]] and therefore should not
be used in compiled code. If the jump address is zero, execution of
compiled code is halted.

<<run.h>>=
extern void run(Label ip);
extern void jump(Label ip) __attribute__((noreturn));
#define halt() jump(0)

@ 
In order to achieve an efficient implementation with the trampoline
model, the trampoline loop does not check the continuation address
returned to it. Therefore, it is impossible to stop execution of
compiled code by returning, e.g., a null pointer to the
trampoline. Instead, we use a [[longjmp]] back into the [[run]]
function in order to stop execution.

The [[run]] function only saves the context for this [[longjmp]] in
the global variable [[jump_buf]] and then calls the private function
[[do_run]], which either executes the trampoline loop or prepares the
stack frame in which the compiled code is executed in the direct jump
configuration.

The [[jump]] function stops execution of compiled abstract machine
code by performing a non-local jump to the context saved in
[[jump_buf]]. If the continuation address is zero, the machine is
halted and [[run]] returns to its caller. Otherwise, [[do_run]] is
entered again with the address passed to [[jump]].

The [[noinline]] attribute of [[do_run]] is important in order to
prevent an overzealous Gnu C compiler from inlining the code of
[[do_run]] in the [[run]] function. This could lead to worse code
because the optimizer may save local variables to the stack rather
than keeping them in processor registers so that their values are not
clobbered by a non-local return to the [[setjmp]] call. Furthermore,
the code, which executes in [[do_run]]'s stack frame in the direct
jump configuration, otherwise might overwrite register values saved in
[[run]]'s stack frame.

<<run.c>>=
#include "config.h"
#include <setjmp.h>
#include "run.h"

static Label   jump_ip;
static jmp_buf jump_buf;

#if __GNUC__ >= 3
# define NOINLINE  noinline,
#else
# define NOINLINE
#endif

static void do_run(Label ip) __attribute__((NOINLINE noreturn));

void
run(Label ip)
{
    if ( setjmp(jump_buf) )
	ip = jump_ip;
    if ( ip )
	do_run(ip);
}

void
jump(Label ip)
{
    jump_ip = ip;
    longjmp(jump_buf, 1);
}

@ 
If the runtime system is compiled with the trampoline configuration,
the [[do_run]] function is a tight loop that repeatedly calls the
function returned from the previous call. In order to improve
efficiency, the loop has been unrolled 8 times and does not perform
null pointer tests.

<<run.c>>=
#if USE_TRAMPOLINE
static void
do_run(Label ip)
{
    for (;;)
    {
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
	ip = (Label)ip();
    }
}
#endif /* USE_TRAMPOLINE */

@
If the runtime system uses direct jumps via Gnu C extensions, the
[[do_run]] function allocates a stack frame which should be large
enough to handle the allocation requirements of all functions in the
program and then jumps to the entry point of the program. The compiled
functions must never return, but call the [[jump]] function in order
to terminate execution.

The [[do_run]] function performs a seemingly redundant call of the
[[trace]] function. This call is necessary so that [[do_run]] is not
compiled as a leaf procedure and therefore a proper stack frame is set
up for it on all architectures. Any other function, which effectively
performs no operation but cannot be inlined by the compiler, would do
as well.

<<run.c>>=
#if !USE_TRAMPOLINE
#include "trace.h"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* needed to work around an instruction scheduler bug in gcc 2.91 for sparc */
Label ip;
# endif

static void
do_run(Label ip)
{
    char dummy[C_STACK_SIZE];

    /* hack to avoid unused variable warning */
    __asm__("" : : "g"(dummy));

    /* DO NOT REMOVE THIS CALL! */
    trace("");

    goto *ip;
}
#endif /* !USE_TRAMPOLINE */
