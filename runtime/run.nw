% -*- noweb-code-mode: c-mode -*-
% $Id: run.nw 2346 2007-06-23 10:23:59Z wlux $
%
% Copyright (c) 2001-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Execution}\label{sec:execution}
While C can be used conveniently as a ``high-level'' assembly
language, the lack of general tail-calls in the language\footnote{The
  Gnu C compiler optimizes tail-calls into jumps to the beginning of
  the function. However, this works only for calls to the same
  function.} complicates the efficient implementation of declarative
languages. The common workaround is to use a trampoline loop. In order
to perform a tail call, a function simply returns the address of the
callee to the trampoline, which then calls that function. This
strategy is portable but inefficient because of the overhead
introduced by returning to the trampoline. Furthermore, the indirect
call sequence prevents intra-procedural optimizations by the C
compiler and may also interfere with the processor's code prefetching.

As a remedy, Baker~\cite{Baker95:CheneyMTA} has proposed to jump back
to the trampoline only when the C runtime stack has been filled up,
which can be detected either by an explicit address comparison or by
using a protected virtual memory page at the high end of the stack. A
variant of this technique was proposed for
Java~\cite{SchinzOdersky01:TailCall}, which does not provide direct
access to its stack. A tail call counter is used and the code returns
to the trampoline after performing a fixed number of tail calls. Yet,
experiments with our compiler show that these techniques do not always
improve performance because naively growing the stack may invalidate
the processor's cache lines to often. In addition, it is particularly
expensive for architectures like SPARC, which are based on register
windows.

Therefore, we use our own variant of the trampoline technique. The
decision whether to perform a tail call as a direct call or an
indirect call through the trampoline is purely syntactic, which means
that there is no runtime overhead (no need to compare addresses or
maintain an explicit counter), nor are there any portability issues
(for handling traps after touching a protected memory page at the
top of the stack).  Essentially, we use indirect calls when returning
to the caller and switching contexts, respectively, and direct calls
otherwise. The main exception are tail calls in leaf procedures, which
are always performed as indirect calls in order to ensure that every
Curry function returns to the trampoline at least once.

A more efficient solution is possible for the Gnu C compiler. With the
help of assembler labels inserted into the code and using computed
\texttt{goto}s, a tail call is performed by jumping directly to these
labels. Implemented this way, the standard function prologue, which
sets up the local stack frame of the callee, is skipped over and no
additional stack space is allocated. The stack space is allocated in
the driver function, which now only has to jump to the first code
address. This strategy will fail if the function prologue has to do
more work than just setting up a stack frame, which, for instance, is
the case on many architectures when generating position independent
code. Therefore, it can be turned off by defining the preprocessor
macro [[USE_TRAMPOLINE]].

The type of a code label which can be used in a tail call is either
a function which returns a [[void]] pointer\footnote{In fact, the
function returns another function with the same type. However, such
recursive types cannot be declared in C.} or is itself a [[void]]
pointer in order to be used in (computed) \texttt{goto} statements.

<<run.h>>=
#if !USE_TRAMPOLINE
# ifndef __GNUC__
#  error "direct jumps require Gnu C; reconfigure with --enable-trampoline"
# endif
#endif

#if USE_TRAMPOLINE
typedef void *(*Label)(void);
#else
typedef void *Label;
#endif

@ 
Every code block of the abstract machine code is translated into a C
function on its own. In case of the trampoline execution model, these
functions can either invoke the callee directly via the [[GOTO]] macro
or return the callee's address to the trampoline with the
[[GOTO_INDIR]] macro. See the introduction of this section on when to
use direct and indirect calls, respectively. %'

In case of the direct jump model, which was derived from the
implementation of the Mercury runtime
system~\cite{HendersonConwaySomogyi95:Portable}, we use Gnu C's
ability to handle labels as values. With the extended assembler
feature of Gnu C, a label is inserted immediately after the function's
prologue with the [[ENTRY_LABEL]] macro. The code generated by the
[[GOTO]] and [[GOTO_INDIR]] macros then jumps directly to that label.
By renaming the function itself in the [[DECLARE_LABEL]] and
[[FUNCTION]] macros and adding a function declaration in
[[DECLARE_LABEL]], which associates the function name with its entry
point, we can simply use the function name in both models to refer to
the entry point of a function. The first argument of the macros
[[DECLARE_LABEL]] and [[ENTRY_LABEL]] specifies whether the label has
internal or external linkage using the C language keywords [[static]]
and [[extern]], respectively.

Getting the direct jump model to work is a little bit tricky. At least
on the Intel x86 architecture, some versions of Gnu C may not pop the
arguments of the last call before a computed [[goto]] statement if no
label is declared in the function. Furthermore, if only one label is
declared in a function, computed [[goto]]s in that function are
``optimized'' into jumps to that label. This means that at least two
labels must be declared in a function in order to generate correct
code for the direct jump model. The macros below therefore insert one
label immediately after the entry point label and additional labels
after each computed [[goto]] statement. In order to prevent Gnu C from
assuming that the code can fall through a [[GOTO]] macro, those labels
are followed immediately by a call to the [[halt]] function.

The assembler statement within the [[GOTO]] macro serves two purposes.
It marks the local label used and it ensures that the compiler will
not cache any global variables over the [[goto]] statement with the
help of a [[memory]] clobber description. Unfortunately, this may also
cause some redundant register reloads when the argument of the
[[GOTO]] macro is an expression that computes the jump
target.\footnote{Many versions of Gnu C generate correct code without
the clobber description, but at least for Gnu C version 3.2 on x86
targets it is necessary.}

In order to measure the effect of our improved trampoline
implementation, the runtime system can be configured to perform
\emph{every} tail call through the trampoline by defining the
preprocessor macro [[USE_STANDARD_TRAMPOLINE]], which is set to a
non-zero value when the compiler is configured with
\texttt{--enable-trampoline=slow}.

<<run.h>>=
#if USE_TRAMPOLINE

# define FUNCTION(f)		void *f(void)
# define DECLARE_LABEL(link, l) link void *l(void)
# define ENTRY_LABEL(link, l)

# if USE_STANDARD_TRAMPOLINE
#  define GOTO(l)		GOTO_INDIR(l)
# else
#  define GOTO(l)		return l()
# endif
# define GOTO_INDIR(l)		return (void *)(l)

#else /* !USE_TRAMPOLINE */

# define C_STACK_SIZE 8192

# if __GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 1
#  define _USED			__attribute__((used))
#  define _USE(l)
# else
#  define _USED
#  define _USE(l)		: : "g" (_FUNC(l))
# endif

# define FUNCTION(f)		void _FUNC(f)(void)
# define DECLARE_LABEL(link, l)			\
    link void _FUNC(l)(void) _USED;		\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define _FUNC(f) f##_func
# define ENTRY_LABEL(link, l)			\
    __asm__(_##link##_LABEL(_ENTRY_LABEL(l))	\
	    _ENTRY_LABEL(l) ":" _USE(l));	\
    __asm__("" : : "g"(&&entry)); entry:
# define _ENTRY_LABEL(l)	#l "_entry"
# define _extern_LABEL(l)	" .globl " l "\n"
# define _static_LABEL(l)

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* work around an instruction scheduler bug in gcc 2.91 for sparc */
extern Label ip;
#  define _GOTO(l)		ip = (Label)(l); goto *ip
# else
#  define _GOTO(l)		goto *(Label)(l)
# endif
# define GOTO(l) ({			      \
	__label__ _l;			      \
	__asm__("" : : "g"(&&_l) : "memory"); \
	_GOTO(l);			      \
    _l: halt();				      \
    })
# define GOTO_INDIR(l)		GOTO(l)

#endif /* !USE_TRAMPOLINE */

@ 
The [[run]] function executes the compiled code starting at label
[[ip]]. The execution of compiled code must be terminated by calling
the [[halt]] function. Execution can be continued at an arbitrary
address by calling the [[jump]] function. [[Jump]] is similar to
[[GOTO]], but can be used from foreign C code. On the other hand, it
is implemented less efficiently than [[GOTO]] and therefore should not
be used in compiled code. If the jump address is zero, execution of
compiled code is halted.

<<run.h>>=
extern void run(Label ip);
extern void jump(Label ip) __attribute__((noreturn));
#define halt() jump(0)

@ 
In order to achieve an efficient implementation with the trampoline
model, the trampoline loop does not check the continuation address
returned to it. Therefore, it is impossible to stop execution of
compiled code by returning, e.g., a null pointer to the
trampoline. Instead, we use a [[longjmp]] back into the [[run]]
function in order to stop execution.

The [[run]] function only saves the context for this [[longjmp]] in
the global variable [[jump_buf]] and then calls the private function
[[do_run]], which either executes the trampoline loop or prepares the
stack frame in which the compiled code is executed in the direct jump
configuration.

The [[jump]] function stops execution of compiled abstract machine
code by performing a non-local jump to the context saved in
[[jump_buf]]. If the continuation address is zero, the machine is
halted and [[run]] returns to its caller. Otherwise, [[do_run]] is
entered again with the address passed to [[jump]].

The [[noinline]] attribute of [[do_run]] is important in order to
prevent an overzealous Gnu C compiler from inlining the code of
[[do_run]] in the [[run]] function. This could lead to worse code
because the optimizer may save local variables to the stack rather
than keeping them in processor registers so that their values are not
clobbered by a non-local return to the [[setjmp]] call. Furthermore,
the code, which executes in [[do_run]]'s stack frame in the direct
jump configuration, otherwise might overwrite register values saved in
[[run]]'s stack frame.

If the preprocessor macro [[COUNT_CALLS]] is defined while compiling
the file [[run.c]], the number of tail calls performed via the
trampoline is computed and shown on standard error when the program
exits.

<<run.c>>=
#include "config.h"
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
# include <stdio.h>
#endif
#include <setjmp.h>
#include "run.h"

static Label   jump_ip;
static jmp_buf jump_buf;

#if __GNUC__ >= 3
# define NOINLINE  noinline,
#else
# define NOINLINE
#endif

static void do_run(Label ip) __attribute__((NOINLINE noreturn));

#if USE_TRAMPOLINE && defined(COUNT_CALLS)
static int	     depth;
static unsigned long n_calls;
#endif

void
run(Label ip)
{
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
    if ( depth++ == 0 )
	n_calls = 0;
#endif
    if ( setjmp(jump_buf) )
	ip = jump_ip;
    if ( ip )
	do_run(ip);
#if USE_TRAMPOLINE && defined(COUNT_CALLS)
    if ( --depth == 0 )
	fprintf(stderr, "[%lu trampoline iterations]\n", n_calls);
#endif
}

void
jump(Label ip)
{
    jump_ip = ip;
    longjmp(jump_buf, 1);
}

@ 
If the runtime system is compiled with the trampoline configuration,
the [[do_run]] function is a tight loop that repeatedly calls the
function returned from the previous call. In order to improve
efficiency, the loop has been unrolled 8 times and does not perform
null pointer tests.

<<run.c>>=
#if USE_TRAMPOLINE

# ifdef COUNT_CALLS
#  define COUNT(ip)	(n_calls++, (ip))
# else
#  define COUNT(ip)	(ip)
# endif

static void
do_run(Label ip)
{
    for (;;)
    {
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
	ip = COUNT((Label)ip());
    }
}
#endif /* USE_TRAMPOLINE */

@
If the runtime system uses direct jumps via Gnu C extensions, the
[[do_run]] function allocates a stack frame which should be large
enough to handle the allocation requirements of all functions in the
program and then jumps to the entry point of the program. The compiled
functions must never return, but call the [[jump]] function in order
to terminate execution.

The [[do_run]] function performs a seemingly redundant call of the
[[trace]] function. This call is necessary so that [[do_run]] is not
compiled as a leaf procedure and therefore a proper stack frame is set
up for it on all architectures. Any other function, which effectively
performs no operation but cannot be inlined by the compiler, would do
as well.

<<run.c>>=
#if !USE_TRAMPOLINE
#include "trace.h"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* needed to work around an instruction scheduler bug in gcc 2.91 for sparc */
Label ip;
# endif

static void
do_run(Label ip)
{
    char dummy[C_STACK_SIZE];

    /* hack to avoid unused variable warning */
    __asm__("" : : "g"(dummy));

    /* DO NOT REMOVE THIS CALL! */
    trace("");

    goto *ip;
}
#endif /* !USE_TRAMPOLINE */
