% -*- noweb-code-mode: c-mode -*-
% $Id: search.nw 2669 2008-04-21 06:52:23Z wlux $
%
% Copyright (c) 2002-2008, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Encapsulated Search}
The implementation of encapsulated search is mostly private to this
module. The external entry points into this module are the external
function [[try]], which starts a new encapsulated search, and the
function [[suspend_search]], which allows the program to temporarily
suspend an encapsulated search.

<<search.h>>=
extern void suspend_search(unsigned int, SearchSpace *);

@ 
<<search.c>>=
#include "curry.h"
#include "search.h"
#include "vars.h"
#include "stats.h"

static void push_search_context(void);
static void pop_search_context(void);

DECLARE_LABEL(static, apply_clos_1_2);
DECLARE_LABEL(static, solved_goal);
DECLARE_LABEL(static, search_goal_success);
DECLARE_LABEL(static, search_cont);
DECLARE_LABEL(static, search_goal_proceed);
DECLARE_LABEL(static, resume_search);
DECLARE_LABEL(static, choices_search);
DECLARE_LABEL(static, deadlock_search);
DECLARE_LABEL(static, fail_search);

static const struct nondet_handlers search_handlers = {
    choices_search, deadlock_search, fail_search
};

static
FUNCTION(apply_clos_1_2)
{
    Node *clos;
 ENTRY_LABEL(static, apply_clos_1_2)
    clos = regs.r[0];
    CALL_RET2(clos->info->entry, 1, clos->c.args[0], regs.sp[0]);
}

static NodeInfo solved_goal_papp_info_table[] = {
    PAPPINFO("<solved goal>", 1, solved_goal, 2)
};
static NodeInfo search_cont_papp_info_table[] = {
    PAPPINFO("<search goal>", 1, search_cont, 2)
};

@
Search contexts are allocated on the stack in order to save the
machine state before an encapsulated search starts and to restore the
machine state when the encapsulated search is left again.

<<search.c>>=
static inline void
push_search_context()
{
    push_choice_point(0);
    regs.handlers = &search_handlers;
}

static inline void
pop_search_context()
{
    assert(is_search_context(regs.bp));
    leave_context();
    pop_choice_point();
}

@ 
The [[try]] function starts an encapsulated search. After pushing a
new search context onto the stack and creating a new search space,
[[try]] starts the evaluation of the search goal by applying it to a
fresh variable. In addition, a queue-me node is created that allows
checking for successful termination of the goal's evaluation. %'

When [[try]] is applied to an already solved search goal (as returned
from a previous encapsulated search), this search goal is returned
immediately. In addition, when [[try]] is applied to a partially
solved search goal, the goal variable and queue-me node of that goal
are shared instead of allocating fresh nodes.

<<search.c>>=
DECLARE_LABEL(extern, __try);
DECLARE_LABEL(static, __try_1);

FUNCTION(__try)
{
 ENTRY_LABEL(extern, __try)
    SAVE_REGS(0);
    EVAL_INDIR_NODE(__try_1);
}

static
FUNCTION(__try_1)
{
    Node *susp, *list, *sc, *var;
 ENTRY_LABEL(static, __try_1)
    MATCH_RIGID_PAPP(__try_1);
    assert(regs.r[0]->info->tag == 1);

    /* return immediately when applied to a solved search goal */
    if ( regs.r[0]->info == solved_goal_papp_info_table )
    {
	CHECK_HEAP(1, cons_node_size);
	list		= (Node *)regs.hp;
	list->info	= &cons_info;
	list->c.args[0] = regs.r[0];
	list->c.args[1] = nil;
	regs.hp	       += cons_node_size;
	RETURN(list, 0);
    }

    /* create a new search context */
    TRACE(("starting encapsulated search\n"));
    push_search_context();
#if COPY_SEARCH_SPACE
    new_search_space(1);
#endif

    /* when applied to a partially solved goal continue its evaluation */
    if ( regs.r[0]->info == search_cont_papp_info_table )
    {
	sc = regs.r[0]->c.args[0];
#if COPY_SEARCH_SPACE
	sc = copy_graph(0, sc, sc->sc.ss);
#endif

	CHECK_STACK(2);
	regs.sp   -= 2;
	regs.sp[0] = sc->sc.susp;
	regs.sp[1] = sc->sc.var;
#if !COPY_SEARCH_SPACE
	restore_search_space(sc->sc.ss);
#endif
	GOTO_INDIR(resume_continuation(sc->sc.code, sc->sc.rq));
    }

#if !COPY_SEARCH_SPACE
    /* create a new search space */
    new_search_space(1);
#endif

    /* allocate new goal variable and suspension */
    CHECK_HEAP(1, variable_node_size + queueMe_node_size);
    var		 = (Node *)regs.hp;
    var->info	 = variable_info_table;
    var->v.spc	 = regs.ss;
    var->v.wq	 = 0;
    var->v.cstrs = 0;
    regs.hp	+= variable_node_size;

    susp	= (Node *)regs.hp;
    susp->info	= queueMe_info_table;
    susp->q.spc	= regs.ss;
    susp->q.wq	= 0;
    regs.hp    += queueMe_node_size;

    /* start the initial thread and evaluate the goal */
    CHECK_STACK(2);
    regs.sp   -= 2;
    regs.sp[0] = regs.r[2] = susp;
    regs.sp[1] = regs.r[1] = var;
    start_thread(3, 0);
    SAVE_RET3(regs.r[1], (Node *)update, regs.r[2]);
    GOTO(regs.r[0]->info->apply);
}

@ 
A solved search goal is represented by a (partial) application of
function [[solved_goal]] to a search continuation saving the state of
the solved goal. When such a closure is applied to an argument, this
argument is unified with a copy of the goal's solution. Copying %'
ensures that multiple applications of a (partially) solved search goal
to different arguments succeed, if the (partial) solution contains
free variables. For instance, the expression
\begin{verbatim}
  let [g] = try (\x -> success) in g 0 & g 1
\end{verbatim}
succeeds because \verb|try (\x -> success)| is equivalent to
\verb|[\x -> success]|.

<<search.c>>=
static
FUNCTION(solved_goal)
{
    Node  *cont, *res, *arg;
 ENTRY_LABEL(static, solved_goal)
    cont = regs.r[0];
    res	 = copy_graph(2, cont->sc.var, cont->sc.ss);

    arg = regs.r[1];
    while ( is_tagged_ptr(arg) && is_indir_node(arg) )
	arg = arg->n.node;
    if ( is_tagged_ptr(arg) && is_variable_node(arg) &&
	 is_local_space(arg->v.spc) )
    {
	SAVE_REGS(0);
	CALL2(bind_var, search_goal_success, arg, res);
    }
    EXEC2(___61__58__61_, arg, res);
}

static
FUNCTION(search_goal_success)
{
 ENTRY_LABEL(static, search_goal_success)
    RETURN(Success, 0);
}

@ 
A partially solved search goal is returned from an encapsulated search
when a non-deterministic computation step has to be performed. In that
case, the current state of the computation is saved in a list of
search continuation nodes. For each alternative continuation, a
(partial) application of function [[search_cont]] to the corresponding
search continuation node is created. When one of these closures is
applied to an argument, the saved state is restored and a unification
between the argument and the partial solution computed so far for the
search goal is performed. The unification is started before resuming
the evaluation of the search goal in order to allow an effective
implementation of pruning search strategies. Note that [[try]]
implicitly performs this unification when it is applied to a partially
solved search goal by sharing the goal variable.

When a search goal is resumed in another (encapsulated or global)
search, its saved state in general must be copied into the current
space. If, however, the current search space is a root space, i.e., if
no non-deterministic choice was performed for the current goal, the
current space is adopted as a child of the resumed goal's search space.
This avoids -- possibly expensive -- copying for the common case where
a pruning search strategy sets up additional constraints on the goal
variable before resuming a search goal, e.g.,
\verb|try (\z -> (z<x)=:=True & g z)|, where \verb|g| is a search
continuation and \verb|x| an upper limit for the goal variable. In the
unusual case where a search goal is continued in the enclosing
computation, the saved state is always copied, even if the enclosing
computation's search space is a root space.

Note that [[search_goal_proceed]] discards the value on the top of the
stack and therefore it does not matter that [[bind_var]] returns the
argument to which [[search_cont]] was applied, whereas the equality
constraint returns the constant [[Success]].

<<search.c>>=
static
FUNCTION(search_cont)
{
    Node *arg, *cont;
 ENTRY_LABEL(static, search_cont)
    cont = regs.r[0];
    if ( is_local_space(cont->sc.spc) || !inject_search_space(cont->sc.ss) )
	regs.r[0] = cont = copy_graph(2, cont, cont->sc.ss);
    restore_continuation(2, cont->sc.code, cont->sc.rq);

    /* NB reload cont -- restore_continuation might invoke gc */
    cont = regs.r[0];
    arg  = regs.r[1];
    while ( is_tagged_ptr(arg) && is_indir_node(arg) )
	arg = arg->n.node;

    SAVE_RET1(cont->sc.susp);
    if ( is_tagged_ptr(arg) && is_variable_node(arg) &&
	 is_local_space(arg->v.spc) )
	CALL2(bind_var, search_goal_proceed, arg, cont->sc.var);
    CALL2(___61__58__61_, search_goal_proceed, arg, cont->sc.var);
}

static
FUNCTION(search_goal_proceed)
{
    Node *susp;
 ENTRY_LABEL(static, search_goal_proceed)
    susp = regs.sp[0];
    ASSERT(is_tagged_ptr(susp));
    ENTER(susp, 1);
}

@ 
When no thread can be run in an encapsulated search, the evaluation of
the search goal either did succeed or a deadlock has occurred. Both
cases can be distinguished by examining the queue-me node allocated by
[[try]] for that purpose. If the search was successful, the queue-me
node has been overwritten with (an indirection to) [[Success]]. Thus,
if this node is not bound to [[Success]], the evaluation has stopped
due to a deadlock. In that case, the calling thread cannot be
continued, too, and is terminated instantly.

\ToDo{Instead of waiting for the deadlock to propagate up to the
  global context, report an error when a deadlock occurs.}

<<search.c>>=
static
FUNCTION(deadlock_search)
{
    Node *goal, *sc, *clos, *list;
 ENTRY_LABEL(static, deadlock_search)
    /* check for successful computation or deadlock */
    assert(regs.sp == (Node **)regs.bp - 2);
    for ( goal = regs.sp[0]; ; )
    {
	switch ( goal->info->kind )
	{
	case CAPP_KIND:
	    break;
	case LAZY_KIND:
	    assert(goal->info->tag == QUEUEME_TAG);
	    /* FALL THROUGH!!! */
	case LVAR_KIND:
	    TRACE(("deadlock in encapsulated search\n"));
	    discard_search_space();
	    pop_search_context();
	    GOTO(stop_thread);
	case INDIR_KIND:
	    goal = goal->n.node;
	    continue;
	default:
	    invalid_arg("deadlock_search", goal->info->kind);
	}
	break;
    }
    TRACE(("leaving encapsulated search with solved search goal\n"));

    /* dereference the goal variable in order to avoid some garbage */
    while ( is_tagged_ptr(regs.sp[1]) && is_indir_node(regs.sp[1]) )
	regs.sp[1] = regs.sp[1]->n.node;

    /* save the local space */
    save_search_space(0);

    /* allocate the singleton list for the search continuation */
    CHECK_HEAP(0, search_cont_node_size + closure_node_size(1) + cons_node_size);
    sc		= (Node *)regs.hp;
    sc->info	= &search_cont_info;
    sc->sc.spc	= regs.bp->btSpc;
    sc->sc.susp	= 0;
    sc->sc.var	= regs.sp[1];
    sc->sc.code	= 0;
    sc->sc.rq	= 0;
    sc->sc.ss	= regs.ss;
    regs.hp    += search_cont_node_size;

    clos	    = (Node *)regs.hp;
    clos->info	    = solved_goal_papp_info_table;
    clos->c.args[0] = sc;
    regs.hp	   += closure_node_size(1);

    list	    = (Node *)regs.hp;
    list->info	    = &cons_info;
    list->c.args[0] = clos;
    list->c.args[1] = nil;
    regs.hp	   += cons_node_size;

    /* return the list */
    pop_search_context();
    RETURN(list, 0);
}

@ 
The function [[suspend_search]] suspends the current search and
eventually enclosing searches in order to make [[space]] a local space.
This is intended to allow evaluation of a non-local lazy application
within an encapsulated search and in order to suspend a search until a
non-local variable is instantiated. The return stack set up by
[[suspend_search]] ensures that the suspended search is resumed at the
current return address.

<<search.c>>=
void
suspend_search(unsigned int n_regs, SearchSpace *space)
{
    Node *sc;

    BEGIN_LOCAL_ROOTS1(space)
    while ( !is_local_space(space) )
    {
	TRACE(("suspending encapsulated search\n"));
	if ( regs.bp == 0 || !is_search_context(regs.bp) )
	    curry_panic("local variable escaped its search space\n");

	/* save the current state */
	save_continuation(n_regs);

	/* dereference the goal nodes in order to avoid some garbage */
	assert(regs.sp == (Node **)regs.bp - 2);
	while ( is_tagged_ptr(regs.sp[0]) && is_indir_node(regs.sp[0]) )
	    regs.sp[0] = regs.sp[0]->n.node;
	while ( is_tagged_ptr(regs.sp[1]) && is_indir_node(regs.sp[1]) )
	    regs.sp[1] = regs.sp[1]->n.node;

	/* save the local space */
	save_search_space(n_regs);

	/* allocate a search continuation */
	CHECK_HEAP(n_regs, search_cont_node_size);
	sc	    = (Node *)regs.hp;
	sc->info    = &search_cont_info;
	sc->sc.spc  = regs.bp->btSpc;
	sc->sc.susp = regs.sp[0];
	sc->sc.var  = regs.sp[1];
	sc->sc.code = regs.ret;
	sc->sc.rq   = regs.rq;
	sc->sc.ss   = regs.ss;
	regs.hp	   += search_cont_node_size;

	/* save the search continuation and set up a return frame that
	 * restores the suspended search */
	pop_search_context();
	CHECK_STACK1();
	regs.ret   = resume_search;
	regs.sp   -= 1;
	regs.sp[0] = sc;
    }
    END_LOCAL_ROOTS
}

@ 
An encapsulated search whose state was saved by [[suspend_search]] is
resumed by [[resume_search]]. This function restores the state of the
encapsulated search using the search continuation node found at the
top of the stack. Note that since the argument registers are not
changed, their contents can be used in the resumed thread.

<<search.c>>=
static
FUNCTION(resume_search)
{
    Node *sc;
 ENTRY_LABEL(static, resume_search)
    sc = *regs.sp++;
    assert(is_tagged_ptr(sc) && is_search_cont_node(sc));

    TRACE(("resuming encapsulated search\n"));
    push_search_context();

    CHECK_STACK(2);
    regs.sp   -= 2;
    regs.sp[0] = sc->sc.susp;
    regs.sp[1] = sc->sc.var;
    restore_search_space(sc->sc.ss);
    GOTO_INDIR(resume_continuation(sc->sc.code, sc->sc.rq));
}

@ 
If a non-deterministic computation step must be performed in a local
search space, the runtime system creates a search continuation node
for each alternative in the continuation array on the top of the
stack and returns those nodes as a list to the enclosing context.

<<search.c>>=
static
FUNCTION(choices_search)
{
    unsigned int n_conts;
    Node	 *list, *cons, *clos, *sc;
    const Label	 *conts;
 ENTRY_LABEL(static, choices_search)
    assert(regs.bp && is_search_context(regs.bp));

    /* compute the number of alternative solutions */
    n_conts = 0;
    for ( conts = (const Label *)*regs.sp++; *conts; conts++ )
	n_conts++;
    assert(n_conts > 1);
    TRACE(("leaving encapsulated search with %u continuations\n", n_conts));

    /* save the current state */
    save_continuation(0);

    /* dereference the goal nodes in order to avoid some garbage */
    assert(regs.sp == (Node **)regs.bp - 2);
    while ( is_tagged_ptr(regs.sp[0]) && is_indir_node(regs.sp[0]) )
	regs.sp[0] = regs.sp[0]->n.node;
    while ( is_tagged_ptr(regs.sp[1]) && is_indir_node(regs.sp[1]) )
	regs.sp[1] = regs.sp[1]->n.node;

    /* save the local space */
    save_search_space(0);

    /* allocate the list of search continuations */
    CHECK_HEAP(0, n_conts * (search_cont_node_size + closure_node_size(1)
			     + cons_node_size));
    list = nil;
    while ( n_conts-- > 0 )
    {
	sc	    = (Node *)regs.hp;
	sc->info    = &search_cont_info;
	sc->sc.spc  = regs.bp->btSpc;
	sc->sc.susp = regs.sp[0];
	sc->sc.var  = regs.sp[1];
	sc->sc.code = *--conts;
	sc->sc.rq   = regs.rq;
	sc->sc.ss   = regs.ss;
	regs.hp	   += search_cont_node_size;

	clos		= (Node *)regs.hp;
	clos->info	= search_cont_papp_info_table;
	clos->c.args[0] = sc;
	regs.hp	       += closure_node_size(1);

	cons		= (Node *)regs.hp;
	cons->info	= &cons_info;
	cons->c.args[0] = clos;
	cons->c.args[1] = list;
	regs.hp	       += cons_node_size;
	list		= cons;
    }

    /* return the list */
    pop_search_context();
    RETURN(list, 0);
}

@ 
When a computation fails inside an encapsulated search, the current
search space is discarded and an empty list is returned to the
enclosing context.

<<search.c>>=
static
FUNCTION(fail_search)
{
 ENTRY_LABEL(static, fail_search)
    assert(is_search_context(regs.bp));
    if ( print_fail > 1 )
	fprintf(stderr, "Failure: %s\n", (const char *)regs.r[0]);

    /* discard the current search space and context */
    discard_search_space();
    pop_search_context();

    /* return an empty list to the caller */
    TRACE(("leaving encapsulated search with no solution\n"));
    RETURN(nil, 0);
}

@ 
\label{encapsulation}
There is an inherent conflict between sharing (of logical variables
and lazy applications) and non-deterministic evaluation, as was
recently pointed out in~\cite{BrasselHanusHuch04:Encapsulating}. An
implementation of encapsulated search can either preserve sharing at
the cost of being unable to encapsulate some non-deterministic
computations (\emph{weak encapsulation}) or encapsulate all
non-deterministic computations at the cost of losing sharing of
unevaluated applications (\emph{strong encapsulation}), which can make
the result of a program depend on evaluation order. As a simple
example, consider the program
\begin{verbatim}
  coin = 0
  coin = 1
  goal | xs =:= findall (\z -> z =:= y) & x =:= y = (x,xs)
    where y = coin
          x,xs free
\end{verbatim}
With weak encapsulation, which is used by our implementation of
encapsulated search, the non-deterministic evaluation of \texttt{coin}
is not encapsulated, but \texttt{y} will have a consistent meaning in
the program. In particular, \texttt{goal} has the two
non-deterministic solutions \texttt{(0,[0])} and \texttt{(1,[1])}.
With strong encapsulation, the result of \texttt{goal} depends on the
order in which the equality constraints are evaluated. If the left
constraint is evaluated first, \texttt{goal} has solutions
\texttt{(0,[0,1])} and \texttt{(1,[0,1])}, i.e., there are two
different interpretations for \texttt{y}. On the other hand, if the
right constraint is evaluated first, \texttt{goal} has the same
solutions as with weak encapsulation, i.e., \texttt{(0,[0])} and
\texttt{(1,[1])}.

Since both approaches are unsatisfactory in some way, the authors
of~\cite{BrasselHanusHuch04:Encapsulating} propose a new primitive IO
action [[getSearchTree]] for encapsulated search, which is based on
strong encapsulation. As this primitive can be used only at the
monadic top-level of a program, problematic examples like
\texttt{goal} cannot occur.

In order to implement [[getSearchTree]], we provide a primitive IO
action [[encapsulate]] that is quite similar to [[try]], but uses a
fresh copy of its input argument within the local search space, which
is necessary in order to achieve strong encapsulation, and does not
start the evaluation of the search goal so that no error is reported
in the program
\begin{verbatim}
  main = do { getSearchTree (error "no computation"); return () }
\end{verbatim}

<<search.c>>=
DECLARE_LABEL(extern, __encapsulate);
DECLARE_LABEL(static, __encapsulate_1);

FUNCTION(__encapsulate)
{
    Node *susp, *var, *clos, *sc;
 ENTRY_LABEL(extern, __encapsulate)
    SAVE_REGS(0);

    /* create a new search context for the goal */
    TRACE(("starting encapsulated search\n"));
    push_search_context();
    new_search_space(1);

    /* copy the argument into the new search space */
    regs.r[0] = copy_graph(0, regs.r[0], 0);

    /* allocate new goal variable and suspension */
    CHECK_HEAP(1, queueMe_node_size + variable_node_size);
    var		 = (Node *)regs.hp;
    var->info	 = variable_info_table;
    var->v.spc	 = regs.ss;
    var->v.wq	 = 0;
    var->v.cstrs = 0;
    regs.hp	+= variable_node_size;

    susp	= (Node *)regs.hp;
    susp->info	= queueMe_info_table;
    susp->q.spc = regs.ss;
    susp->q.wq	= 0;
    regs.hp    += queueMe_node_size;

    /* prepare the initial thread that evaluates the argument via v=:=e */
    CHECK_STACK(2);
    regs.sp   -= 2;
    regs.sp[0] = regs.r[2] = susp;
    regs.sp[1] = regs.r[1] = var;
    start_thread(3, 0);

    SAVE_RET4(regs.r[1], regs.r[0], (Node *)update, regs.r[2]);

    /* save the current state */
    TRACE(("leaving encapsulated search with 1 continuation\n"));
    save_continuation(0);
    save_search_space(0);

    /* allocate a search continuation */
    CHECK_HEAP(0, search_cont_node_size + closure_node_size(1));
    sc		= (Node *)regs.hp;
    sc->info	= &search_cont_info;
    sc->sc.spc	= regs.bp->btSpc;
    sc->sc.susp	= regs.sp[0];
    sc->sc.var	= regs.sp[1];
    sc->sc.code	= __encapsulate_1;
    sc->sc.rq	= regs.rq;
    sc->sc.ss	= regs.ss;
    regs.hp    += search_cont_node_size;

    clos	    = (Node *)regs.hp;
    clos->info	    = search_cont_papp_info_table;
    clos->c.args[0] = sc;
    regs.hp	   += closure_node_size(1);

    /* return the search goal */
    pop_search_context();
    RETURN(clos, 0);
}

static
FUNCTION(__encapsulate_1)
{
 ENTRY_LABEL(static, __encapsulate_1)
    CALL_RET2(___61__58__61_, 2, regs.sp[0], regs.sp[1]);
}
