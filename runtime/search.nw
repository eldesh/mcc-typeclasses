% -*- noweb-code-mode: c-mode -*-
% $Id: search.nw 2270 2007-06-16 14:59:21Z wlux $
%
% Copyright (c) 2002-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Encapsulated Search}
The implementation of encapsulated search is mostly private to this
module. The external entry points into this module are the external
function [[try]], which starts a new encapsulated search, and the
function [[suspend_search]], which allows the program to temporarily
suspend an encapsulated search.

<<search.h>>=
extern void suspend_search(Label, Node *, SearchSpace *);

@ 
<<search.c>>=
#include "curry.h"
#include "search.h"
#include "vars.h"
#include "stats.h"

static void push_search_context(void);
static void pop_search_context(void);

DECLARE_LABEL(static, eval_clos_1);
DECLARE_LABEL(static, solved_goal);
DECLARE_LABEL(static, search_goal_success);
DECLARE_LABEL(static, search_cont);
DECLARE_LABEL(static, search_goal_proceed);
DECLARE_LABEL(static, resume_search);
DECLARE_LABEL(static, choices_search);
DECLARE_LABEL(static, deadlock_search);
DECLARE_LABEL(static, fail_search);

static const struct nondet_handlers search_handlers = {
    choices_search, deadlock_search, fail_search
};

static
FUNCTION(eval_clos_1)
{
    Node *clos;
 ENTRY_LABEL(static, eval_clos_1)
    clos       = regs.sp[0];
    regs.sp[0] = clos->c.args[0];
    GOTO(clos->info->entry);
}

static NodeInfo solved_goal_papp_info_table[] = {
    PAPPINFO("<solved goal>", 1, solved_goal, 2)
};
static NodeInfo search_cont_papp_info_table[] = {
    PAPPINFO("<search goal>", 1, search_cont, 2)
};

@
Search contexts are allocated on the stack in order to save the
machine state before an encapsulated search starts and to restore the
machine state after the encapsulated search is left again. Note that
the argument on the top of the stack is passed to the local search and
not saved by the context.

<<search.c>>=
static void
push_search_context()
{
    Choicepoint *oldBp = regs.bp;

    CHECK_STACK(wordsof(Choicepoint));
    regs.sp   -= wordsof(Choicepoint);
    regs.sp[0] = regs.sp[wordsof(Choicepoint)];

    /* allocate a new search context on the stack */
    regs.bp		= (Choicepoint *)(regs.sp + 1);
    regs.bp->btAlts	= 0;	    /* btAlts == 0 identifies search context */
    regs.bp->btCid	= regs.cid;
    regs.bp->btDsBase   = regs.ds_base;
    regs.bp->btBp	= oldBp;
    regs.bp->btRq	= regs.rq;
#if !COPY_SEARCH_SPACE
    regs.bp->btTp	= regs.tp;
#endif
    regs.bp->btDict	= names_tail;
    regs.bp->btHp	= regs.hp;
    regs.bp->btSpc	= regs.ss;
    regs.bp->btHandlers = regs.handlers;

    /* change the current handler vector */
    regs.handlers = &search_handlers;

    /* initialize the machine state for the new context */
    regs.cid	 = 0;
    regs.ds_base = regs.sp;
    regs.rq	 = 0;
    regs.hlim	 = regs.hp;
}

static void
pop_search_context()
{
    assert(regs.bp->btAlts == 0);

    /* eventually restore a safe ancestor of the current search space */
    leave_context();

    /* restore the machine state from the current search context */
    regs.cid	  = regs.bp->btCid;
    regs.ds_base  = regs.bp->btDsBase;
    regs.rq	  = regs.bp->btRq;
#if !COPY_SEARCH_SPACE
    regs.tp	  = regs.bp->btTp;
#endif
    regs.ss	  = regs.bp->btSpc;
    regs.handlers = regs.bp->btHandlers;
    regs.sp	  = (Node **)(regs.bp + 1);

    /* drop the search context */
    regs.bp   = regs.bp->btBp;
    regs.hlim = regs.bp ? regs.bp->btHp : heap_base;
}

@ 
The [[try]] function starts an encapsulated search. After pushing a
new search context onto the stack and creating a new search space,
[[try]] starts the evaluation of the search goal by applying it to a
fresh variable. In addition, a queue-me node is created that allows
checking for successful termination of the goal's evaluation. %'

When [[try]] is applied to an already solved search goal (as returned
from a previous encapsulated search), this search goal is returned
immediately. In addition, when [[try]] is applied to a partially
solved search goal, the goal variable and queue-me node of that goal
are shared instead of allocating fresh nodes.

<<search.c>>=
DECLARE_LABEL(extern, __try);
DECLARE_LABEL(static, __try_1);

FUNCTION(__try)
{
 ENTRY_LABEL(extern, __try)
    EVAL_BOXED(__try_1);
}

static
FUNCTION(__try_1)
{
    Node *susp, *list, *sc, *var;
 ENTRY_LABEL(static, __try_1)
    MATCH_RIGID_PAPP(__try_1);
    assert(regs.sp[0]->info->tag == 1);

    /* return immediately when applied to a solved search goal */
    if ( regs.sp[0]->info == solved_goal_papp_info_table )
    {
	CHECK_HEAP(cons_node_size);
	list		= (Node *)regs.hp;
	list->info	= &cons_info;
	list->c.args[0] = *regs.sp++;
	list->c.args[1] = nil;
	regs.hp	       += cons_node_size;
	RETURN(list);
    }

    /* create a new search context */
    TRACE(("starting encapsulated search\n"));
    push_search_context();
#if COPY_SEARCH_SPACE
    new_search_space();
#endif

    /* when applied to a partially solved goal continue its evaluation */
    if ( regs.sp[0]->info == search_cont_papp_info_table )
    {
	sc = regs.sp[0]->c.args[0];
#if COPY_SEARCH_SPACE
	sc = copy_graph(sc, sc->sc.spc);
#endif

	CHECK_STACK1();
	regs.sp   -= 1;
	regs.sp[0] = sc->sc.susp;
	regs.sp[1] = sc->sc.var;
#if !COPY_SEARCH_SPACE
	restore_search_space(sc->sc.spc);
#endif
	GOTO(resume_continuation(sc->sc.code, sc->sc.rq));
    }

#if !COPY_SEARCH_SPACE
    /* create a new search space */
    new_search_space();
#endif

    /* allocate new goal variable and suspension */
    CHECK_HEAP(variable_node_size + queueMe_node_size);
    var		 = (Node *)regs.hp;
    var->info	 = variable_info_table;
    var->v.spc	 = regs.ss;
    var->v.wq	 = 0;
    var->v.cstrs = 0;
    regs.hp	+= variable_node_size;

    susp	= (Node *)regs.hp;
    susp->info	= queueMe_info_table;
    susp->q.spc	= regs.ss;
    susp->q.wq	= 0;
    regs.hp    += queueMe_node_size;

    /* start the initial thread and evaluate the goal */
    CHECK_STACK(6);
    regs.sp   -= 6;
    regs.sp[0] = regs.sp[6];
    regs.sp[1] = var;
    regs.sp[2] = (Node *)update;
    regs.sp[3] = susp;
    regs.sp[4] = 0;
    regs.sp[5] = susp;
    regs.sp[6] = var;
    start_thread(5);
    GOTO(regs.sp[0]->info->apply);
}

@ 
A solved search goal is represented by a (partial) application of
function [[solved_goal]] to a search continuation saving the state of
the solved goal. When such a closure is applied to an argument, this
argument is unified with a copy of the goal's solution. Copying %'
ensures that multiple applications of a (partially) solved search goal
to different arguments succeed, if the (partial) solution contains
free variables. For instance, the expression
\begin{verbatim}
  let [g] = try (\x -> success) in g 0 & g 1
\end{verbatim}
succeeds because \verb|try (\x -> success)| is equivalent to
\verb|[\x -> success]|.

<<search.c>>=
static
FUNCTION(solved_goal)
{
    Node  *cont, *res, *arg;
 ENTRY_LABEL(static, solved_goal)
    cont = regs.sp[0];
    res	 = copy_graph(cont->sc.var, cont->sc.spc);

    arg = regs.sp[1];
    while ( is_boxed(arg) && arg->info->kind == INDIR_KIND )
	arg = arg->n.node;
    if ( is_boxed(arg) && is_variable_node(arg) && is_local_space(arg->v.spc) )
    {
	CHECK_STACK1();
	regs.sp   -= 1;
	regs.sp[0] = res;
	regs.sp[1] = arg;
	regs.sp[2] = (Node *)search_goal_success;
	GOTO(bind_var);
    }

    regs.sp[0] = arg;
    regs.sp[1] = res;
    GOTO(___61__58__61_);
}

static
FUNCTION(search_goal_success)
{
 ENTRY_LABEL(static, search_goal_success)
    regs.sp += 1;
    RETURN(Success);
}

@ 
A partially solved search goal is returned from an encapsulated search
when a non-deterministic computation step has to be performed. In that
case, the current state of the computation is saved in a list of
search continuation nodes. For each alternative continuation, a
(partial) application of function [[search_cont]] to the corresponding
search continuation node is created. When one of these closures is
applied to an argument, the saved state is restored and a unification
between the argument and the partial solution computed so far for the
search goal is performed. The unification is started before resuming
the evaluation of the search goal in order to allow an effective
implementation of pruning search strategies. Note that [[try]]
implicitly performs this unification when it is applied to a partially
solved search goal by sharing the goal variable.

If the current search space is a root space, i.e., if no
non-deterministic choice was performed for the current goal, the
current space will be adopted as a child by the search space of the
resumed search goal. Otherwise, the saved state must be copied into
the current search space. This policy ensures that -- except for some
unusual cases, e.g., continuing a partially solved goal in a global
context -- expensive copying is avoided.

Note that [[search_goal_proceed]] discards the value on the top of the
stack and therefore it does not matter that [[bind_var]] returns the
argument to which [[search_cont]] was applied, whereas the equality
constraint returns the constant [[Success]].

<<search.c>>=
static
FUNCTION(search_cont)
{
    Node *arg, *cont;
 ENTRY_LABEL(static, search_cont)
    cont = regs.sp[0];
    if ( !inject_search_space(cont->sc.spc) )
	regs.sp[0] = cont = copy_graph(cont, cont->sc.spc);
    restore_continuation(cont->sc.code, cont->sc.rq);

    /* NB reload cont -- restore_continuation might invoke gc */
    cont = regs.sp[0];
    arg  = regs.sp[1];
    while ( is_boxed(arg) && arg->info->kind == INDIR_KIND )
	arg = arg->n.node;

    CHECK_STACK(2);
    regs.sp   -= 2;
    regs.sp[2] = (Node *)search_goal_proceed;
    regs.sp[3] = cont->sc.susp;
    if ( is_boxed(arg) && is_variable_node(arg) && is_local_space(arg->v.spc) )
    {
	regs.sp[0] = cont->sc.var;
	regs.sp[1] = arg;
	GOTO(bind_var);
    }
    regs.sp[0] = arg;
    regs.sp[1] = cont->sc.var;
    GOTO(___61__58__61_);
}

static
FUNCTION(search_goal_proceed)
{
    Node *susp;
 ENTRY_LABEL(static, search_goal_proceed)
    regs.sp += 1;
    susp     = regs.sp[0];
    ASSERT(is_boxed(susp));
    GOTO(susp->info->eval);
}

@ 
When no thread can be run in an encapsulated search, the evaluation of
the search goal either did succeed or a deadlock has occurred. Both
cases can be distinguished by examining the queue-me node allocated by
[[try]] for that purpose. If the search was successful, the queue-me
node has been overwritten with (an indirection to) [[Success]]. Thus,
if this node is not bound to [[Success]], the evaluation has stopped
due to a deadlock. In that case, the calling thread cannot be
continued, too, and is terminated instantly.

\ToDo{Instead of waiting for the deadlock to propagate up to the
  global context, report an error when a deadlock occurs.}

<<search.c>>=
static
FUNCTION(deadlock_search)
{
    Node *goal, *sc, *clos, *list;
 ENTRY_LABEL(static, deadlock_search)
    /* check for successful computation or deadlock */
    assert(regs.sp == (Node **)regs.bp - 2);
    for ( goal = regs.sp[0]; ; )
    {
	switch ( goal->info->kind )
	{
	case CAPP_KIND:
	    break;
	case LAZY_KIND:
	    assert(goal->info->tag == QUEUEME_TAG);
	    /* FALL THROUGH!!! */
	case LVAR_KIND:
	    TRACE(("deadlock in encapsulated search\n"));
	    discard_search_space();
	    pop_search_context();
	    GOTO(stop_thread);
	case INDIR_KIND:
	    goal = goal->n.node;
	    continue;
	default:
	    invalid_arg("deadlock_search", goal->info->kind);
	}
	break;
    }
    TRACE(("leaving encapsulated search with solved search goal\n"));

    /* dereference the goal variable in order to avoid some garbage */
    while ( is_boxed(regs.sp[1]) && regs.sp[1]->info->kind == INDIR_KIND )
	regs.sp[1] = regs.sp[1]->n.node;

    /* save the local space */
    save_search_space();

    /* allocate the singleton list for the search continuation */
    CHECK_HEAP(search_cont_node_size + closure_node_size(1) + cons_node_size);
    sc		= (Node *)regs.hp;
    sc->info	= &search_cont_info;
    sc->sc.spc	= regs.ss;
    sc->sc.susp	= 0;
    sc->sc.var	= regs.sp[1];
    sc->sc.code	= 0;
    sc->sc.rq	= 0;
    regs.hp    += search_cont_node_size;

    clos	    = (Node *)regs.hp;
    clos->info	    = solved_goal_papp_info_table;
    clos->c.args[0] = sc;
    regs.hp	   += closure_node_size(1);

    list	    = (Node *)regs.hp;
    list->info	    = &cons_info;
    list->c.args[0] = clos;
    list->c.args[1] = nil;
    regs.hp	   += cons_node_size;

    /* return the list */
    pop_search_context();
    RETURN(list);
}

@ 
The function [[suspend_search]] suspends the current search and
eventually enclosing searches in order to make [[space]] a local space.
This is intended to allow evaluation of a non-local lazy application
within an encapsulated search and in order to suspend a search until a
non-local variable is instantiated. The return stack set up by
[[suspend_search]] ensures that the suspended search is resumed at
address [[retIp]] after [[node]] has been evaluated.

<<search.c>>=
void
suspend_search(Label retIp, Node *node, SearchSpace *space)
{
    Node *sc;

    BEGIN_LOCAL_ROOTS2(node, space)
    while ( !is_local_space(space) )
    {
	TRACE(("suspending encapsulated search\n"));
	if ( regs.bp == 0 || !is_search_context(regs.bp) )
	    curry_panic("local variable escaped its search space\n");

	/* save the current state */
	save_continuation();

	/* dereference the goal nodes in order to avoid some garbage */
	assert(regs.sp == (Node **)regs.bp - 2);
	while ( is_boxed(regs.sp[0]) && regs.sp[0]->info->kind == INDIR_KIND )
	    regs.sp[0] = regs.sp[0]->n.node;
	while ( is_boxed(regs.sp[1]) && regs.sp[1]->info->kind == INDIR_KIND )
	    regs.sp[1] = regs.sp[1]->n.node;

	/* save the local space */
	save_search_space();

	/* allocate a search continuation */
	CHECK_HEAP(search_cont_node_size);
	sc	    = (Node *)regs.hp;
	sc->info    = &search_cont_info;
	sc->sc.spc  = regs.ss;
	sc->sc.susp = regs.sp[0];
	sc->sc.var  = regs.sp[1];
	sc->sc.code = retIp;
	sc->sc.rq   = regs.rq;
	regs.hp	   += search_cont_node_size;

	/* save the search continuation and set up a return frame that
	 * restores the suspended search; note that resume_search discards
	 * its first argument */
	pop_search_context();
	CHECK_STACK(3);
	retIp	   = resume_search;
	regs.sp   -= 2;
	regs.sp[0] = 0;
	regs.sp[1] = sc;
    }
    END_LOCAL_ROOTS

    regs.sp   -= 1;
    regs.sp[0] = node;
    regs.sp[1] = (Node *)retIp;
}

@ 
When an encapsulated search is resumed that was interrupted by a call
to [[suspend_search]], the argument on the top of the stack is
discarded. A pointer to the (non-local) application node or variable
is found on the top of the local stack prepared by [[suspend_search]].

<<search.c>>=
static
FUNCTION(resume_search)
{
    Node *sc;
 ENTRY_LABEL(static, resume_search)
    regs.sp += 1;
    sc	     = regs.sp[0];
    assert(is_boxed(sc) && is_search_cont_node(sc));

    TRACE(("resuming encapsulated search\n"));
    push_search_context();

    CHECK_STACK1();
    regs.sp   -= 1;
    regs.sp[0] = sc->sc.susp;
    regs.sp[1] = sc->sc.var;
    restore_search_space(sc->sc.spc);
    GOTO(resume_continuation(sc->sc.code, sc->sc.rq));
}

@ 
If a non-deterministic computation step must be performed in a local
search space, the runtime system creates a search continuation node
for each alternative in the continuation array on the top of the
stack and returns those nodes as a list to the enclosing context.

<<search.c>>=
static
FUNCTION(choices_search)
{
    unsigned int n_conts;
    Node	 *list, *cons, *clos, *sc;
    const Label	 *conts;
 ENTRY_LABEL(static, choices_search)
    assert(regs.bp && is_search_context(regs.bp));

    /* compute the number of alternative solutions */
    n_conts = 0;
    for ( conts = (const Label *)*regs.sp++; *conts; conts++ )
	n_conts++;
    assert(n_conts > 1);
    TRACE(("leaving encapsulated search with %u continuations\n", n_conts));

    /* save the current state */
    save_continuation();

    /* dereference the goal nodes in order to avoid some garbage */
    assert(regs.sp == (Node **)regs.bp - 2);
    while ( is_boxed(regs.sp[0]) && regs.sp[0]->info->kind == INDIR_KIND )
	regs.sp[0] = regs.sp[0]->n.node;
    while ( is_boxed(regs.sp[1]) && regs.sp[1]->info->kind == INDIR_KIND )
	regs.sp[1] = regs.sp[1]->n.node;

    /* save the local space */
    save_search_space();

    /* allocate the list of search continuations */
    CHECK_HEAP(n_conts * (search_cont_node_size + closure_node_size(1)
			  + cons_node_size));
    list = nil;
    while ( n_conts-- > 0 )
    {
	sc	    = (Node *)regs.hp;
	sc->info    = &search_cont_info;
	sc->sc.spc  = regs.ss;
	sc->sc.susp = regs.sp[0];
	sc->sc.var  = regs.sp[1];
	sc->sc.code = *--conts;
	sc->sc.rq   = regs.rq;
	regs.hp	   += search_cont_node_size;

	clos		= (Node *)regs.hp;
	clos->info	= search_cont_papp_info_table;
	clos->c.args[0] = sc;
	regs.hp	       += closure_node_size(1);

	cons		= (Node *)regs.hp;
	cons->info	= &cons_info;
	cons->c.args[0] = clos;
	cons->c.args[1] = list;
	regs.hp	       += cons_node_size;
	list		= cons;
    }

    /* return the list */
    pop_search_context();
    RETURN(list);
}

@ 
When a computation fails inside an encapsulated search, the current
search space is discarded and an empty list is returned to the
enclosing context.

<<search.c>>=
static
FUNCTION(fail_search)
{
 ENTRY_LABEL(static, fail_search)
    assert(is_search_context(regs.bp));

    /* discard the current search space and context */
    discard_search_space();
    pop_search_context();

    /* return an empty list to the caller */
    TRACE(("leaving encapsulated search with no solution\n"));
    RETURN(nil);
}

@ 
\label{encapsulation}
There is an inherent conflict between sharing (of logical variables
and lazy applications) and non-deterministic evaluation, as was
recently pointed out in~\cite{BrasselHanusHuch04:Encapsulating}. An
implementation of encapsulated search can either preserve sharing at
the cost of being unable to encapsulate some non-deterministic
computations (\emph{weak encapsulation}) or encapsulate all
non-deterministic computations at the cost of losing sharing of
unevaluated applications (\emph{strong encapsulation}), which can make
the result of a program depend on evaluation order. As a simple
example, consider the program
\begin{verbatim}
  coin = 0
  coin = 1
  goal | xs =:= findall (\z -> z =:= y) & x =:= y = (x,xs)
    where y = coin
          x,xs free
\end{verbatim}
With weak encapsulation, which is used by our implementation of
encapsulated search, the non-deterministic evaluation of \texttt{coin}
is not encapsulated, but \texttt{y} will have a consistent meaning in
the program. In particular, \texttt{goal} has the two
non-deterministic solutions \texttt{(0,[0])} and \texttt{(1,[1])}.
With strong encapsulation, the result of \texttt{goal} depends on the
order in which the equality constraints are evaluated. If the left
constraint is evaluated first, \texttt{goal} has solutions
\texttt{(0,[0,1])} and \texttt{(1,[0,1])}, i.e., there are two
different interpretations for \texttt{y}. On the other hand, if the
right constraint is evaluated first, \texttt{goal} has the same
solutions as with weak encapsulation, i.e., \texttt{(0,[0])} and
\texttt{(1,[1])}.

Since both approaches are unsatisfactory in some way, the authors
of~\cite{BrasselHanusHuch04:Encapsulating} propose a new primitive IO
action [[getSearchTree]] for encapsulated search, which is based on
strong encapsulation. As this primitive can be used only at the
monadic top-level of a program, problematic examples like
\texttt{goal} cannot occur.

In order to implement [[getSearchTree]], we provide a primitive IO
action [[encapsulate]] that is quite similar to [[try]], but uses a
fresh copy of its input argument within the local search space, which
is necessary in order to achieve strong encapsulation, and does not
start the evaluation of the search goal so that no error is reported
in the program
\begin{verbatim}
  main = do { getSearchTree (error "no computation"); return () }
\end{verbatim}

<<search.c>>=
DECLARE_LABEL(extern, __encapsulate);

FUNCTION(__encapsulate)
{
    Node *susp, *var, *goal, *clos, *sc;
 ENTRY_LABEL(extern, __encapsulate)
    /* create a new search context for the goal */
    TRACE(("starting encapsulated search\n"));
    regs.sp[1] = regs.sp[0];
    regs.sp   += 1;
    push_search_context();
    new_search_space();

    /* copy the argument into the new search space */
    regs.sp[0] = copy_graph(regs.sp[0], 0);

    /* allocate new goal variable and suspension */
    CHECK_HEAP(queueMe_node_size + variable_node_size);
    var		 = (Node *)regs.hp;
    var->info	 = variable_info_table;
    var->v.spc	 = regs.ss;
    var->v.wq	 = 0;
    var->v.cstrs = 0;
    regs.hp	+= variable_node_size;

    susp	= (Node *)regs.hp;
    susp->info	= queueMe_info_table;
    susp->q.spc = regs.ss;
    susp->q.wq	= 0;
    regs.hp    += queueMe_node_size;

    /* prepare the initial thread that evaluates the argument via v=:=e */
    CHECK_STACK(6);
    goal       = regs.sp[0];
    regs.sp   -= 6;
    regs.sp[0] = var;
    regs.sp[1] = goal;
    regs.sp[2] = (Node *)update;
    regs.sp[3] = susp;
    regs.sp[4] = 0;
    regs.sp[5] = susp;
    regs.sp[6] = var;
    start_thread(5);

    /* save the current state */
    TRACE(("leaving encapsulated search with 1 continuation\n"));
    save_continuation();
    save_search_space();

    /* allocate a search continuation */
    CHECK_HEAP(search_cont_node_size + closure_node_size(1));
    sc		= (Node *)regs.hp;
    sc->info	= &search_cont_info;
    sc->sc.spc	= regs.ss;
    sc->sc.susp = regs.sp[0];
    sc->sc.var	= regs.sp[1];
    sc->sc.code	= ___61__58__61_;
    sc->sc.rq	= regs.rq;
    regs.hp    += search_cont_node_size;

    clos	    = (Node *)regs.hp;
    clos->info	    = search_cont_papp_info_table;
    clos->c.args[0] = sc;
    regs.hp	   += closure_node_size(1);

    /* return the search goal */
    pop_search_context();
    RETURN(clos);
}
