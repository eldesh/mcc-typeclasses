% -*- noweb-code-mode: c-mode -*-
% $Id: show.nw 1916 2006-05-08 21:36:20Z wlux $
%
% Copyright (c) 2001-2006, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Show Function}
The function \verb|shows :: a -> String -> String| is used to convert
a value lazily into a string. This function uses the information
available in the node info structure in order to determine how its
argument should be displayed.

A minor variant of \verb|shows| is the impure function
\verb|dvals :: a -> String -> String|, which does not evaluate its
argument and also does not wait until unbound variables are
instantiated. The primary objective of this function is to support the
declarative debugger.

<<show.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <math.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "spaces.h"
#include "search.h"
#include "trail.h"
#include "eval.h"
#include "data.h"
#include "vars.h"
#include "cstring.h"
#include "cam.h"
#include "trace.h"

DECLARE_ENTRYPOINT(__shows);
DECLARE_ENTRYPOINT(__dvals);
DECLARE_LABEL(showp);
DECLARE_LABEL(showp_1);
DECLARE_LABEL(showArgs);
DECLARE_LABEL(showInfix);
DECLARE_LABEL(showTuple);
DECLARE_LABEL(showTupleArgs);
DECLARE_LABEL(showList);
DECLARE_LABEL(showTail);
DECLARE_LABEL(showTail_1);
DECLARE_LABEL(showString);
DECLARE_LABEL(showStringTail);

#if ONLY_BOXED_OBJECTS
static const struct int_node zero_node = { &int_info, 0 };
static const struct int_node one_node  = { &int_info, 1 };
static const struct int_node two_node  = { &int_info, 2 };

# define zero CONST(zero)
# define one  CONST(one)
# define two  CONST(two)
#else
# define zero mk_unboxed(0)
# define one  mk_unboxed(1)
# define two  mk_unboxed(2)
#endif

#define space	 (Node *)(char_table + ' ')
#define comma	 (Node *)(char_table + ',')
#define lparen	 (Node *)(char_table + '(')
#define rparen	 (Node *)(char_table + ')')
#define lbracket (Node *)(char_table + '[')
#define rbracket (Node *)(char_table + ']')
#define bar	 (Node *)(char_table + '|')
#define dblquote (Node *)(char_table + '\"')

DECLARE_LABEL(eval_lazy_3);
DECLARE_LABEL(eval_lazy_4);

static NodeInfo showp_lazy_info_table[] = LAZYINFO("showp", showp, 4);
static NodeInfo showArgs_lazy_info_table[] = LAZYINFO("showArgs", showArgs, 4);
static NodeInfo showTupleArgs_lazy_info_table[] =
    LAZYINFO("showTupleArgs", showTupleArgs, 3);
static NodeInfo showTail_lazy_info_table[] = LAZYINFO("showTail", showTail, 3);
static NodeInfo showStringTail_lazy_info_table[] =
    LAZYINFO("showStringTail", showStringTail, 3);

static
FUNCTION(eval_lazy_3)
{
    boolean local;
    Node    *susp, *x, *y, *z;
    Label   entry;
 ENTRY_LABEL(eval_lazy_3)
    /* suspend the search if the node is not local */
    local = is_local_space(sp[0]->s.spc);
    if ( !local )
	suspend_search(resume, sp[0], sp[0]->s.spc);

    /* get the arguments */
    susp  = sp[0];
    entry = susp->info->entry;
    x	  = susp->s.args[0];
    y	  = susp->s.args[1];
    z	  = susp->s.args[2];

    /* create an indirection if there is an update frame immediately above */
    if ( local && (Label)sp[1] == update )
    {
	CHECK_STACK(2);
	sp -= 2;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < hlim )
	{
	    DO_SAVE(susp, n.node);
	    susp->info += 2;
	}
	else
#endif
	    susp->info = &indir_info;
	assert(is_queueMe_node(sp[4]));
	susp->n.node = sp[4];
    }

    /* otherwise, lock the application node and create an update frame */
    else
    {
	CHECK_STACK(4);
	sp   -= 4;
	sp[3] = (Node *)update;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < hlim )
	{
	    DO_SAVE(susp, q.wq);
	    susp->info++;
	}
	else
#endif
	    susp->info = queueMe_info_table;
	susp->q.wq = 0;
    }

    /* enter the callee */
    sp[0] = x;
    sp[1] = y;
    sp[2] = z;
    GOTO(entry);
}

static
FUNCTION(eval_lazy_4)
{
    boolean local;
    Node    *susp, *x, *y, *z, *t;
    Label   entry;
 ENTRY_LABEL(eval_lazy_4)
    /* suspend the search if the node is not local */
    local = is_local_space(sp[0]->s.spc);
    if ( !local )
	suspend_search(resume, sp[0], sp[0]->s.spc);

    /* get the arguments */
    susp  = sp[0];
    entry = susp->info->entry;
    x	  = susp->s.args[0];
    y	  = susp->s.args[1];
    z	  = susp->s.args[2];
    t	  = susp->s.args[3];

    /* create an indirection if there is an update frame immediately above */
    if ( local && (Label)sp[1] == update )
    {
	CHECK_STACK(3);
	sp -= 3;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < hlim )
	{
	    DO_SAVE(susp, n.node);
	    susp->info += 2;
	}
	else
#endif
	    susp->info = &indir_info;
	assert(is_queueMe_node(sp[5]));
	susp->n.node = sp[5];
    }

    /* otherwise, lock the application node and create an update frame */
    else
    {
	CHECK_STACK(5);
	sp   -= 5;
	sp[4] = (Node *)update;

#if !COPY_SEARCH_SPACE
	if ( (word *)susp < hlim )
	{
	    DO_SAVE(susp, q.wq);
	    susp->info++;
	}
	else
#endif
	    susp->info = queueMe_info_table;
	susp->q.wq = 0;
    }

    /* enter the callee */
    sp[0] = x;
    sp[1] = y;
    sp[2] = z;
    sp[3] = t;
    GOTO(entry);
}

@
The external entry points \texttt{shows} and \texttt{dvals} just call
the main worker function \texttt{showp}. This function is called with
two additional arguments. The first is an integer precedence level
that controls whether an application must be enclosed in parentheses
and the second is an integer flag, which is set to 1 if \texttt{showp}
is called from \texttt{shows} and 0 otherwise. Note that
\texttt{dvals} calls \texttt{showp} with precedence level two. Thus,
all arguments are printed as if they did occur in an argument
position, which is the way \texttt{dvals} is used by the debugger.

<<show.c>>=
FUNCTION(__shows)
{
    EXPORT_LABEL(__shows)
 ENTRY_LABEL(__shows)
    CHECK_STACK(2);
    sp	 -= 2;
    sp[0] = sp[2];
    sp[1] = zero;
    sp[2] = one;
    GOTO(showp);
}

FUNCTION(__dvals)
{
    EXPORT_LABEL(__dvals)
 ENTRY_LABEL(__dvals)
    CHECK_STACK(2);
    sp	 -= 2;
    sp[0] = sp[2];
    sp[1] = two;
    sp[2] = zero;
    GOTO(showp);
}

@
When necessary, the \texttt{showp} function evaluates its argument to
weak head normal form and makes sure that it is not an unbound
variable. Then, it dispatches on the type of the node and delegates
processing to special purpose functions in order to handle data
structures with arguments.

<<show.c>>=
static
FUNCTION(showp)
{
 ENTRY_LABEL(showp)
    TRACE_FUN("showp", 4);
    GOTO(showp_1);
}

static
FUNCTION(showp_1)
{
    boolean	 isop, isneg;
    char	 buf[32];
    const char   *str;
    unsigned int i, argc;
    double	 d;
    Node	 *node, *susp, *cons, *tail, *arglist, **argp, *prec, *show;

 ENTRY_LABEL(showp_1)

    str	  = buf;
    argc  = 0;
    node  = sp[0];
    prec  = sp[1];
    show  = sp[2];
    isop  = false;
    isneg = false;

 again:
#if !ONLY_BOXED_OBJECTS
    if ( is_unboxed(node) )
    {
	sprintf(buf, "%ld", unboxed_val(node));
	isneg = buf[0] == '-';
    }
    else
#endif
	switch ( node_kind(node) )
	{
	case INDIR_KIND:
	    node = node->n.node;
	    goto again;

	case LAZY_KIND:
	    if ( show != zero )
	    {
		CHECK_STACK1();
		sp   -= 1;
		sp[0] = node;
		sp[1] = (Node *)showp_1;
		GOTO(node->info->eval);
	    }
	    str = "_";
	    break;

	case LVAR_KIND:
	    if ( show != zero )
	    {
		CHECK_STACK1();
		sp   -= 1;
		sp[0] = node;
		sp[1] = (Node *)showp_1;
		GOTO(sync_var);
	    }
	    str = lookup_name(node);
	    break;

	case CHAR_KIND:
	    buf[0] = '\'';
	    strcat(lit_char(buf + 1, '\0', node->ch.ch, '\''), "'");
	    break;

	case INT_KIND:
	    sprintf(buf, "%ld", node->i.i);
	    isneg = buf[0] == '-';
	    break;

	case FLOAT_KIND:
	    get_double_val(d, node->f);
	    lit_double(buf, d);
	    isneg = buf[0] == '-';
	    break;

	case PTR_KIND:
	    sprintf(buf, long_val(prec) > 1 ? "(%s %p)" : "%s %p",
		    node->info->cname, node->p.ptr);
	    break;

	case FOREIGN_PTR_KIND:
	    sprintf(buf, long_val(prec) > 1 ? "(%s %p)" : "%s %p",
		    node->info->cname, node->fp.ptr);
	    break;

	case VECTOR_KIND:
	    if ( is_tuple(node->info) )
	    {
		*++sp = node;
		GOTO(showTuple);
	    }
	    else
	    {
		str  = node->info->cname;
		argc = vector_argc(node);
	    }
	    break;

	case PAPP_KIND:
	    str  = node->info->cname;
	    isop = is_operator(node->info) && !is_tuple(node->info);
	    argc = closure_argc(node);
	    break;

	case SEARCH_CONT_KIND:
	case ABSTRACT_KIND:
	    str = node->info->cname;
	    if ( str == 0 )
		str = "<abstract>";
	    break;

	case CAPP_KIND:
	    if ( node->info == (NodeInfo *)&cons_info )
	    {
		sp[0] = node->c.args[0];
		sp[1] = node->c.args[1];
		GOTO(showList);
	    }
	    else if ( is_tuple(node->info) )
	    {
		*++sp = node;
		GOTO(showTuple);
	    }
	    else
	    {
		str  = node->info->cname;
		isop = is_operator(node->info);
		argc = closure_argc(node);
	    }
	    break;

	default:
	    invalid_arg("showp", node_kind(node));
	}

    if ( isop && argc == 2 )
    {
	sp[0] = node;
	GOTO(showInfix);
    }

    sp[0] = node;
    CHECK_HEAP((argc + 1) * cons_node_size + suspend_node_size(4));
    node = sp[0];
    prec = sp[1];
    show = sp[2];
    tail = sp[3];

    if ( argc > 0 )
    {
	argp	= is_vector_node(node) ? node->a.args : node->c.args;
	arglist = nil;
	for ( i = argc; i-- > 0; )
	{
	    cons	    = (Node *)hp;
	    cons->info	    = &cons_info;
	    cons->c.args[0] = argp[i];
	    cons->c.args[1] = arglist;
	    arglist	    = cons;
	    hp		   += cons_node_size;
	}

	susp		= (Node *)hp;
	susp->info	= showArgs_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = arglist;
	susp->s.args[1] = prec;
	susp->s.args[2] = show;
	susp->s.args[3] = tail;
	hp	       += suspend_node_size(4);

	tail = susp;
    }

    if ( isop || (isneg && long_val(prec) > 0) )
    {
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = rparen;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;

	tail = cons;
    }

    sp[0] = prefix_string(str, tail);

    CHECK_HEAP(2*cons_node_size);
    cons = sp[0];
    prec = sp[1];
    sp  += 4;
    if ( isop || (isneg && long_val(prec) > 0) )
    {
	tail		= cons;
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = lparen;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;
    }
    if ( long_val(prec) > 1 && argc > 0 )
    {
	tail		= cons;
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = lparen;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;
    }

    RETURN(cons);
}

@
The function \texttt{showArgs} displays the arguments of an
application. Each argument is preceded by a space and enclosed in
parentheses if necessary.

<<show.c>>=
static
FUNCTION(showArgs)
{
    Node *arglist, *susp, *susp2, *cons, *tail, *prec, *show;
 ENTRY_LABEL(showArgs)
    TRACE_FUN("showArgs", 4);

    CHECK_HEAP(2 * suspend_node_size(4) + cons_node_size);
    arglist = sp[0];
    prec    = sp[1];
    show    = sp[2];
    tail    = sp[3];
    sp	   += 4;

    if ( arglist->info->tag == NIL_TAG )
    {
	if ( long_val(prec) > 1 )
	{
	    cons	    = (Node *)hp;
	    cons->info	    = &cons_info;
	    cons->c.args[0] = rparen;
	    cons->c.args[1] = tail;
	    hp		   += cons_node_size;
	}
	else
	{
	    *--sp = tail;
	    GOTO(tail->info->eval);
	}
    }
    else
    {
	ASSERT(arglist->info->tag == CONS_TAG);

	susp		= (Node *)hp;
	susp->info	= showArgs_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = arglist->c.args[1];
	susp->s.args[1] = prec;
	susp->s.args[2] = show;
	susp->s.args[3] = tail;
	hp	       += suspend_node_size(4);

	susp2		 = (Node *)hp;
	susp2->info	 = showp_lazy_info_table;
	susp2->s.spc	 = ss;
	susp2->s.args[0] = arglist->c.args[0];
	susp2->s.args[1] = two;
	susp2->s.args[2] = show;
	susp2->s.args[3] = susp;
	hp		+= suspend_node_size(4);

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = space;
	cons->c.args[1] = susp2;
	hp	       += cons_node_size;
    }

    RETURN(cons);
}

@
The function \texttt{showInfix} is invoked when the node to be shown
is an application of an infix operator to exactly two arguments. Such
nodes are displayed in infix notation. As we do not have access to the
fixity of the operator, we will ensure that every nested infix
application is enclosed in parentheses.

<<show.c>>=
static
FUNCTION(showInfix)
{
    long prec;
    Node *node, *tail, *show, *cons, *susp;
 ENTRY_LABEL(showInfix)
    CHECK_HEAP(2 * cons_node_size + suspend_node_size(4));
    node = sp[0];
    prec = long_val(sp[1]);
    show = sp[2];
    tail = sp[3];

    if ( prec > 0 )
    {
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = rparen;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;

	tail = cons;
    }

    susp	    = (Node *)hp;
    susp->info	    = showp_lazy_info_table;
    susp->s.spc	    = ss;
    susp->s.args[0] = node->c.args[1];
    susp->s.args[1] = one;
    susp->s.args[2] = show;
    susp->s.args[3] = tail;
    hp		   += suspend_node_size(4);

    cons	    = (Node *)hp;
    cons->info	    = &cons_info;
    cons->c.args[0] = space;
    cons->c.args[1] = susp;
    hp		   += cons_node_size;

    sp[0] = node->c.args[0];
    sp[3] = prefix_string(node->info->cname, cons);

    CHECK_HEAP(2 * cons_node_size + suspend_node_size(4));
    node = sp[0];
    show = sp[2];
    tail = sp[3];

    cons	    = (Node *)hp;
    cons->info	    = &cons_info;
    cons->c.args[0] = space;
    cons->c.args[1] = tail;
    hp		   += cons_node_size;

    if ( prec > 0 )
    {
	susp		= (Node *)hp;
	susp->info	= showp_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = node;
	susp->s.args[1] = one;
	susp->s.args[2] = show;
	susp->s.args[3] = cons;
	hp	       += suspend_node_size(4);

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = lparen;
	cons->c.args[1] = susp;
	hp	       += cons_node_size;

	sp += 4;
	RETURN(cons);
    }

    sp[1] = one;
    sp[3] = cons;
    GOTO(showp);
}

@
The code of \texttt{showp} jumps to the label \texttt{showTuple} in
order to display a tuple. In this case, the arguments are separated by
commas and not enclosed in parentheses. Instead, the whole tuple is
always enclosed in parentheses. Note that the function is prepared to
handle tuples as well as vectors, which are shown like a tuple.

<<show.c>>=
static
FUNCTION(showTuple)
{
    unsigned int i, argc;
    Node	 *tuple, *susp, *cons, *tail, *arglist, **argp, *show;
 ENTRY_LABEL(showTuple)
    argc = is_vector_node(sp[0]) ? vector_argc(sp[0]) : closure_argc(sp[0]);
    CHECK_HEAP(argc * cons_node_size + suspend_node_size(3)
	       + suspend_node_size(4));
    tuple = sp[0];
    show  = sp[1];
    tail  = sp[2];
    sp	 += 3;

    argp    = is_vector_node(tuple) ? tuple->a.args : tuple->c.args;
    argp   += argc;
    arglist = nil;

    for ( i = argc; i-- > 1; )
    {
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = *--argp;
	cons->c.args[1] = arglist;
	arglist		= cons;
	hp	       += cons_node_size;
    }

    susp	    = (Node *)hp;
    susp->info	    = showTupleArgs_lazy_info_table;
    susp->s.spc	    = ss;
    susp->s.args[0] = arglist;
    susp->s.args[1] = show;
    susp->s.args[2] = tail;
    hp		   += suspend_node_size(3);

    if ( argc )
    {
	tail = susp;

	susp		= (Node *)hp;
	susp->info	= showp_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = *--argp;
	susp->s.args[1] = zero;
	susp->s.args[2] = show;
	susp->s.args[3] = tail;
	hp	       += suspend_node_size(4);
    }

    cons	    = (Node *)hp;
    cons->info	    = &cons_info;
    cons->c.args[0] = lparen;
    cons->c.args[1] = susp;
    hp		   += cons_node_size;

    RETURN(cons);
}

static
FUNCTION(showTupleArgs)
{
    Node *arglist, *susp, *susp2, *cons, *tail, *show;
 ENTRY_LABEL(showTupleArgs)
    TRACE_FUN("showTupleArgs", 3);

    CHECK_HEAP(suspend_node_size(3) + suspend_node_size(4) + cons_node_size);
    arglist = sp[0];
    show    = sp[1];
    tail    = sp[2];
    sp	   += 3;

    if ( arglist->info->tag == NIL_TAG )
    {
	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = rparen;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;
    }
    else
    {
	ASSERT(arglist->info->tag == CONS_TAG);

	susp		= (Node *)hp;
	susp->info	= showTupleArgs_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = arglist->c.args[1];
	susp->s.args[1] = show;
	susp->s.args[2] = tail;
	hp	       += suspend_node_size(3);

	susp2		 = (Node *)hp;
	susp2->info	 = showp_lazy_info_table;
	susp2->s.spc	 = ss;
	susp2->s.args[0] = arglist->c.args[0];
	susp2->s.args[1] = zero;
	susp2->s.args[2] = show;
	susp2->s.args[3] = susp;
	hp		+= suspend_node_size(4);

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = comma;
	cons->c.args[1] = susp2;
	hp	       += cons_node_size;
    }

    RETURN(cons);
}

@
Lists are shown using the standard list notation, enclosing the whole
list in brackets and separating the arguments by commas. Eventually
the function \texttt{showTail} has to evaluate its tail before it can
be converted into a string. When being called from \texttt{dvals}, we
do not evaluate the tail of the list, but print it in the usual Prolog
notation, i.e., separating the unevaluated or non-ground tail from the
head of the list with a vertical bar. Unfortunately, this notation is
not available in source code because of ambiguities with the list
comprehension syntax. Fortunately, list comprehensions cannot occur in
the output; thus, there is no ambiguity here.

When we print a character list whose elements are ground values, we
make use of the standard string notation. In the case of the
\texttt{show} function we only need to check the first element of the
list in order to check whether it is a character. As \texttt{show} is
rigid we know that the string will be ground. The situation is
different for \texttt{dvals} because is not rigid. Therefore, we have
to check every character of the list. In order to prevent entering an
infinite loop when \texttt{dvals} is applied to a cyclic list -- as can
be created, for instance, with the function \texttt{repeat x = xs
where x:xs} -- only strings with less than 10000 characters are
recognized.

<<show.c>>=
static boolean
is_char(Node *node)
{
    while ( is_boxed(node) && is_indir_node(node) )
	node = node->n.node;
    return is_boxed(node) && is_char_node(node);
}

static boolean
is_string(Node *node)
{
    unsigned int n = 0;

    while ( is_boxed(node) && is_indir_node(node) )
	node = node->n.node;
    while ( n++ < 10000 && node != nil )
    {
	if ( node->info != &cons_info || !is_char(node->c.args[0]) )
	    return false;
	node = node->c.args[1];
	while ( is_boxed(node) && is_indir_node(node) )
	    node = node->n.node;
    }
    return node == nil;
}

static
FUNCTION(showList)
{
    Node *hd, *tl, *susp, *susp2, *cons, *tail, *show;
 ENTRY_LABEL(showList)
    hd	 = sp[0];
    show = sp[2];
    for (;;)
    {
	if ( is_boxed(hd) )
	    switch ( hd->info->kind )
	    {
	    case INDIR_KIND:
		hd = hd->n.node;
		continue;
	    case LAZY_KIND:
		if ( show != zero )
		{
		    CHECK_STACK1();
		    sp   -= 1;
		    sp[0] = hd;
		    sp[1] = (Node *)showList;
		    GOTO(hd->info->eval);
		}
		break;
	    case LVAR_KIND:
		if ( show != zero )
		{
		    CHECK_STACK1();
		    sp	 -= 1;
		    sp[0] = hd;
		    sp[1] = (Node *)showList;
		    GOTO(sync_var);
		}
		break;
	    case CHAR_KIND:
		if ( show != zero || is_string(sp[1]) )
		{
		    sp[0] = hd;
		    CHECK_HEAP(suspend_node_size(3) + 2 * cons_node_size);

		    hd   = sp[0];
		    tl   = sp[1];
		    tail = sp[3];
		    sp  += 4;

		    cons	    = (Node *)hp;
		    cons->info	    = &cons_info;
		    cons->c.args[0] = hd;
		    cons->c.args[1] = tl;
		    hp		   += cons_node_size;

		    susp	    = (Node *)hp;
		    susp->info	    = showStringTail_lazy_info_table;
		    susp->s.spc	    = ss;
		    susp->s.args[0] = cons;
		    susp->s.args[1] = (Node *)char_table;
		    susp->s.args[2] = tail;
		    hp		   += suspend_node_size(3);

		    cons	    = (Node *)hp;
		    cons->info	    = &cons_info;
		    cons->c.args[0] = dblquote;
		    cons->c.args[1] = susp;
		    hp		   += cons_node_size;

		    RETURN(cons);
		}
		break;
	    }
	break;
    }
    sp[0] = hd;

    CHECK_HEAP(suspend_node_size(3) + suspend_node_size(4) + cons_node_size);
    hd   = sp[0];
    tl	 = sp[1];
    show = sp[2];
    tail = sp[3];
    sp	+= 4;

    susp	    = (Node *)hp;
    susp->info	    = showTail_lazy_info_table;
    susp->s.spc	    = ss;
    susp->s.args[0] = tl;
    susp->s.args[1] = show;
    susp->s.args[2] = tail;
    hp		   += suspend_node_size(3);

    susp2	     = (Node *)hp;
    susp2->info	     = showp_lazy_info_table;
    susp2->s.spc     = ss;
    susp2->s.args[0] = hd;
    susp2->s.args[1] = zero;
    susp2->s.args[2] = show;
    susp2->s.args[3] = susp;
    hp		    += suspend_node_size(4);

    cons	    = (Node *)hp;
    cons->info	    = &cons_info;
    cons->c.args[0] = lbracket;
    cons->c.args[1] = susp2;
    hp		   += cons_node_size;

    RETURN(cons);
}

static
FUNCTION(showTail)
{
 ENTRY_LABEL(showTail)
    TRACE_FUN("showTail", 3);
    GOTO(showTail_1);
}

static
FUNCTION(showTail_1)
{
    Node *list, *susp, *susp2, *cons, *tail, *show;
 ENTRY_LABEL(showTail_1)
    list = sp[0];
    show = sp[1];
 again:
    switch ( node_kind(list) )
    {
    case INDIR_KIND:
	list = list->n.node;
	goto again;

    case LAZY_KIND:
	if ( show != zero )
	{
	    CHECK_STACK1();
	    sp -= 1;
	    sp[0] = list;
	    sp[1] = (Node *)showTail_1;
	    GOTO(list->info->eval);
	}
	goto make_tail;

    case LVAR_KIND:
	if ( show != zero )
	{
	    CHECK_STACK1();
	    sp	 -= 1;
	    sp[0] = list;
	    sp[1] = (Node *)showTail_1;
	    GOTO(sync_var);
	}
    make_tail:
	sp[0] = list;
	CHECK_HEAP(suspend_node_size(4) + 2 * cons_node_size);
	list = sp[0];
	show = sp[1];
	tail = sp[2];
	sp  += 3;

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = rbracket;
	cons->c.args[1] = tail;
	hp	       += cons_node_size;

	susp		= (Node *)hp;
	susp->info	= showp_lazy_info_table;
	susp->s.spc	= ss;
	susp->s.args[0] = list;
	susp->s.args[1] = zero;
	susp->s.args[2] = show;
	susp->s.args[3] = cons;
	hp	       += suspend_node_size(4);

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = bar;
	cons->c.args[1] = susp;
	hp	       += cons_node_size;
	break;

    case CAPP_KIND:
	switch ( node_tag(list) )
	{
	case NIL_TAG:
	    CHECK_HEAP(cons_node_size);
	    tail = sp[2];
	    sp  += 3;

	    cons	    = (Node *)hp;
	    cons->info	    = &cons_info;
	    cons->c.args[0] = rbracket;
	    cons->c.args[1] = tail;
	    hp		   += cons_node_size;
	    break;

	case CONS_TAG:
	    sp[0] = list;
	    CHECK_HEAP(suspend_node_size(3) + suspend_node_size(4)
		       + cons_node_size);
	    list = sp[0];
	    show = sp[1];
	    tail = sp[2];
	    sp  += 3;

	    susp	    = (Node *)hp;
	    susp->info	    = showTail_lazy_info_table;
	    susp->s.spc	    = ss;
	    susp->s.args[0] = list->c.args[1];
	    susp->s.args[1] = show;
	    susp->s.args[2] = tail;
	    hp		   += suspend_node_size(3);

	    susp2	     = (Node *)hp;
	    susp2->info	     = showp_lazy_info_table;
	    susp2->s.spc     = ss;
	    susp2->s.args[0] = list->c.args[0];
	    susp2->s.args[1] = zero;
	    susp2->s.args[2] = show;
	    susp2->s.args[3] = susp;
	    hp		    += suspend_node_size(4);

	    cons	    = (Node *)hp;
	    cons->info	    = &cons_info;
	    cons->c.args[0] = comma;
	    cons->c.args[1] = susp2;
	    hp		   += cons_node_size;
	    break;

	default:
	    unexpected_tag("showTail", node_tag(list));
	}
	break;

    default:
	invalid_arg("showTail", node_kind(list));
    }

    RETURN(cons);
}

@ 
The \texttt{showString} code is used to print a non-empty string head.
It evaluates the head of the string to a character node and prints
that character. It will then continue to display the remaining string.

<<show.c>>=
static
FUNCTION(showString)
{
    char buf[8];
    Node *hd, *tl, *prev, *tail, *susp, *cons;
 ENTRY_LABEL(showString);
    EVAL_RIGID_CHAR(showString);
    CHECK_HEAP(suspend_node_size(3));

    hd	 = sp[0];
    tl	 = sp[1];
    prev = sp[2];
    tail = sp[3];
    sp	     += 4;

    susp	    = (Node *)hp;
    susp->info	    = showStringTail_lazy_info_table;
    susp->s.spc	    = ss;
    susp->s.args[0] = tl;
    susp->s.args[1] = hd;
    susp->s.args[2] = tail;
    hp		   += suspend_node_size(3);

    cons = prefix_string(lit_char(buf, prev->ch.ch, hd->ch.ch, '"'), susp);
    RETURN(cons);
}

static
FUNCTION(showStringTail)
{
    Node *cons;
 ENTRY_LABEL(showStringTail)
    EVAL_RIGID_POLY(showStringTail);

    if ( sp[0] == nil )
    {
	CHECK_HEAP(cons_node_size);

	cons		= (Node *)hp;
	cons->info	= &cons_info;
	cons->c.args[0] = dblquote;
	cons->c.args[1] = sp[2];
	hp	       += cons_node_size;

	sp += 3;
	RETURN(cons);
    }

    ASSERT(sp[0]->info == &cons_info);
    CHECK_STACK1();
    sp	 -= 1;
    sp[0] = sp[1]->c.args[0];
    sp[1] = sp[1]->c.args[1];
    GOTO(showString);
}

@
The functions \verb|showEFloat| and \verb|showFFloat| convert a
floating-point number into a string using scientific and fixed
point formats, respectively. In order to avoid buffer overflows, these
functions use a dynamically allocated temporary buffer. If the
precision argument is not negative, it specifies the number of decimal
digits for the result.

<<show.c>>=
DECLARE_ENTRYPOINT(__showEFloat);
DECLARE_ENTRYPOINT(__showFFloat);

DECLARE_LABEL(__showEFloat_1);
DECLARE_LABEL(__showFFloat_1);

FUNCTION(__showEFloat)
{
    Node *p, *d;
    EXPORT_LABEL(__showEFloat)
 ENTRY_LABEL(__showEFloat)
    EVAL_RIGID_INT(__showEFloat);
    p	  = sp[0];
    d	  = sp[1];
    sp[0] = d;
    sp[1] = p;
    GOTO(__showEFloat_1);
}

static
FUNCTION(__showEFloat_1)
{
    int	       p, n;
    double     d;
    char       fmt[20], *buf;
    const char *loc;
    Node       *str;
 ENTRY_LABEL(__showEFloat_1)
    EVAL_RIGID_FLOAT(__showEFloat_1);
    get_double_val(d, sp[0]->f);
    p   = long_val(sp[1]);
    str = sp[2];
    if ( p >= 0 )
	sprintf(fmt, "%%.%de", p);
    else
	strcpy(fmt, "%e");
    n   = p >= 0 ? 10 + p : 25;
    buf = (char *)malloc(n);
    if ( buf == NULL )
	sys_error("showEFloat");
    loc = setlocale(LC_NUMERIC, NULL);
    setlocale(LC_NUMERIC, "C");
    sprintf(buf, fmt, d);
    setlocale(LC_NUMERIC, loc);

    sp += 3;
    str = prefix_string(buf, str);
    free(buf);
    RETURN(str);
}

FUNCTION(__showFFloat)
{
    Node *p, *d;
    EXPORT_LABEL(__showFFloat)
 ENTRY_LABEL(__showFFloat)
    EVAL_RIGID_INT(__showFFloat);
    p	  = sp[0];
    d	  = sp[1];
    sp[0] = d;
    sp[1] = p;
    GOTO(__showFFloat_1);
}

static
FUNCTION(__showFFloat_1)
{
    int	       p, n;
    double     d;
    char       fmt[20], *buf;
    const char *loc;
    Node       *str;
 ENTRY_LABEL(__showFFloat_1)
    EVAL_RIGID_FLOAT(__showFFloat_1);
    get_double_val(d, sp[0]->f);
    p   = long_val(sp[1]);
    str = sp[2];
    if ( p >= 0 )
	sprintf(fmt, "%%.%df", p);
    else
	strcpy(fmt, "%f");
    frexp(d, &n);
    if ( p >= 0 )
	n = (n > 0 ? n / 3 + 4 : 5) + p;
    else
	n = (n >= 0 ? n : -n) / 3 + 20;
    buf = (char *)malloc(n);
    if ( buf == NULL )
	sys_error("showFFloat");
    loc = setlocale(LC_NUMERIC, NULL);
    setlocale(LC_NUMERIC, "C");
    sprintf(buf, fmt, d);
    setlocale(LC_NUMERIC, loc);

    sp += 3;
    str = prefix_string(buf, str);
    free(buf);
    RETURN(str);
}

@ 
Due to lack of a better place, we also implement the primitive
\verb|convertToFloat| here, which converts a string into a
floating-point number. The conversion is based on the C function
[[strtod]].

<<show.c>>=
DECLARE_ENTRYPOINT(__convertToFloat);
DECLARE_LABEL(__convertToFloat_1);

FUNCTION(__convertToFloat)
{
    EXPORT_LABEL(__convertToFloat)
 ENTRY_LABEL(__convertToFloat)
    CHECK_STACK(1);
    sp	 -= 1;
    sp[0] = sp[1];
    sp[1] = (Node *)__convertToFloat_1;
    GOTO(nf_string);
}

static
FUNCTION(__convertToFloat_1)
{
    char       *buf;
    const char *loc;
    double     d;
    Node       *s, *r;
 ENTRY_LABEL(__convertToFloat_1)
    /* drop leading zeros */
    s = *sp++;
    while ( is_indir_node(s) )
	s = s->n.node;
    while ( s != nil )
    {
	r = s->c.args[0];
	while ( is_indir_node(r) )
	    r = r->n.node;
	if ( r->ch.ch != '0' )
	    break;
	s = s->c.args[1];
	while ( is_indir_node(s) )
	    s = s->n.node;
    }

    /* convert the remaining string */
    if ( s != nil )
    {
	buf = to_string(s);
	loc = setlocale(LC_NUMERIC, NULL);
	setlocale(LC_NUMERIC, "C");
	d   = strtod(buf, NULL);
	setlocale(LC_NUMERIC, loc);
	free(buf);
    }
    else
	d = 0;

    /* return a fresh number */
    CHECK_HEAP(float_node_size);
    r	    = (Node *)hp;
    r->info = &float_info;
    put_double_val(r->f, d);
    hp += float_node_size;
    RETURN(r);
}
