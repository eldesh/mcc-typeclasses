% -*- noweb-code-mode: c-mode -*-
% $Id: stable.nw 1856 2006-02-19 10:36:44Z wlux $
%
% Copyright (c) 2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Stable Pointers}
Stable pointers allow passing stable references to Curry values to C
code. Stable pointers are implemented as [[malloc]]ed pointers to heap
nodes. In order to prevent the referenced nodes from being garbage
collected, stable pointers are automatically registered as global
roots. Therefore, they must be released explicitly when they are no
longer used. The runtime system provides three functions that create
new stable pointers, dereference stable pointers, and release stable
pointers, respectively.

<<stable.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "eval.h"
#include "data.h"
#include "io_monad.h"
#include "cam.h"

@ 
The primitive [[__newStablePtr]] allocates and initializes a new
stable pointer for its first argument.

\ToDo{Allocating each stable pointer individually with [[malloc]] is
  somewhat inefficient. The system should rather allocate a whole
  block of pointers at a time and manage allocation from that block
  itself.}

<<stable.c>>=
DECLARE_ENTRYPOINT(__newStablePtr);

FUNCTION(__newStablePtr)
{
    Node *ptr, **sptr;
    EXPORT_LABEL(__newStablePtr)
 ENTRY_LABEL(__newStablePtr)
    sptr = (Node **)malloc(sizeof(Node *));
    if ( sptr == NULL )
	sys_error("newStablePtr");
    *sptr = sp[0];
    sp   += 2;
    add_global_root(sptr);

    CHECK_HEAP(ptr_node_size);
    ptr	       = (Node *)hp;
    ptr->info  = &stabptr_info;
    ptr->p.ptr = sptr;
    hp	      += ptr_node_size;

    RETURN(ptr);
}

@ 
The primitive [[__deRefStablePtr]] returns the node associated with a
stable pointer. Note that the result is not evaluated to head normal
form due to the lazy \texttt{IO} monad semantics (cf.
Sect.~\ref{sec:io-monad}).

Some care is necessary when [[__newStablePtr]] was called in the
context of an [[unsafePerformIO]]. If the enclosing computation fails,
the stable pointer itself may still exist, but the associated node may
have been released. In order to prevent crashing the runtime system,
the garbage collector sets global roots to [[0]] in such cases.

<<stable.c>>=
DECLARE_ENTRYPOINT(__deRefStablePtr);

FUNCTION(__deRefStablePtr)
{
    Node **sptr;
    EXPORT_LABEL(__deRefStablePtr)
 ENTRY_LABEL(__deRefStablePtr)
    EVAL_RIGID_PTR(__deRefStablePtr);
    sptr = (Node **)sp[0]->p.ptr;
    if ( *sptr == 0 )
	fail_with("deRefStablePtr: value released by failed computation");
    sp	+= 2;
    RETURN(*sptr);
}

@ 
The primitive [[__freeStablePtr]] releases a stable pointer and annuls
its registration as a global root.

<<stable.c>>=
DECLARE_ENTRYPOINT(__freeStablePtr);

FUNCTION(__freeStablePtr)
{
    Node **sptr;
    EXPORT_LABEL(__freeStablePtr)
 ENTRY_LABEL(__freeStablePtr)
    EVAL_RIGID_PTR(__freeStablePtr);
    sptr = (Node **)sp[0]->p.ptr;

    remove_global_root(sptr);
    free(sptr);

    sp += 2;
    RETURN(unit);
}
