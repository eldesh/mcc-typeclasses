% -*- noweb-code-mode: c-mode -*-
% $Id: stats.nw 1744 2005-08-23 16:17:12Z wlux $
%
% Copyright (c) 2002-2005, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Gathering statistical information}
The compiled Curry program is able to gather some timing information
and memory allocation statistics. The interface to this module
consists of five functions. The function [[stats_init]] will
initialize the module. The argument determines the amount of
information displayed. The function [[stats_terminate]] prints the
final statistics when the program has finished. The functions
[[stats_begin_gc]] and [[stats_end_gc]] switch between normal program
execution and garbage collection for gathering the statistics. In
addition, they expect the amount of allocated memory as
arguments. Space which is freed by backtracking is recorded by the
function [[stats_backtrack]].

<<stats.h>>=
extern void stats_init(int on);
extern void stats_terminate(unsigned long allocated);

extern void stats_begin_gc(unsigned long allocated);
extern void stats_end_gc(unsigned long allocated);

extern void stats_backtrack(unsigned long freed);

@ 
The implementation of the statistics module is pretty straight
forward. In order to determine the expired run-time we will use the
[[rusage]] function which is usually defined in the header file
[[sys/resource.h]] together with the necessary constants.

<<stats.c>>=
#include "config.h"
#include <stdio.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "stats.h"

<<Function prototypes>>
<<Global variables>>

@
The amount of statistics to be presented is determined by the variable
[[show_stats]]. If it is 0, nothing will be shown at all, if is 1 the
total execution time and garbage collector information is presented at
the end of the run and if it is larger, information about allocated
memory and live memory will be shown at every garbage collection, too.

<<Global variables>>=
static int show_stats;

@ 
Timing information will be divided into the execution time in user
space during (normal) program execution, execution time in user space
during garbage collection, and system time for the whole program. The
times are computed with the help of the function [[rusage]], which
returns user and system time information since the program start. In
addition, the elapsed wall clock time is computed using
[[gettimeofday]].

<<Global variables>>=
static struct timeval user_time, gc_time, sys_time, real_time;

@ 
Concerning memory allocation the statistics module computes the number
of allocated \emph{words} and the average number of live words during
each garbage collection. Because these numbers can become quite large,
we use variables of type [[long long]] here.

<<Global variables>>=
unsigned long      n_gc;
unsigned long long total_collect, total_release, total_live;

@
The function [[stats_init]] saves its argument in the global variable
[[show_stats]] and computes the initial timing information. The time
spent in the initialization code will be added as a negative offset
for the collect user mode and system mode times. For that reason
[[stats_init]] should be called after all other initializations have
been performed.

<<stats.c>>=
void
stats_init(int level)
{
    struct rusage  ru;
    struct timeval tv;
    show_stats = level;

    gettimeofday(&tv, NULL);
    getrusage(RUSAGE_SELF, &ru);
    sub_timeval(&user_time, ru.ru_utime);
    sub_timeval(&sys_time, ru.ru_stime);
    sub_timeval(&real_time, tv);
}

@ 
At the end of the program, [[stats_terminate]] is used to display the
statistics information collected during the program. We assume here
that this function is called on regular termination of the program,
i.e., this call will always happen in normal execution mode and not in
garbage collection mode. 

<<stats.c>>=
void
stats_terminate(unsigned long allocated)
{
    struct rusage      ru;
    struct timeval     tv;
    unsigned long long total_alloc;

    gettimeofday(&tv, NULL);
    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&user_time, ru.ru_utime);
    add_timeval(&sys_time, ru.ru_stime);
    add_timeval(&real_time, tv);

    total_alloc = allocated + total_collect + total_release;

    if ( show_stats > 0 )
    {
        fprintf(stderr,
		"[user: %lu.%03us, gc: %lu.%03us,"
		" sys: %lu.%03us, real: %lu.%03us]\n",
                (unsigned long)user_time.tv_sec,
		(unsigned)user_time.tv_usec / 1000,
                (unsigned long)gc_time.tv_sec,
		(unsigned)gc_time.tv_usec / 1000,
                (unsigned long)sys_time.tv_sec,
		(unsigned)sys_time.tv_usec / 1000,
                (unsigned long)real_time.tv_sec,
		(unsigned)real_time.tv_usec / 1000);

        fprintf(stderr, "[%llu words allocated", total_alloc);
        if ( n_gc > 0 )
	    fprintf(stderr,
		    ", %lu collection%s copying %llu words (%.2g%% live)",
		    n_gc, n_gc > 1 ? "s" : "", total_live,
		    (double)total_live / (total_live + total_collect) * 100);
	fprintf(stderr, "]\n");
    }
}

@ 
The functions [[stats_begin_gc]] and [[stats_end_gc]] update the
timing information appropriately at the beginning and end of a garbage
collection. In addition, the allocation counts are updated with the
arguments passed to the functions. Note that only the cells that have
been freed by the garbage collection are actually added to number of
allocated cells. This will ensure that every live cell is counted only
once, viz. when the cell is finally freed. For that reason, the
[[stats_terminate]] function had to update the allocation count with
the number of cells that are still allocated when the program
terminates.

If the value [[show_stats]] is greater than 1, information about the
number of allocated and freed words is displayed to the user at the
end of a collection.

<<Global variables>>=
static unsigned long n_alloc_before_gc;

@ 
<<stats.c>>=
void
stats_begin_gc(unsigned long n_alloc)
{
    struct rusage ru;

    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&user_time, ru.ru_utime);
    sub_timeval(&gc_time, ru.ru_utime);

    n_alloc_before_gc = n_alloc;
    if ( show_stats > 1 )
        fprintf(stderr, "<GC: ");
}

void
stats_end_gc(unsigned long n_alloc)
{
    struct rusage ru;

    n_gc++;
    total_collect += n_alloc_before_gc - n_alloc;
    total_live	  += n_alloc;

    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&gc_time, ru.ru_utime);
    sub_timeval(&user_time, ru.ru_utime);

    if ( show_stats > 1 )
        fprintf(stderr, "%lu live words, %lu words freed>\n",
                n_alloc, n_alloc_before_gc - n_alloc);
}

@ 
The function [[stats_backtrack]] only has to update the number of
allocated words.

<<stats.c>>=
void
stats_backtrack(unsigned long n_freed)
{
    total_release += n_freed;
}

@
Unix systems usually do not provide any functions to compute the sum
or difference of two [[timeval]]s. The statistics module therefore
implements its own functions for that purpose. Note that the micro
seconds part will always be a positive number in the range between 0
and 999999.

<<Function prototypes>>=
static void add_timeval(struct timeval *, struct timeval);
static void sub_timeval(struct timeval *, struct timeval);

@ 
<<stats.c>>=
static void
add_timeval(struct timeval *p_tv1, struct timeval tv2)
{
    p_tv1->tv_sec += tv2.tv_sec;
    p_tv1->tv_usec += tv2.tv_usec;
    if ( p_tv1->tv_usec >= 1000000 )
    {
        p_tv1->tv_sec++;
        p_tv1->tv_usec -= 1000000;
    }
}

static void
sub_timeval(struct timeval *p_tv1, struct timeval tv2)
{
    p_tv1->tv_sec -= tv2.tv_sec;
    if ( p_tv1->tv_usec >= tv2.tv_usec )
        p_tv1->tv_usec -= tv2.tv_usec;
    else
    {
        p_tv1->tv_sec--;
        p_tv1->tv_usec += 1000000 - tv2.tv_usec;
    }
}
