% -*- noweb-code-mode: c-mode -*-
% $Id: threads.nw 2664 2008-04-21 06:43:57Z wlux $
%
% Copyright (c) 2001-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Thread Management}
This section describes the thread management code of the runtime
system. All scheduling is explicit, i.e., a running thread
relinquishes control only when its computation is finished or cannot
be continued.

<<threads.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "spaces.h"
#include "trail.h"
#include "trace.h"

@
The state of a thread that is not running is saved in a thread node
structure which is allocated in the heap. The state information
includes a thread id, the reason for its suspension, the continuation
address, and a pointer to the current exception frame. The runtime
system does not use thread ids in any way except that it requires them
to be non-zero. Nevertheless, they can be quite useful for debugging
compiled programs. Thread nodes can be linked to a thread queue via
the [[next]] field. Suspended threads are added to the wait queue of
the variable or queue-me node that caused the suspension. The runnable
threads are collected in the ready queue, which is available through
the register [[regs.rq]].

When a thread is interrupted and inserted at the head of the ready
queue, its stack segment is retained on the global stack. If a thread
is added to the end of the ready queue or moved to some other queue,
its stack segment must be saved to the heap. A pointer to the saved
stack is recorded in the thread node as well. Since the stack may be
restored at a different address when the thread is resumed, the base
address of the stack is saved in the thread node so that the exception
handler chain can be relocated appropriately. We do not use relative
offsets for the exception handler chain because they could be
misidentified as node pointers by the garbage collector.

A thread may be added to more than one queue. This is implemented by
adding a surrogate to each of the queues. These surrogates are linked
into a ring and share a common thread state, which is allocated
separately in the heap. When the thread is woken through one of the
queues, the state pointer of all its surrogates is set to [[0]]. In
order to distinguish surrogates from regular thread states, the
reserved thread id [[0]] is used for them.

The runtime system maintains the invariant that the head of the ready
queue is never a surrogate whose state pointer is [[0]]. Thus, it is
safe to check [[regs.rq != 0]] in order to test whether other runnable
threads exist.

<<threads.h>>=
# if 0
typedef union thread_node *ThreadQueue; /* already declared in heap.h */
# endif

@ 
<<threads.c>>=
enum { THREAD_TAG, SURROGATE_TAG };

# define THREAD_INFO \
    NodeInfo	     *info; \
    unsigned int     id;		/* (unique) thread id */ \
    ThreadQueue	     next;		/* link to next thread of queue */

struct thread_state {
    THREAD_INFO
    int		     reason;		/* reason for suspension */
    Label	     ip;		/* next instruction to be executed */
    ExceptionFrame   *efp;		/* pointer to exception frame */
    Node	     **ds_base;		/* base address of stack */
    unsigned int     ds_size;		/* size of data stack (segment) */
    Node	     *ds;		/* saved data stack */
};

struct thread_surrogate {
    THREAD_INFO
    ThreadQueue	     thd;		/* pointer to the "real" thread */
    ThreadQueue	     link;		/* ring of surrogates for the thread */
};

union thread_node {
    struct thread_state	    t;
    struct thread_surrogate s;
};

#define thread_node_size	wordsof(union thread_node)
#define thread_state_size	wordsof(struct thread_state)
#define thread_surrogate_size	wordsof(struct thread_surrogate)

static const int ot_thread[] = {
    2,
    word_offsetof(struct thread_state, next),
    word_offsetof(struct thread_state, ds)
};
static NodeInfo thread_info = {
    THREAD_KIND, THREAD_TAG, thread_state_size, ot_thread, 0, no_eval, 0, 0, 0
};

static const int ot_surrogate[] = {
    3,
    word_offsetof(struct thread_surrogate, next),
    word_offsetof(struct thread_surrogate, thd),
    word_offsetof(struct thread_surrogate, link)
};
static NodeInfo surrogate_info = {
    THREAD_KIND, SURROGATE_TAG, thread_surrogate_size, ot_surrogate, 0,
    no_eval, 0, 0, 0
};

@
The thread state includes the reason why a thread was interrupted.
Possible reasons are [[None]] in case of a fork and [[Yield]] if the
thread was performing a yield. The reasons [[Eval]] and [[Delay]] are
used if the thread is suspended due to a queue-me and unbound variable
node, respectively.

<<threads.c>>=
enum suspend_reason {
    None,			/* interrupted */
    Yield,			/* rescheduled due non-determinism */
    Delay,			/* suspended due to unbound variable */
    Eval			/* suspended due to locked application */
};

static const char *reasons[] = { "None", "Yield", "Delay", "Eval" };

@
The interface to the thread management code consists of four global
functions and five entry points. The function [[start_thread]] starts
a new thread, [[stop_thread]] terminates the current thread, and the
functions [[suspend_thread]] and [[delay_thread]] suspend the current
thread and add this thread to the wait queue of the node in register
[[regs.r[0]]]. The former is intended to be used for locked suspended
applications, the latter for unbound variables. The function
[[yield_thread]] interrupts the current thread and moves it to the end
of the ready queue. The function [[yield_delay_thread]] is a
combination of [[yield_thread]] and [[delay_thread]]. It interrupts
the running thread and moves it to the end of the ready queue. In
addition, the running thread is inserted into the wait queue of the
variable in register [[regs.r[0]]] so that it will be woken as well
when that variable is bound.

The functions [[activate_threads]] and [[wake_threads]] wake a list of
suspended threads. Whereas [[activate_threads]] interrupts the current
thread and activates the first woken thread immediately, the running
thread remains active when [[wake_threads]] is used. The last
function, [[join_queues]], concatenates the two thread queues [[tq1]]
and [[tq2]].

<<threads.h>>=
extern void start_thread(unsigned int n, Label l);
DECLARE_LABEL(extern, stop_thread);
DECLARE_LABEL(extern, suspend_thread);
DECLARE_LABEL(extern, delay_thread);
DECLARE_LABEL(extern, yield_thread);
DECLARE_LABEL(extern, yield_delay_thread);
extern Label activate_threads(ThreadQueue wq, Label l);
extern void wake_threads(ThreadQueue wq);
extern ThreadQueue join_queues(ThreadQueue tq1, ThreadQueue tq2);

@
The functions [[save_continuation]], [[restore_continuation]], and
[[resume_continuation]] provide the interface for saving and restoring
computations within an encapsulated search. The function
[[save_continuation]] interrupts the current thread and ensures that
the stack segments of all local threads are saved to the heap. The
function [[restore_continuation]] restores a local computation by
adding its ready queue to the front of the current ready queue without
interrupting the running thread. The function [[resume_continuation]],
on the other hand, sets the ready queue to the one of the restored
computation and activates its first thread immediately. Thus,
[[restore_continuation]] is intended for restoring a search goal
within another search space, whereas [[resume_continuation]] is
intended for resuming a search goal directly. Both functions replace
the continuation address of the first thread from the local
computation's ready queue with the specified address. %'

<<threads.h>>=
extern void save_continuation(unsigned int n_regs);
#if !COPY_SEARCH_SPACE
extern void restore_continuation(unsigned int n_regs, Label l, ThreadQueue rq);
#else
extern void restore_continuation(Label l, ThreadQueue rq);
# define restore_continuation(n_regs, l, rq) restore_continuation(l, rq)
#endif
extern Label resume_continuation(Label l, ThreadQueue rq);

@
<<threads.c>>=
static void new_thread(void);
DECLARE_LABEL(static, activate_thread);
static void terminate_thread(void);
static ThreadQueue interrupt_thread(unsigned int, Label, enum suspend_reason);
static ExceptionFrame *relocate_thread(ExceptionFrame *, int);

static NodeInfo saved_stack_info = {
    VECTOR_KIND, 0, 0, 0, 0, no_eval, 0, 0, 0
};

@
The function [[start_thread]] starts a new thread. It preserves the
first [[n_regs]] argument registers, which can be used to pass
arguments to the new thread. The current thread is interrupted and
will continue its execution at address [[l]]. If this parameter is
[[0]], [[start_thread]] assumes that it is creating the initial thread
of the program or an encapsulated search and therefore no thread is
interrupted. The initial return address of the new thread is set to
[[stop_thread]] so that it is terminated automatically when it returns
from its bottom frame.

<<threads.c>>=
void
start_thread(unsigned int n_regs, Label l)
{
    ThreadQueue thd;

    /* eventually interrupt the current thread */
    if ( l )
    {
	thd	    = interrupt_thread(n_regs, l, None);
	thd->t.next = regs.rq;
	regs.rq	    = thd;
    }

    /* start a new thread */
    new_thread();
    TRACE(("%I starting\n"));

    /* set the ultimate return address */
    regs.ret = stop_thread;
}

@
The [[stop_thread]] code terminates the current thread and
tries to activate the next thread from the ready queue.

<<threads.c>>=
FUNCTION(stop_thread)
{
 ENTRY_LABEL(extern, stop_thread)
    TRACE(("%I terminated\n"));
    terminate_thread();
    GOTO(activate_thread);
}

@
The functions [[suspend_thread]] and [[delay_thread]] suspend the
current thread and add it to the wait queue of the node in register
[[regs.r[0]]]. This node must be either a queue-me node
([[suspend_thread]]) or an unbound variable ([[delay_thread]]). Both
functions must be applied only to local nodes of the current search
space.

<<threads.c>>=
FUNCTION(suspend_thread)
{
    Node	*susp;
    ThreadQueue thd;
 ENTRY_LABEL(extern, suspend_thread)
    thd = interrupt_thread(1, regs.ret, Eval);

    susp = regs.r[0];
    ASSERT(is_tagged_ptr(susp) && is_queueMe_node(susp));
    assert(is_local_space(susp->q.spc));
    SAVE(susp, q.wq);
    thd->t.next = susp->q.wq;
    susp->q.wq  = thd;

    GOTO(activate_thread);
}

FUNCTION(delay_thread)
{
    Node	*var;
    ThreadQueue thd;
 ENTRY_LABEL(extern, delay_thread)
    thd = interrupt_thread(1, regs.ret, Delay);

    var = regs.r[0];
    ASSERT(is_tagged_ptr(var) && is_variable_node(var));
    assert(is_local_space(var->v.spc));
    SAVE(var, v.wq);
    thd->t.next = var->v.wq;
    var->v.wq   = thd;

    GOTO(activate_thread);
}

@ 
The functions [[yield_thread]] and [[yield_delay_thread]] interrupt
the current thread and move it to the end of the ready queue. The
function [[yield_delay_thread]] also adds the thread to the wait queue
of the variable node in register [[regs.r[0]]] so that it is woken
when that variable is bound.

<<threads.c>>=
FUNCTION(yield_thread)
{
    ThreadQueue thd;
 ENTRY_LABEL(extern, yield_thread)
    if ( regs.rq == 0 )
	GOTO_INDIR(regs.ret);

    thd	    = interrupt_thread(0, regs.ret, Yield);
    regs.rq = join_queues(regs.rq, thd);
    GOTO(activate_thread);
}

FUNCTION(yield_delay_thread)
{
    Node	*var;
    ThreadQueue thd, thd1;
 ENTRY_LABEL(extern, yield_delay_thread)
    if ( regs.rq == 0 )
	GOTO_INDIR(regs.ret);

    thd1 = interrupt_thread(1, regs.ret, Yield);
    BEGIN_LOCAL_ROOTS1(thd1)
    CHECK_HEAP(1, 2*thread_surrogate_size);
    END_LOCAL_ROOTS

    var = regs.r[0];
    ASSERT(is_tagged_ptr(var) && is_variable_node(var));
    assert(is_local_space(var->v.spc));
    SAVE(var, v.wq);
    thd		= (ThreadQueue)regs.hp;
    thd->s.info = &surrogate_info;
    thd->s.id   = 0;
    thd->s.thd  = thd1;
    thd->s.next = var->v.wq;
    thd->s.link = (ThreadQueue)(regs.hp + thread_surrogate_size);
    var->v.wq   = thd;

    thd		= (ThreadQueue)(regs.hp + thread_surrogate_size);
    thd->s.info = &surrogate_info;
    thd->s.id   = 0;
    thd->s.thd  = thd1;
    thd->s.next = 0;
    thd->s.link = (ThreadQueue)regs.hp;
    regs.hp    += 2*thread_surrogate_size;

    regs.rq = join_queues(regs.rq, thd);
    GOTO(activate_thread);
}

@ 
The functions [[activate_threads]] and [[wake_threads]] wake a list of
suspended threads and insert them at the head of the ready queue. If
the function [[activate_threads]] is called, the current thread is
interrupted before this operation and the first of the woken threads
is activated. On the other hand, if the function [[wake_threads]] is
called the current thread remains active.

<<threads.c>>=
Label
activate_threads(ThreadQueue wq, Label l)
{
    ThreadQueue thd;

    while ( wq && wq->t.id == 0 && wq->s.thd == 0 )
	wq = wq->t.next;
    if ( wq == 0 )
	return l;

    BEGIN_LOCAL_ROOTS1(wq)
    thd = interrupt_thread(0, l, None);
    END_LOCAL_ROOTS

    thd->t.next = regs.rq;
    regs.rq	= join_queues(wq, thd);

    return activate_thread;
}

void
wake_threads(ThreadQueue wq)
{
    while ( wq && wq->t.id == 0 && wq->s.thd == 0 )
	wq = wq->t.next;
    regs.rq = join_queues(wq, regs.rq);
}

@
The function [[join_queues]] combines the two thread-queues [[tq1]]
and [[tq2]] such that the resulting queue starts with the threads
from [[tq1]] followed by those from [[tq2]].

<<threads.c>>=
ThreadQueue
join_queues(ThreadQueue tq1, ThreadQueue tq2)
{
    ThreadQueue tq;

    /* return the other queue if one queue is empty */
    if ( tq1 == 0 )
	tq = tq2;
    else if ( tq2 == 0 )
	tq = tq1;

    /* otherwise append tq2 to tq1 (destructively) */
    else
    {
	tq = tq1;
	while ( tq1->t.next )
	    tq1 = tq1->t.next;
	SAVE(tq1, t.next);
	tq1->t.next = tq2;
    }

    return tq;
}

@ 
The function [[new_thread]] initializes a new thread, which
automatically becomes the running thread.

A new thread id is generated by incrementing the private variable
[[tid]]. We do not care about overflows, so thread ids may be no
longer unique if you manage to generate more than $2^{32}$ threads.
Recall that the thread id [[0]] is reserved and setting the [[cid]]
register to [[0]] denotes that no thread is running.

<<threads.c>>=
static void
new_thread()
{
    static unsigned int tid;

    /* initialize the thread state */
    if ( tid == 0 )
	tid++;
    regs.cid	 = tid++;
    regs.ds_base = regs.sp;
    regs.efp	 = 0;
}

@ 
The function [[activate_thread]] activates the first thread of the
ready queue. If the ready queue is empty the function jumps to the
deadlock handler of the current context.

<<threads.c>>=
static
FUNCTION(activate_thread)
{
    Label		ip;
    ThreadQueue		thd, sur;
    enum suspend_reason reason;
 ENTRY_LABEL(static, activate_thread)
    /* check for a deadlock */
    if ( regs.rq == 0 )
	GOTO(regs.handlers->deadlock);

    /* activate the head of the ready queue */
    thd	    = regs.rq;
    regs.rq = thd->t.next;
    while ( regs.rq && regs.rq->t.id == 0 && regs.rq->s.thd == 0 )
	regs.rq = regs.rq->t.next;
    if ( thd->t.id == 0 )
    {
	sur = thd;
	thd = (ThreadQueue)sur->s.thd;
	ASSERT(thd->t.id != 0);
	while ( sur->s.thd )
	{
	    ASSERT(sur->s.id == 0 && sur->s.link != 0);
	    SAVE(sur, s.thd);
	    sur->s.thd = 0;
	    sur	       = sur->s.link;
	}
    }
    regs.cid = thd->t.id;
    ip	     = thd->t.ip;
    reason   = (enum suspend_reason)thd->t.reason;

    /* eventually restore the stack */
    if ( thd->t.ds )
    {
	CHECK_STACK(thd->t.ds_size);
	ASSERT(thd->t.ds_size == vector_argc(thd->t.ds));
	regs.ds_base = regs.sp;
	regs.sp	    -= thd->t.ds_size;
	memcpy(regs.sp, thd->t.ds->a.args, thd->t.ds_size * word_size);
    }
    else
	regs.ds_base = regs.sp + thd->t.ds_size;

    /* eventually relocate the exception handler chain */
    regs.efp = thd->t.efp;
    if ( regs.efp && regs.ds_base != thd->t.ds_base )
	regs.efp = relocate_thread(regs.efp, regs.ds_base - thd->t.ds_base);

    /* continue the activated thread */
    if ( reason != None )
	TRACE(("%I resume (%s)\n", reasons[reason]));
    GOTO_INDIR(ip);
}

@ 
The function [[terminate_thread]] terminates the current thread and
discards its stack.

<<threads.c>>=
static void
terminate_thread()
{
    /* deallocate the current thread */
    regs.sp = regs.ds_base;
}

@ 
The function [[interrupt_thread]] interrupts the current thread and
returns a thread node for it. The stack is saved to the heap except if
the thread was interrupted with reason [[None]]. The caller is
responsible for adding the thread to the appropriate queue.

<<threads.c>>=
static ThreadQueue
interrupt_thread(unsigned int n_regs, Label l, enum suspend_reason reason)
{
    Node	 *ds;
    ThreadQueue  thd;
    bool	 save_ds = reason != None;
    unsigned int ds_size = regs.ds_base - regs.sp;

    CHECK_HEAP(n_regs,
	       thread_state_size + (save_ds ? vector_node_size(ds_size) : 0));

    if ( reason != None )
	TRACE(("%I suspend (%s)\n", reasons[reason]));

    /* eventually save the stack */
    if ( save_ds )
    {
	ds	     = (Node *)regs.hp;
	ds->info     = &saved_stack_info;
	ds->a.length = vector_node_size(ds_size);
	memcpy(ds->a.args, regs.sp, ds_size * word_size);
	regs.hp	    += vector_node_size(ds_size);
	regs.sp	     = regs.ds_base;
    }
    else
	ds = 0;

    /* save the thread state */
    assert(regs.cid != 0);
    thd		   = (ThreadQueue)regs.hp;
    thd->t.info	   = &thread_info;
    thd->t.id	   = regs.cid;
    thd->t.next	   = 0;
    thd->t.reason  = reason;
    thd->t.ip	   = l;
    thd->t.efp	   = regs.efp;
    thd->t.ds_base = regs.ds_base;
    thd->t.ds_size = ds_size;
    thd->t.ds	   = ds;
    regs.hp	  += thread_state_size;

    /* return the thread */
    return thd;
}

@
The function [[relocate_thread]] relocates the exception handler chain
when a thread is restored to a different stack offset.

<<threads.c>>=
static ExceptionFrame *
relocate_thread(ExceptionFrame *efp, int dist)
{
    ExceptionFrame *fp;

    if ( efp )
    {
	efp = (ExceptionFrame *)((Node **)efp + dist);
	for ( fp = efp; fp->frame; fp = fp->frame )
	    fp->frame = (ExceptionFrame *)((Node **)fp->frame + dist);
    }

    return efp;
}

@
When the abstract machine returns from an encapsulated search, the
current state of the local computation is saved to the heap. The
function [[save_continuation]] interrupts the running thread and
ensures that all threads from the ready queue have their stack
segments saved to the heap. In order to share the saved ready queue of
the local computation between the different alternatives of a
non-deterministic continuation, the actual continuation address is
saved independently of the ready queue. Therefore, no continuation
address is passed to [[save_continuation]].

Note that the code in [[save_continuation]] examines only thread nodes
but no surrogates. This is safe because the stacks of those threads
which are not part of the ready queue are always saved in the heap and
surrogates are used only when a thread is member of more than one
queue.  Obviously, at least one of these queues cannot be the ready
queue and, hence, the stack is already saved to the heap.

Also note that [[restore_continuation]] creates a new head for the
ready queue before updating the continuation address. This is to
prevent accidental overwriting of the address if another related
continuation is restored before the thread is actually woken. No such
precaution is necessary when the runtime system was configured with
the \texttt{--enable-copying} option and neither in function
[[resume_continuation]] as it activates the first thread immediately.

<<threads.c>>=
void
save_continuation(unsigned int n_regs)
{
    unsigned int ds_size;
    Node	 *ds;
    ThreadQueue  tq;

    /* interrupt the current thread */
    tq	       = interrupt_thread(n_regs, 0, None);
    tq->t.next = regs.rq;
    regs.rq    = tq;

    /* save all stack segments to the heap */
    BEGIN_LOCAL_ROOTS1(tq)
    for ( tq = regs.rq; tq; tq = tq->t.next )
	if ( tq->t.id && tq->t.ds == 0 )
	{
	    ds_size = tq->t.ds_size;

	    CHECK_HEAP(n_regs, vector_node_size(ds_size));
	    SAVE(tq, t.ds);
	    ds = tq->t.ds = (Node *)regs.hp;
	    ds->info	  = &saved_stack_info;
	    ds->a.length  = vector_node_size(ds_size);
	    memcpy(ds->a.args, regs.sp, ds_size * word_size);
	    regs.hp	 += vector_node_size(ds_size);

	    regs.sp += ds_size;
	    ASSERT(regs.sp == tq->t.ds_base);
	}
    END_LOCAL_ROOTS
}

void
#if !COPY_SEARCH_SPACE
restore_continuation(unsigned int n_regs, Label l, ThreadQueue tq)
#else
# undef restore_continuation
restore_continuation(Label l, ThreadQueue tq)
#endif
{
    assert(tq && tq->t.id != 0);

    /* update the continuation address of the first restored thread */
#if !COPY_SEARCH_SPACE
    BEGIN_LOCAL_ROOTS1(tq)
    CHECK_HEAP(n_regs, thread_node_size);
    memcpy(regs.hp, tq, thread_node_size * word_size);
    tq	     = (ThreadQueue)regs.hp;
    regs.hp += thread_node_size;
    END_LOCAL_ROOTS
#endif
    tq->t.ip = l;

    /* wake all threads of the search space and add them to the ready queue */
    wake_threads(tq);
}

Label
resume_continuation(Label l, ThreadQueue tq)
{
    /* restore the continuation's ready queue */
    assert(tq && tq->t.id != 0);
    regs.rq = tq;

    /* update the continuation address of the first restored thread */
    regs.rq->t.ip = l;

    /* activate the first thread */
    return activate_thread;
}
