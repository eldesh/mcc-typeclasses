% -*- noweb-code-mode: c-mode -*-
% $Id: vars.nw 2709 2008-05-20 08:43:20Z wlux $
%
% Copyright (c) 2002-2008, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Naming variables}
When printing the result of a goal, we need to associate variable
nodes with unique names. To this end, the runtime system maintains a
dictionary that maps the addresses of variable nodes onto their names.
This dictionary is also consulted by the \texttt{dval} function.

<<vars.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "stack.h"
#include "vars.h"

@ 
At present the dictionary is implemented as a single-linked list
rooted in [[names_dict]] and a pointer to the last node of the
dictionary is saved in [[names_tail]].

The type of dictionary nodes has to be exported because the garbage
collector must update the node pointers in the dictionary.
\textbf{These declarations should not be used in any other module!}

\ToDo{Use a hash table for the dictionary.}

<<vars.h>>=
struct dict_node {
    Node	     *node;		/* variable node         */
    const char	     *name;		/* name of variables     */
    struct dict_node *next;		/* link to next variable */
};

extern struct dict_node *names_dict, *names_tail;

@ 
<<vars.c>>=
struct dict_node *names_dict;
struct dict_node *names_tail;

@ 
New entries can be inserted into the dictionary using the function
[[add_name]]. The name will [[free]]d when the dictionary is released,
so the [[name]] argument should point to a [[malloc]]ed string --
except for entries allocated in the startup code that are never going
to be released.

<<vars.h>>=
extern void add_name(Node *node, const char *name);

@ 
<<vars.c>>=
void
add_name(Node *node, const char *name)
{
    struct dict_node *next;

    next = (struct dict_node *)malloc(sizeof(struct dict_node));
    if ( next == 0 )
	sys_error("add_name");

    next->node = node;
    next->name = name;
    next->next = 0;

    if ( names_tail == 0 )
    {
	ASSERT(names_dict == 0);
	names_dict = names_tail = next;
    }
    else
    {
	names_tail->next = next;
	names_tail	 = next;
    }
}

@ 
The function [[release_names]] releases all dictionary entries after
[[new_tail]]. If this argument is [[0]] the whole dictionary is
released.

This function should be used only to remove the tail of the dictionary
that was created since the last choice point or search context was
installed. Releasing longer tails might leave dangling pointers in the
stack.

<<vars.h>>=
extern void release_names(struct dict_node *new_tail);

@ 
<<vars.c>>=
void
release_names(struct dict_node *new_tail)
{
    struct dict_node *curr, *next;

    if ( new_tail != names_tail )
    {
	names_tail = new_tail;
	if ( new_tail == 0 )
	{
	    curr       = names_dict;
	    names_dict = 0;
	}
	else
	{
	    curr	   = new_tail->next;
	    new_tail->next = 0;
	}

	for ( ; curr; curr = next )
	{
	    next = curr->next;
	    free((char *)curr->name);
	    free(curr);
	}
    }
}

@ 
In order to cleanup the dictionary after a garbage collection, the
function [[cleanup_names]] should be used. This function looks for
dictionary nodes whose referenced (variable) node has been released
and in turn releases those dictionary nodes themselves. In addition,
the saved dictionary tails in choice points and search contexts are
updated to a preceding live dictionary node if necessary.

The function proceeds in three steps. First, the dictionary list is
reversed in order to be able to advance dictionary pointers backwards.
In the next step, the choice points and search contexts in the stack
are processed from top to bottom and all dictionary pointers are set
to the next dictionary node with a non-null node pointer. In the last
phase, the dictionary list is reversed again and all nodes which do
not point to a node are released. In addition, the tail pointer of the
dictionary is set to the last live dictionary node (if any).

\ToDo{We can speed up the second phase a bit by making use of the fact
that many choice points will save the same dictionary. We only need to
find the next used dictionary for the first choice point of such a
group and can reuse the new dictionary tail for the other choice
points of that group.}

<<vars.h>>=
extern void cleanup_names(void);

@ 
<<vars.c>>=
void
cleanup_names()
{
    struct dict_node *prev, *curr, *next;
    Choicepoint	     *cp;

    /* Phase I: reverse the dictionary */
    prev = 0;
    for ( curr = names_dict; curr; curr = next )
    {
	next	   = curr->next;
	curr->next = prev;
	prev	   = curr;
    }

    /* Phase II: update the control stack */
    for ( cp = regs.bp; cp; cp = cp->btBp )
    {
	curr = cp->btDict;
	while ( curr && curr->node == 0 )
	    curr = curr->next;
	cp->btDict = curr;
    }

    /* Phase III: re-reverse the dictionary and release unused nodes */
    for ( names_tail = prev;
	  names_tail && names_tail->node == 0;
	  names_tail = names_tail->next )
	;

    curr = prev;
    prev = 0;
    for ( ; curr; curr = next )
    {
	next = curr->next;
	if ( curr->node == 0 )
	{
	    free((char *)curr->name);
	    free(curr);
	}
	else
	{
	    curr->next = prev;
	    prev       = curr;
	}
    }
    names_dict = prev;
}

@ 
The function [[lookup_name]] returns the name of the given (variable)
node from the dictionary. If there is no name in the dictionary, a new
name is created with the help of the local function [[gen_name]].

<<vars.h>>=
extern const char *lookup_name(Node *node);

@ 
<<vars.c>>=
static const char *gen_name(void);

extern const char *lookup_name(Node *node)
{
    const char	     *name;
    struct dict_node *dict;

    for ( dict = names_dict; dict; dict = dict->next )
	if ( dict->node == node )
	    return dict->name;

    name = gen_name();
    add_name(node, name);
    return name;
}

@ 
The private function [[gen_name]] uses the counter [[dict_index]] in
order to create unique names. In order to avoid name conflicts with
entities defined in the program, all generated names start with an
underscore.

\ToDo{Provide a runtime option to choose either uppercase or lowercase
names for generated names.}

\ToDo{Reset the counter when the dictionary is released during
backtracking.}

<<vars.c>>=
static unsigned long dict_index;

static const char *
gen_name()
{
    char name[13];

    name[0] = '_';
    name[1] = 'a' + dict_index % 26;
    if ( dict_index < 26 )
	name[2] = '\0';
    else
	sprintf(name + 2, "%ld", dict_index / 26);
    dict_index++;

    return (const char *)strdup(name);
}
