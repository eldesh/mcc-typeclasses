% -*- noweb-code-mode: c-mode -*-
% $Id: vector.nw 2309 2007-06-20 11:52:36Z wlux $
%
% Copyright (c) 2002-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Mutable Vectors}
Mutable vectors are implemented essentially as tuples with an
arbitrary length. We use the string \texttt{"(,)"} as closure name for
vectors because this will make the printing code treat vectors as tuples.

<<vector.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "eval.h"
#include "trail.h"
#include "io_monad.h"
#include "vector.h"

static NodeInfo vector_info = {
    VECTOR_KIND, 0, 0, 0, "(,)", eval_whnf, 0, 0, 0
};

static const struct vector_node empty = {
    &vector_info, vector_node_size(0), { 0 }
};

@ 
Two vector nodes are considered equal, if they are physically the
same.

<<vector.h>>=
extern Node *primEqIOVector(Node *, Node *);

@ 
<<vector.c>>=
DECLARE_CONST(__Prelude__False);
DECLARE_CONST(__Prelude__True);

#define Prelude_False CONST(__Prelude__False)
#define Prelude_True  CONST(__Prelude__True)

Node *
primEqIOVector(Node *x, Node *y)
{
    return x == y ? Prelude_True : Prelude_False;
}

@ 
The function [[primNewIOVector]] allocates a new vector with the
specified length and assigns an initial value to every element of the
vector. The initial value is passed in the form \texttt{Wrap}~$e$ in
order to prevent evaluation of $e$ by the foreign function interface
code.

<<vector.h>>=
extern Node *primNewIOVector(Node *, Node *);

@ 
<<vector.c>>=
Node *
primNewIOVector(Node *len, Node *wrappedArg)
{
    long i, n;
    Node *init, *vec;

    n = long_val(len);
    if ( n < 0 )
	fail_with("newIOVector: negative length (%ld)", n);

    if ( n == 0 )
	vec = (Node *)&empty;
    else
    {
	init = wrappedArg->c.args[0];
	while ( is_tagged_ptr(init) && is_indir_node(init) )
	    init = init->n.node;

	BEGIN_LOCAL_ROOTS1(init)
	CHECK_HEAP(0, vector_node_size(n));
	vec	      = (Node *)regs.hp;
	vec->info     = &vector_info;
	vec->a.length = vector_node_size(n);
	for ( i = 0; i < n; i++ )
	    vec->a.args[i] = init;
	regs.hp += vector_node_size(n);
	END_LOCAL_ROOTS
    }

    return vec;
}

@ 
The function [[primCopyIOVector]] creates a copy of a vector. The copy
of an empty vector is always the vector itself.

<<vector.h>>=
extern Node *primCopyIOVector(Node *);

@ 
<<vector.c>>=
Node *
primCopyIOVector(Node *vec)
{
    if ( vector_argc(vec) > 0 )
    {
	BEGIN_LOCAL_ROOTS1(vec)
	CHECK_HEAP(0, vec->a.length);
	memcpy(regs.hp, vec, vec->a.length * word_size);
	vec	 = (Node *)regs.hp;
	regs.hp += vec->a.length;
	END_LOCAL_ROOTS
    }

    return vec;
}

@ 
The function [[primReadIOVector]] returns the $i$th element of a
vector. If the index is out of range, the program fails.

<<vector.h>>=
extern Node *primReadIOVector(Node *, Node *);

@ 
<<vector.c>>=
Node *
primReadIOVector(Node *vec, Node *ofs)
{
    long i = long_val(ofs);

    if ( i < 0 || (unsigned long)i >= vector_argc(vec) )
	fail_with("readIOVector: index out range (%ld)", i);
    return vec->a.args[i];
}

@ 
The function [[primWriteIOVector]] updates the $i$th element of a
vector. As for [[primReadIOVector]], the program fails if the index is
out of range. The assigned value is passed in the form
\texttt{Wrap}~$e$ in order to prevent evaluation of $e$ by the foreign
function interface code. The old value of the $i$th element is
recorded on the trail in order prevent program crashes when mutable
vectors are used in non-deterministic code via [[unsafePerformIO]].

<<vector.h>>=
extern void primWriteIOVector(Node *, Node *, Node *);

@ 
<<vector.c>>=
void
primWriteIOVector(Node *vec, Node *ofs, Node *wrappedArg)
{
    long i = long_val(ofs);

    if ( i < 0 || (unsigned long)i >= vector_argc(vec) )
	fail_with("writeIOVector: index out range (%ld)", i);
    SAVE(vec, a.args[i]);
    vec->a.args[i] = wrappedArg->c.args[0];
}

@ 
The function [[primLengthIOVector]] returns the length of a vector,
i.e., the number of elements that can be stored in the vector.

<<vector.h>>=
extern Node *primLengthIOVector(Node *);

@ 
<<vector.c>>=
Node *
primLengthIOVector(Node *vec)
{
    long n;
    Node *r;

    n = vector_argc(vec);
#if !NO_POINTER_TAGS
    if ( !is_large_int(n) )
	r = tag_int(n);
    else
#endif
    {
	CHECK_HEAP(0, int_node_size);
	r	 = (Node *)regs.hp;
	r->info	 = &int_info;
	r->i.i	 = n;
	regs.hp += int_node_size;
    }

    return r;
}
