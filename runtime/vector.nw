% -*- noweb-code-mode: c-mode -*-
% $Id: vector.nw 2303 2007-06-20 07:22:47Z wlux $
%
% Copyright (c) 2002-2007, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Mutable Vectors}
Mutable vectors are implemented essentially as tuples with an
arbitrary length. We use the string \texttt{"(,)"} as closure name for
vectors because this will make the printing code treat vectors as tuples.

<<vector.c>>=
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "regs.h"
#include "heap.h"
#include "eval.h"
#include "trail.h"
#include "io_monad.h"
#include "vector.h"

static NodeInfo vector_info = {
    VECTOR_KIND, 0, 0, 0, "(,)", eval_whnf, 0, 0, 0
};

static const struct vector_node empty = {
    &vector_info, vector_node_size(0), { 0 }
};

@ 
Two vector nodes are considered equal, if they are physically the
same.

<<vector.h>>=
#define primEqIOVector(x,y) ((x) == (y))

@ 
The function [[primNewIOVector]] allocates a new vector with the
specified length and assigns an initial value to every element of the
vector. The initial value is passed in the form \texttt{Wrap}~$e$ in
order to prevent evaluation of $e$ by the foreign function interface
code.

<<vector.h>>=
extern Node *primNewIOVector(long, Node *);

@ 
<<vector.c>>=
Node *
primNewIOVector(long n, Node *wrappedArg)
{
    long i;
    Node *vec, *init;

    if ( n < 0 )
	fail_with("newIOVector: negative length (%ld)", n);
    if ( n == 0 )
	vec = (Node *)&empty;
    else
    {
	init = wrappedArg->c.args[0];
	while ( is_tagged_ptr(init) && is_indir_node(init) )
	    init = init->n.node;
	BEGIN_LOCAL_ROOTS1(init)
	CHECK_HEAP(0, vector_node_size(n));
	vec	      = (Node *)regs.hp;
	vec->info     = &vector_info;
	vec->a.length = vector_node_size(n);
	for ( i = 0; i < n; i++ )
	    vec->a.args[i] = init;
	regs.hp += vector_node_size(n);
	END_LOCAL_ROOTS
    }

    return vec;
}

@ 
The function [[primCopyIOVector]] creates a copy of a vector. The copy
of an empty vector is always the vector itself.

<<vector.h>>=
extern Node *primCopyIOVector(Node *);

@ 
<<vector.c>>=
Node *
primCopyIOVector(Node *vec)
{
    if ( vector_argc(vec) > 0 )
    {
	BEGIN_LOCAL_ROOTS1(vec)
	CHECK_HEAP(0, vec->a.length);
	memcpy(regs.hp, vec, vec->a.length * word_size);
	vec	 = (Node *)regs.hp;
	regs.hp += vec->a.length;
	END_LOCAL_ROOTS
    }

    return vec;
}

@ 
The function [[primReadIOVector]] returns the $i$th element of a
vector. If the index is out of range, the program is aborted.

<<vector.h>>=
extern Node *primReadIOVector(Node *, long);

@ 
<<vector.c>>=
Node *
primReadIOVector(Node *vec, long i)
{
    if ( i < 0 || (unsigned long)i >= vector_argc(vec) )
	fail_with("readIOVector: index out range (%ld)", i);
    return vec->a.args[i];
}

@ 
The function [[primWriteIOVector]] updates the $i$th element of a
vector. As for [[primReadIOVector]], the program is aborted if the
index is out of range. The assigned value is passed in the form
\texttt{Wrap}~$e$ in order to prevent evaluation of $e$ by the foreign
function interface code. The old value of the $i$th element is
recorded on the trail in order prevent program crashes when mutable
vectors are used in non-deterministic code via [[unsafePerformIO]].

<<vector.h>>=
extern void primWriteIOVector(Node *, long, Node *);

@ 
<<vector.c>>=
void
primWriteIOVector(Node *vec, long i, Node *wrappedArg)
{
    if ( i < 0 || (unsigned long)i >= vector_argc(vec) )
	fail_with("writeIOVector: index out range (%ld)", i);
    SAVE(vec, a.args[i]);
    vec->a.args[i] = wrappedArg->c.args[0];
}

@ 
The macro [[primLengthIOVector]] returns the length of a vector, i.e.,
the number of elements that can be stored in the vector.

<<vector.h>>=
#define primLengthIOVector(vec)	vector_argc(vec)
